name: Production Env Tests

on:
  push:
    branches: [master]
  pull_request:
    branches: [master]

jobs:
  run_tests:
    runs-on: ubuntu-latest
    env:
      CI_FREE_UP_SPACE: "false"

    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Set up python
        uses: actions/setup-python@v5
        with:
          python-version: "3.10"

      - name: Install Poetry
        uses: snok/install-poetry@v1
        with:
          version: 1.8.2
          virtualenvs-create: true
          virtualenvs-in-project: true

      - name: Load cached venv
        id: cached-poetry-dependencies
        uses: actions/cache@v3
        with:
          path: .venv
          key: venv-${{ runner.os }}-${{ hashFiles('poetry.lock') }}

      - name: Install dependencies
        if: steps.cached-poetry-dependencies.outputs.cache-hit != 'true'
        run: poetry install --no-interaction --no-root

      - name: Build data paths for workers
        run: |
          python tests/worker_data_paths_builder.py \
            --local-workers localworker3 localworker2 localworker1 \
            --global-worker globalworker \
            --test-data-folder tests/test_data

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: network=host

      - name: Create k8s Kind Cluster
        id: kind
        uses: helm/kind-action@v1.13.0
        with:
          cluster_name: kind
          config: tests/prod_env_tests/deployment_configs/kind_configuration/kind_cluster.yaml
          registry: true
          registry_name: kind-registry
          registry_port: 5001

      - name: Configure Kind registry on nodes
        run: |
          REG_HOST="localhost:5001"
          # Wire the local registry into Kind: map runner localhost to the in-network registry
          # so containerd on each node can pull freshly built images without a remote registry.
          for node in $(kind get nodes --name kind); do
            docker exec "$node" mkdir -p "/etc/containerd/certs.d/${REG_HOST}"
            cat <<'EOF' | docker exec -i "$node" tee "/etc/containerd/certs.d/${REG_HOST}/hosts.toml"
          [host."http://kind-registry:5000"]
            capabilities = ["pull", "resolve", "push"]
          EOF
          done

      - name: Load Docker buildx cache
        uses: actions/cache@v3
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ hashFiles('exaflow/**', 'aggregation_server/**') }}
          restore-keys: |
            ${{ runner.os }}-buildx-

      - name: Build and push images with bake
        uses: docker/bake-action@v5
        with:
          files: ./docker-bake.hcl
          targets: default
          push: true
          set: |
            *.cache-from=type=local,src=/tmp/.buildx-cache
            *.cache-to=type=local,dest=/tmp/.buildx-cache-new,mode=max
        env:
          REGISTRY: localhost:5001

        # Temp fix
        # https://github.com/docker/build-push-action/issues/252
        # https://github.com/moby/buildkit/issues/1896
      - name: Move Docker buildx cache
        run: |
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache

      - name: Install Helm
        uses: azure/setup-helm@v3
        with:
          version: 3.9.1
        id: install

      - name: Taint Nodes
        run: |
          kubectl taint nodes master node-role.kubernetes.io/control-plane-
          kubectl label node master master=true
          kubectl label node localworker1 worker=true
          kubectl label node localworker2 worker=true
          kubectl label node localworker3 worker=true

      - name: Get container disk space
        run: df -h

      - name: Free up space, by removing dotnet, android and haskell unused libs.
        if: env.CI_FREE_UP_SPACE == 'true'
        run: |
          rm -rf /usr/share/dotnet
          rm -rf /opt/ghc
          sudo rm -rf /usr/local/lib/android

      - name: Get container disk space
        if: env.CI_FREE_UP_SPACE == 'true'
        run: df -h

      - name: Copy prod_env_tests values.yaml
        run: cp -r tests/prod_env_tests/deployment_configs/kubernetes_values.yaml kubernetes/values.yaml

      - name: Rewrite image repos for local registry
        run: |
          REG="localhost:5001"
          # Point Helm values at the local Kind registry so pods pull the locally built images.
          sed -i "s#repository: madgik#repository: ${REG}/madgik#g" kubernetes/values.yaml

      - name: Print Helm Templates
        run: helm template kubernetes/

      - name: Deploy Helm
        run: helm install exaflow kubernetes/ --debug

      - name: Wait for pods to get healthy
        run: |
          if ! timeout 300 bash -c '
          set -euo pipefail

          while true; do
            # Get pods and check if all are ready (1/1, 2/2, 3/3, 4/4)
            if kubectl get pods --no-headers | awk '\''{if ($2 != "1/1" && $2 != "2/2" && $2 != "3/3" && $2 != "4/4") exit 1;}'\''; then
              echo "All pods are ready!"
              break
            else
              echo "Some pods are not ready yet:"
              kubectl get pods -o wide

              # Find clearly "bad" pods (crashing / failing)
              crashing_pods=$(kubectl get pods --no-headers \
                | awk '\''$3 ~ /CrashLoopBackOff|Error|ImagePullBackOff|CreateContainerError/ {print $1}'\'')

              if [ -n "$crashing_pods" ]; then
                echo "Detected crashing pods: $crashing_pods"

                for p in $crashing_pods; do
                  echo "===== DESCRIBE POD $p ====="
                  kubectl describe pod "$p" || true

                  echo "===== LOGS POD $p (all containers) ====="
                  kubectl logs "$p" --all-containers --tail=200 || true

                  echo "===== PREVIOUS LOGS POD $p (if any) ====="
                  kubectl logs "$p" --all-containers --previous --tail=200 || true
                done

                echo "Failing because at least one pod is crashing."
                exit 1
              fi

              sleep 5
            fi
          done
          '; then
            exit_code=$?
            if [ "$exit_code" -eq 124 ]; then
              echo "Timeout exceeded while waiting for pods. Describing unready pods..."
              unready_pods=$(kubectl get pods --no-headers \
                | awk '$2 != "1/1" && $2 != "2/2" && $2 != "3/3" && $2 != "4/4" {print $1}')
              if [ -n "$unready_pods" ]; then
                for p in $unready_pods; do
                  echo "===== DESCRIBE POD $p ====="
                  kubectl describe pod "$p" || true
                done
              else
                echo "No unready pods found to describe."
              fi
            fi
            exit "$exit_code"
          fi


      - name: Controller logs
        run: kubectl logs -l app=exaflow-controller --tail -1

      - name: Globalnode logs
        run: kubectl logs -l nodeType=globalworker -c worker --tail -1

      - name: Localnode logs
        run: kubectl logs -l nodeType=localworker -c worker --tail -1

      - name: Controller logs (post run)
        uses: webiny/action-post-run@3.0.0
        with:
          run: kubectl logs -l app=exaflow-controller --tail -1

      - name: Globalnode logs (post run)
        uses: webiny/action-post-run@3.0.0
        with:
          run: kubectl logs -l nodeType=globalworker -c worker --tail -1

      - name: Localnode logs (post run)
        uses: webiny/action-post-run@3.0.0
        with:
          run: kubectl logs -l nodeType=localworker -c worker --tail -1

      - name: Wait before WLA update
        run: sleep 5

      - name: Run Worker Landscape Aggregator update
        run: curl -X POST "http://172.17.0.1:5000/wla"

      - name: Run Healthcheck
        run: curl "http://172.17.0.1:5000/healthcheck"

      - name: Run production env tests
        run: poetry run pytest tests/prod_env_tests --verbosity=4
