#define _CFFI_USE_EMBEDDING
#define _CFFI_

/* We try to define Py_LIMITED_API before including Python.h.

   Mess: we can only define it if Py_DEBUG, Py_TRACE_REFS and
   Py_REF_DEBUG are not defined.  This is a best-effort approximation:
   we can learn about Py_DEBUG from pyconfig.h, but it is unclear if
   the same works for the other two macros.  Py_DEBUG implies them,
   but not the other way around.

   The implementation is messy (issue #350): on Windows, with _MSC_VER,
   we have to define Py_LIMITED_API even before including pyconfig.h.
   In that case, we guess what pyconfig.h will do to the macros above,
   and check our guess after the #include.

   Note that on Windows, with CPython 3.x, you need >= 3.5 and virtualenv
   version >= 16.0.0.  With older versions of either, you don't get a
   copy of PYTHON3.DLL in the virtualenv.  We can't check the version of
   CPython *before* we even include pyconfig.h.  ffi.set_source() puts
   a ``#define _CFFI_NO_LIMITED_API'' at the start of this file if it is
   running on Windows < 3.5, as an attempt at fixing it, but that's
   arguably wrong because it may not be the target version of Python.
   Still better than nothing I guess.  As another workaround, you can
   remove the definition of Py_LIMITED_API here.

   See also 'py_limited_api' in cffi/setuptools_ext.py.
*/
#if !defined(_CFFI_USE_EMBEDDING) && !defined(Py_LIMITED_API)
#  ifdef _MSC_VER
#    if !defined(_DEBUG) && !defined(Py_DEBUG) && !defined(Py_TRACE_REFS) && !defined(Py_REF_DEBUG) && !defined(_CFFI_NO_LIMITED_API)
#      define Py_LIMITED_API
#    endif
#    include <pyconfig.h>
     /* sanity-check: Py_LIMITED_API will cause crashes if any of these
        are also defined.  Normally, the Python file PC/pyconfig.h does not
        cause any of these to be defined, with the exception that _DEBUG
        causes Py_DEBUG.  Double-check that. */
#    ifdef Py_LIMITED_API
#      if defined(Py_DEBUG)
#        error "pyconfig.h unexpectedly defines Py_DEBUG, but Py_LIMITED_API is set"
#      endif
#      if defined(Py_TRACE_REFS)
#        error "pyconfig.h unexpectedly defines Py_TRACE_REFS, but Py_LIMITED_API is set"
#      endif
#      if defined(Py_REF_DEBUG)
#        error "pyconfig.h unexpectedly defines Py_REF_DEBUG, but Py_LIMITED_API is set"
#      endif
#    endif
#  else
#    include <pyconfig.h>
#    if !defined(Py_DEBUG) && !defined(Py_TRACE_REFS) && !defined(Py_REF_DEBUG) && !defined(_CFFI_NO_LIMITED_API)
#      define Py_LIMITED_API
#    endif
#  endif
#endif

#include <Python.h>
#ifdef __cplusplus
extern "C" {
#endif
#include <stddef.h>

/* This part is from file 'cffi/parse_c_type.h'.  It is copied at the
   beginning of C sources generated by CFFI's ffi.set_source(). */

typedef void *_cffi_opcode_t;

#define _CFFI_OP(opcode, arg)   (_cffi_opcode_t)(opcode | (((uintptr_t)(arg)) << 8))
#define _CFFI_GETOP(cffi_opcode)    ((unsigned char)(uintptr_t)cffi_opcode)
#define _CFFI_GETARG(cffi_opcode)   (((intptr_t)cffi_opcode) >> 8)

#define _CFFI_OP_PRIMITIVE       1
#define _CFFI_OP_POINTER         3
#define _CFFI_OP_ARRAY           5
#define _CFFI_OP_OPEN_ARRAY      7
#define _CFFI_OP_STRUCT_UNION    9
#define _CFFI_OP_ENUM           11
#define _CFFI_OP_FUNCTION       13
#define _CFFI_OP_FUNCTION_END   15
#define _CFFI_OP_NOOP           17
#define _CFFI_OP_BITFIELD       19
#define _CFFI_OP_TYPENAME       21
#define _CFFI_OP_CPYTHON_BLTN_V 23   // varargs
#define _CFFI_OP_CPYTHON_BLTN_N 25   // noargs
#define _CFFI_OP_CPYTHON_BLTN_O 27   // O  (i.e. a single arg)
#define _CFFI_OP_CONSTANT       29
#define _CFFI_OP_CONSTANT_INT   31
#define _CFFI_OP_GLOBAL_VAR     33
#define _CFFI_OP_DLOPEN_FUNC    35
#define _CFFI_OP_DLOPEN_CONST   37
#define _CFFI_OP_GLOBAL_VAR_F   39
#define _CFFI_OP_EXTERN_PYTHON  41

#define _CFFI_PRIM_VOID          0
#define _CFFI_PRIM_BOOL          1
#define _CFFI_PRIM_CHAR          2
#define _CFFI_PRIM_SCHAR         3
#define _CFFI_PRIM_UCHAR         4
#define _CFFI_PRIM_SHORT         5
#define _CFFI_PRIM_USHORT        6
#define _CFFI_PRIM_INT           7
#define _CFFI_PRIM_UINT          8
#define _CFFI_PRIM_LONG          9
#define _CFFI_PRIM_ULONG        10
#define _CFFI_PRIM_LONGLONG     11
#define _CFFI_PRIM_ULONGLONG    12
#define _CFFI_PRIM_FLOAT        13
#define _CFFI_PRIM_DOUBLE       14
#define _CFFI_PRIM_LONGDOUBLE   15

#define _CFFI_PRIM_WCHAR        16
#define _CFFI_PRIM_INT8         17
#define _CFFI_PRIM_UINT8        18
#define _CFFI_PRIM_INT16        19
#define _CFFI_PRIM_UINT16       20
#define _CFFI_PRIM_INT32        21
#define _CFFI_PRIM_UINT32       22
#define _CFFI_PRIM_INT64        23
#define _CFFI_PRIM_UINT64       24
#define _CFFI_PRIM_INTPTR       25
#define _CFFI_PRIM_UINTPTR      26
#define _CFFI_PRIM_PTRDIFF      27
#define _CFFI_PRIM_SIZE         28
#define _CFFI_PRIM_SSIZE        29
#define _CFFI_PRIM_INT_LEAST8   30
#define _CFFI_PRIM_UINT_LEAST8  31
#define _CFFI_PRIM_INT_LEAST16  32
#define _CFFI_PRIM_UINT_LEAST16 33
#define _CFFI_PRIM_INT_LEAST32  34
#define _CFFI_PRIM_UINT_LEAST32 35
#define _CFFI_PRIM_INT_LEAST64  36
#define _CFFI_PRIM_UINT_LEAST64 37
#define _CFFI_PRIM_INT_FAST8    38
#define _CFFI_PRIM_UINT_FAST8   39
#define _CFFI_PRIM_INT_FAST16   40
#define _CFFI_PRIM_UINT_FAST16  41
#define _CFFI_PRIM_INT_FAST32   42
#define _CFFI_PRIM_UINT_FAST32  43
#define _CFFI_PRIM_INT_FAST64   44
#define _CFFI_PRIM_UINT_FAST64  45
#define _CFFI_PRIM_INTMAX       46
#define _CFFI_PRIM_UINTMAX      47
#define _CFFI_PRIM_FLOATCOMPLEX 48
#define _CFFI_PRIM_DOUBLECOMPLEX 49
#define _CFFI_PRIM_CHAR16       50
#define _CFFI_PRIM_CHAR32       51

#define _CFFI__NUM_PRIM         52
#define _CFFI__UNKNOWN_PRIM           (-1)
#define _CFFI__UNKNOWN_FLOAT_PRIM     (-2)
#define _CFFI__UNKNOWN_LONG_DOUBLE    (-3)

#define _CFFI__IO_FILE_STRUCT         (-1)


struct _cffi_global_s {
    const char *name;
    void *address;
    _cffi_opcode_t type_op;
    void *size_or_direct_fn;  // OP_GLOBAL_VAR: size, or 0 if unknown
                              // OP_CPYTHON_BLTN_*: addr of direct function
};

struct _cffi_getconst_s {
    unsigned long long value;
    const struct _cffi_type_context_s *ctx;
    int gindex;
};

struct _cffi_struct_union_s {
    const char *name;
    int type_index;          // -> _cffi_types, on a OP_STRUCT_UNION
    int flags;               // _CFFI_F_* flags below
    size_t size;
    int alignment;
    int first_field_index;   // -> _cffi_fields array
    int num_fields;
};
#define _CFFI_F_UNION         0x01   // is a union, not a struct
#define _CFFI_F_CHECK_FIELDS  0x02   // complain if fields are not in the
                                     // "standard layout" or if some are missing
#define _CFFI_F_PACKED        0x04   // for CHECK_FIELDS, assume a packed struct
#define _CFFI_F_EXTERNAL      0x08   // in some other ffi.include()
#define _CFFI_F_OPAQUE        0x10   // opaque

struct _cffi_field_s {
    const char *name;
    size_t field_offset;
    size_t field_size;
    _cffi_opcode_t field_type_op;
};

struct _cffi_enum_s {
    const char *name;
    int type_index;          // -> _cffi_types, on a OP_ENUM
    int type_prim;           // _CFFI_PRIM_xxx
    const char *enumerators; // comma-delimited string
};

struct _cffi_typename_s {
    const char *name;
    int type_index;   /* if opaque, points to a possibly artificial
                         OP_STRUCT which is itself opaque */
};

struct _cffi_type_context_s {
    _cffi_opcode_t *types;
    const struct _cffi_global_s *globals;
    const struct _cffi_field_s *fields;
    const struct _cffi_struct_union_s *struct_unions;
    const struct _cffi_enum_s *enums;
    const struct _cffi_typename_s *typenames;
    int num_globals;
    int num_struct_unions;
    int num_enums;
    int num_typenames;
    const char *const *includes;
    int num_types;
    int flags;      /* future extension */
};

struct _cffi_parse_info_s {
    const struct _cffi_type_context_s *ctx;
    _cffi_opcode_t *output;
    unsigned int output_size;
    size_t error_location;
    const char *error_message;
};

struct _cffi_externpy_s {
    const char *name;
    size_t size_of_result;
    void *reserved1, *reserved2;
};

#ifdef _CFFI_INTERNAL
static int parse_c_type(struct _cffi_parse_info_s *info, const char *input);
static int search_in_globals(const struct _cffi_type_context_s *ctx,
                             const char *search, size_t search_len);
static int search_in_struct_unions(const struct _cffi_type_context_s *ctx,
                                   const char *search, size_t search_len);
#endif

/* this block of #ifs should be kept exactly identical between
   c/_cffi_backend.c, cffi/vengine_cpy.py, cffi/vengine_gen.py
   and cffi/_cffi_include.h */
#if defined(_MSC_VER)
# include <malloc.h>   /* for alloca() */
# if _MSC_VER < 1600   /* MSVC < 2010 */
   typedef __int8 int8_t;
   typedef __int16 int16_t;
   typedef __int32 int32_t;
   typedef __int64 int64_t;
   typedef unsigned __int8 uint8_t;
   typedef unsigned __int16 uint16_t;
   typedef unsigned __int32 uint32_t;
   typedef unsigned __int64 uint64_t;
   typedef __int8 int_least8_t;
   typedef __int16 int_least16_t;
   typedef __int32 int_least32_t;
   typedef __int64 int_least64_t;
   typedef unsigned __int8 uint_least8_t;
   typedef unsigned __int16 uint_least16_t;
   typedef unsigned __int32 uint_least32_t;
   typedef unsigned __int64 uint_least64_t;
   typedef __int8 int_fast8_t;
   typedef __int16 int_fast16_t;
   typedef __int32 int_fast32_t;
   typedef __int64 int_fast64_t;
   typedef unsigned __int8 uint_fast8_t;
   typedef unsigned __int16 uint_fast16_t;
   typedef unsigned __int32 uint_fast32_t;
   typedef unsigned __int64 uint_fast64_t;
   typedef __int64 intmax_t;
   typedef unsigned __int64 uintmax_t;
# else
#  include <stdint.h>
# endif
# if _MSC_VER < 1800   /* MSVC < 2013 */
#  ifndef __cplusplus
    typedef unsigned char _Bool;
#  endif
# endif
# define _cffi_float_complex_t   _Fcomplex    /* include <complex.h> for it */
# define _cffi_double_complex_t  _Dcomplex    /* include <complex.h> for it */
#else
# include <stdint.h>
# if (defined (__SVR4) && defined (__sun)) || defined(_AIX) || defined(__hpux)
#  include <alloca.h>
# endif
# define _cffi_float_complex_t   float _Complex
# define _cffi_double_complex_t  double _Complex
#endif

#ifdef __GNUC__
# define _CFFI_UNUSED_FN  __attribute__((unused))
#else
# define _CFFI_UNUSED_FN  /* nothing */
#endif

#ifdef __cplusplus
# ifndef _Bool
   typedef bool _Bool;   /* semi-hackish: C++ has no _Bool; bool is builtin */
# endif
#endif

/**********  CPython-specific section  **********/
#ifndef PYPY_VERSION


#if PY_MAJOR_VERSION >= 3
# define PyInt_FromLong PyLong_FromLong
#endif

#define _cffi_from_c_double PyFloat_FromDouble
#define _cffi_from_c_float PyFloat_FromDouble
#define _cffi_from_c_long PyInt_FromLong
#define _cffi_from_c_ulong PyLong_FromUnsignedLong
#define _cffi_from_c_longlong PyLong_FromLongLong
#define _cffi_from_c_ulonglong PyLong_FromUnsignedLongLong
#define _cffi_from_c__Bool PyBool_FromLong

#define _cffi_to_c_double PyFloat_AsDouble
#define _cffi_to_c_float PyFloat_AsDouble

#define _cffi_from_c_int(x, type)                                        \
    (((type)-1) > 0 ? /* unsigned */                                     \
        (sizeof(type) < sizeof(long) ?                                   \
            PyInt_FromLong((long)x) :                                    \
         sizeof(type) == sizeof(long) ?                                  \
            PyLong_FromUnsignedLong((unsigned long)x) :                  \
            PyLong_FromUnsignedLongLong((unsigned long long)x)) :        \
        (sizeof(type) <= sizeof(long) ?                                  \
            PyInt_FromLong((long)x) :                                    \
            PyLong_FromLongLong((long long)x)))

#define _cffi_to_c_int(o, type)                                          \
    ((type)(                                                             \
     sizeof(type) == 1 ? (((type)-1) > 0 ? (type)_cffi_to_c_u8(o)        \
                                         : (type)_cffi_to_c_i8(o)) :     \
     sizeof(type) == 2 ? (((type)-1) > 0 ? (type)_cffi_to_c_u16(o)       \
                                         : (type)_cffi_to_c_i16(o)) :    \
     sizeof(type) == 4 ? (((type)-1) > 0 ? (type)_cffi_to_c_u32(o)       \
                                         : (type)_cffi_to_c_i32(o)) :    \
     sizeof(type) == 8 ? (((type)-1) > 0 ? (type)_cffi_to_c_u64(o)       \
                                         : (type)_cffi_to_c_i64(o)) :    \
     (Py_FatalError("unsupported size for type " #type), (type)0)))

#define _cffi_to_c_i8                                                    \
                 ((int(*)(PyObject *))_cffi_exports[1])
#define _cffi_to_c_u8                                                    \
                 ((int(*)(PyObject *))_cffi_exports[2])
#define _cffi_to_c_i16                                                   \
                 ((int(*)(PyObject *))_cffi_exports[3])
#define _cffi_to_c_u16                                                   \
                 ((int(*)(PyObject *))_cffi_exports[4])
#define _cffi_to_c_i32                                                   \
                 ((int(*)(PyObject *))_cffi_exports[5])
#define _cffi_to_c_u32                                                   \
                 ((unsigned int(*)(PyObject *))_cffi_exports[6])
#define _cffi_to_c_i64                                                   \
                 ((long long(*)(PyObject *))_cffi_exports[7])
#define _cffi_to_c_u64                                                   \
                 ((unsigned long long(*)(PyObject *))_cffi_exports[8])
#define _cffi_to_c_char                                                  \
                 ((int(*)(PyObject *))_cffi_exports[9])
#define _cffi_from_c_pointer                                             \
    ((PyObject *(*)(char *, struct _cffi_ctypedescr *))_cffi_exports[10])
#define _cffi_to_c_pointer                                               \
    ((char *(*)(PyObject *, struct _cffi_ctypedescr *))_cffi_exports[11])
#define _cffi_get_struct_layout                                          \
    not used any more
#define _cffi_restore_errno                                              \
    ((void(*)(void))_cffi_exports[13])
#define _cffi_save_errno                                                 \
    ((void(*)(void))_cffi_exports[14])
#define _cffi_from_c_char                                                \
    ((PyObject *(*)(char))_cffi_exports[15])
#define _cffi_from_c_deref                                               \
    ((PyObject *(*)(char *, struct _cffi_ctypedescr *))_cffi_exports[16])
#define _cffi_to_c                                                       \
    ((int(*)(char *, struct _cffi_ctypedescr *, PyObject *))_cffi_exports[17])
#define _cffi_from_c_struct                                              \
    ((PyObject *(*)(char *, struct _cffi_ctypedescr *))_cffi_exports[18])
#define _cffi_to_c_wchar_t                                               \
    ((_cffi_wchar_t(*)(PyObject *))_cffi_exports[19])
#define _cffi_from_c_wchar_t                                             \
    ((PyObject *(*)(_cffi_wchar_t))_cffi_exports[20])
#define _cffi_to_c_long_double                                           \
    ((long double(*)(PyObject *))_cffi_exports[21])
#define _cffi_to_c__Bool                                                 \
    ((_Bool(*)(PyObject *))_cffi_exports[22])
#define _cffi_prepare_pointer_call_argument                              \
    ((Py_ssize_t(*)(struct _cffi_ctypedescr *,                           \
                    PyObject *, char **))_cffi_exports[23])
#define _cffi_convert_array_from_object                                  \
    ((int(*)(char *, struct _cffi_ctypedescr *, PyObject *))_cffi_exports[24])
#define _CFFI_CPIDX  25
#define _cffi_call_python                                                \
    ((void(*)(struct _cffi_externpy_s *, char *))_cffi_exports[_CFFI_CPIDX])
#define _cffi_to_c_wchar3216_t                                           \
    ((int(*)(PyObject *))_cffi_exports[26])
#define _cffi_from_c_wchar3216_t                                         \
    ((PyObject *(*)(int))_cffi_exports[27])
#define _CFFI_NUM_EXPORTS 28

struct _cffi_ctypedescr;

static void *_cffi_exports[_CFFI_NUM_EXPORTS];

#define _cffi_type(index)   (                           \
    assert((((uintptr_t)_cffi_types[index]) & 1) == 0), \
    (struct _cffi_ctypedescr *)_cffi_types[index])

static PyObject *_cffi_init(const char *module_name, Py_ssize_t version,
                            const struct _cffi_type_context_s *ctx)
{
    PyObject *module, *o_arg, *new_module;
    void *raw[] = {
        (void *)module_name,
        (void *)version,
        (void *)_cffi_exports,
        (void *)ctx,
    };

    module = PyImport_ImportModule("_cffi_backend");
    if (module == NULL)
        goto failure;

    o_arg = PyLong_FromVoidPtr((void *)raw);
    if (o_arg == NULL)
        goto failure;

    new_module = PyObject_CallMethod(
        module, (char *)"_init_cffi_1_0_external_module", (char *)"O", o_arg);

    Py_DECREF(o_arg);
    Py_DECREF(module);
    return new_module;

  failure:
    Py_XDECREF(module);
    return NULL;
}


#ifdef HAVE_WCHAR_H
typedef wchar_t _cffi_wchar_t;
#else
typedef uint16_t _cffi_wchar_t;   /* same random pick as _cffi_backend.c */
#endif

_CFFI_UNUSED_FN static uint16_t _cffi_to_c_char16_t(PyObject *o)
{
    if (sizeof(_cffi_wchar_t) == 2)
        return (uint16_t)_cffi_to_c_wchar_t(o);
    else
        return (uint16_t)_cffi_to_c_wchar3216_t(o);
}

_CFFI_UNUSED_FN static PyObject *_cffi_from_c_char16_t(uint16_t x)
{
    if (sizeof(_cffi_wchar_t) == 2)
        return _cffi_from_c_wchar_t((_cffi_wchar_t)x);
    else
        return _cffi_from_c_wchar3216_t((int)x);
}

_CFFI_UNUSED_FN static int _cffi_to_c_char32_t(PyObject *o)
{
    if (sizeof(_cffi_wchar_t) == 4)
        return (int)_cffi_to_c_wchar_t(o);
    else
        return (int)_cffi_to_c_wchar3216_t(o);
}

_CFFI_UNUSED_FN static PyObject *_cffi_from_c_char32_t(unsigned int x)
{
    if (sizeof(_cffi_wchar_t) == 4)
        return _cffi_from_c_wchar_t((_cffi_wchar_t)x);
    else
        return _cffi_from_c_wchar3216_t((int)x);
}

union _cffi_union_alignment_u {
    unsigned char m_char;
    unsigned short m_short;
    unsigned int m_int;
    unsigned long m_long;
    unsigned long long m_longlong;
    float m_float;
    double m_double;
    long double m_longdouble;
};

struct _cffi_freeme_s {
    struct _cffi_freeme_s *next;
    union _cffi_union_alignment_u alignment;
};

_CFFI_UNUSED_FN static int
_cffi_convert_array_argument(struct _cffi_ctypedescr *ctptr, PyObject *arg,
                             char **output_data, Py_ssize_t datasize,
                             struct _cffi_freeme_s **freeme)
{
    char *p;
    if (datasize < 0)
        return -1;

    p = *output_data;
    if (p == NULL) {
        struct _cffi_freeme_s *fp = (struct _cffi_freeme_s *)PyObject_Malloc(
            offsetof(struct _cffi_freeme_s, alignment) + (size_t)datasize);
        if (fp == NULL)
            return -1;
        fp->next = *freeme;
        *freeme = fp;
        p = *output_data = (char *)&fp->alignment;
    }
    memset((void *)p, 0, (size_t)datasize);
    return _cffi_convert_array_from_object(p, ctptr, arg);
}

_CFFI_UNUSED_FN static void
_cffi_free_array_arguments(struct _cffi_freeme_s *freeme)
{
    do {
        void *p = (void *)freeme;
        freeme = freeme->next;
        PyObject_Free(p);
    } while (freeme != NULL);
}

/**********  end CPython-specific section  **********/
#else
_CFFI_UNUSED_FN
static void (*_cffi_call_python_org)(struct _cffi_externpy_s *, char *);
# define _cffi_call_python  _cffi_call_python_org
#endif


#define _cffi_array_len(array)   (sizeof(array) / sizeof((array)[0]))

#define _cffi_prim_int(size, sign)                                      \
    ((size) == 1 ? ((sign) ? _CFFI_PRIM_INT8  : _CFFI_PRIM_UINT8)  :    \
     (size) == 2 ? ((sign) ? _CFFI_PRIM_INT16 : _CFFI_PRIM_UINT16) :    \
     (size) == 4 ? ((sign) ? _CFFI_PRIM_INT32 : _CFFI_PRIM_UINT32) :    \
     (size) == 8 ? ((sign) ? _CFFI_PRIM_INT64 : _CFFI_PRIM_UINT64) :    \
     _CFFI__UNKNOWN_PRIM)

#define _cffi_prim_float(size)                                          \
    ((size) == sizeof(float) ? _CFFI_PRIM_FLOAT :                       \
     (size) == sizeof(double) ? _CFFI_PRIM_DOUBLE :                     \
     (size) == sizeof(long double) ? _CFFI__UNKNOWN_LONG_DOUBLE :       \
     _CFFI__UNKNOWN_FLOAT_PRIM)

#define _cffi_check_int(got, got_nonpos, expected)      \
    ((got_nonpos) == (expected <= 0) &&                 \
     (got) == (unsigned long long)expected)

#ifdef MS_WIN32
# define _cffi_stdcall  __stdcall
#else
# define _cffi_stdcall  /* nothing */
#endif

#ifdef __cplusplus
}
#endif

#define _CFFI_MODULE_NAME  "my_plugin"
static const char _CFFI_PYTHON_STARTUP_CODE[] = {
// # NB. this is not a string because of a size limit in MSVC
// 'from fractions import Fraction\n
102,114,111,109,32,102,114,97,99,116,105,111,110,115,32,105,109,112,111,114,
116,32,70,114,97,99,116,105,111,110,10,
// 'import threading\n
105,109,112,111,114,116,32,116,104,114,101,97,100,105,110,103,10,
// 'import traceback\n
105,109,112,111,114,116,32,116,114,97,99,101,98,97,99,107,10,
// 'import math\n
105,109,112,111,114,116,32,109,97,116,104,10,
// 'import numpy as np\n
105,109,112,111,114,116,32,110,117,109,112,121,32,97,115,32,110,112,10,
// 'import multiprocessing\n
105,109,112,111,114,116,32,109,117,108,116,105,112,114,111,99,101,115,115,105,
110,103,10,
// 'import multiprocessing.shared_memory\n
105,109,112,111,114,116,32,109,117,108,116,105,112,114,111,99,101,115,115,105,
110,103,46,115,104,97,114,101,100,95,109,101,109,111,114,121,10,
// 'import ctypes\n
105,109,112,111,114,116,32,99,116,121,112,101,115,10,
// 'import weakref\n
105,109,112,111,114,116,32,119,101,97,107,114,101,102,10,
// 'import os\n
105,109,112,111,114,116,32,111,115,10,
// 'import struct\n
105,109,112,111,114,116,32,115,116,114,117,99,116,10,
// 'import sys\n
105,109,112,111,114,116,32,115,121,115,10,
// 'from my_plugin import  lib, ffi\n
102,114,111,109,32,109,121,95,112,108,117,103,105,110,32,105,109,112,111,114,
116,32,32,108,105,98,44,32,102,102,105,10,
// 'import json\n
105,109,112,111,114,116,32,106,115,111,110,10,
// 'import importlib\n
105,109,112,111,114,116,32,105,109,112,111,114,116,108,105,98,10,
// 'from importlib import reload\n
102,114,111,109,32,105,109,112,111,114,116,108,105,98,32,105,109,112,111,114,
116,32,114,101,108,111,97,100,10,
// 'env=os.path.expanduser(os.path.expandvars(\'$PYTHONPATH\')) # "source" directory with python script\n
101,110,118,61,111,115,46,112,97,116,104,46,101,120,112,97,110,100,117,115,101,
114,40,111,115,46,112,97,116,104,46,101,120,112,97,110,100,118,97,114,115,40,
39,36,80,89,84,72,79,78,80,65,84,72,39,41,41,32,35,32,34,115,111,117,114,99,
101,34,32,100,105,114,101,99,116,111,114,121,32,119,105,116,104,32,112,121,116,
104,111,110,32,115,99,114,105,112,116,10,
// "mypath = env.split(';')\n
109,121,112,97,116,104,32,61,32,101,110,118,46,115,112,108,105,116,40,39,59,
39,41,10,
// 'for p in mypath:\n
102,111,114,32,112,32,105,110,32,109,121,112,97,116,104,58,10,
// '    sys.path.insert(0, p)\n
32,32,32,32,115,121,115,46,112,97,116,104,46,105,110,115,101,114,116,40,48,44,
32,112,41,10,
// 'import inspect\n
105,109,112,111,114,116,32,105,110,115,112,101,99,116,10,
// 'import time\n
105,109,112,111,114,116,32,116,105,109,101,10,
// 'import gc\n
105,109,112,111,114,116,32,103,99,10,
// 'import os\n
105,109,112,111,114,116,32,111,115,10,
// 'import hashlib\n
105,109,112,111,114,116,32,104,97,115,104,108,105,98,10,
// 'import functions\n
105,109,112,111,114,116,32,102,117,110,99,116,105,111,110,115,10,
// 'try:\n
116,114,121,58,10,
// '    import __pypy__\n
32,32,32,32,105,109,112,111,114,116,32,95,95,112,121,112,121,95,95,10,
// 'except:\n
101,120,99,101,112,116,58,10,
// '    pass\n
32,32,32,32,112,97,115,115,10,
// '#gc.disable()\n
35,103,99,46,100,105,115,97,98,108,101,40,41,10,
// '#tmpstrs = {}\n
35,116,109,112,115,116,114,115,32,61,32,123,125,10,
// 'iters = {}\n
105,116,101,114,115,32,61,32,123,125,10,
// 'global_lock = threading.Lock()\n
103,108,111,98,97,108,95,108,111,99,107,32,61,32,116,104,114,101,97,100,105,
110,103,46,76,111,99,107,40,41,10,
// 'tmpstrs = []\n
116,109,112,115,116,114,115,32,61,32,91,93,10,
// 'checksums = {}\n
99,104,101,99,107,115,117,109,115,32,61,32,123,125,10,
// '#li = [None]*10\n
35,108,105,32,61,32,91,78,111,110,101,93,42,49,48,10,
// '@ffi.def_extern()\n
64,102,102,105,46,100,101,102,95,101,120,116,101,114,110,40,41,10,
// 'def disable_gc():\n
100,101,102,32,100,105,115,97,98,108,101,95,103,99,40,41,58,10,
// '    gc.disable()\n
32,32,32,32,103,99,46,100,105,115,97,98,108,101,40,41,10,
// 'inc = 0\n
105,110,99,32,61,32,48,10,
// '@ffi.def_extern()\n
64,102,102,105,46,100,101,102,95,101,120,116,101,114,110,40,41,10,
// 'def call_gc():\n
100,101,102,32,99,97,108,108,95,103,99,40,41,58,10,
// '    gc.enable()\n
32,32,32,32,103,99,46,101,110,97,98,108,101,40,41,10,
// '    gc.collect()\n
32,32,32,32,103,99,46,99,111,108,108,101,99,116,40,41,10,
// '    global tmpstrs\n
32,32,32,32,103,108,111,98,97,108,32,116,109,112,115,116,114,115,10,
// '    del tmpstrs[:]\n
32,32,32,32,100,101,108,32,116,109,112,115,116,114,115,91,58,93,10,
// '    global iters\n
32,32,32,32,103,108,111,98,97,108,32,105,116,101,114,115,10,
// '    del iters\n
32,32,32,32,100,101,108,32,105,116,101,114,115,10,
// '    iters = {}\n
32,32,32,32,105,116,101,114,115,32,61,32,123,125,10,
// '\n
10,
// '@ffi.def_extern()\n
64,102,102,105,46,100,101,102,95,101,120,116,101,114,110,40,41,10,
// 'def freecarray(arrays, num, count):\n
100,101,102,32,102,114,101,101,99,97,114,114,97,121,40,97,114,114,97,121,115,
44,32,110,117,109,44,32,99,111,117,110,116,41,58,10,
// '    #for i in range(num):\n
32,32,32,32,35,102,111,114,32,105,32,105,110,32,114,97,110,103,101,40,110,117,
109,41,58,10,
// '    #    for r in range(count):\n
32,32,32,32,35,32,32,32,32,102,111,114,32,114,32,105,110,32,114,97,110,103,101,
40,99,111,117,110,116,41,58,10,
// '    #      if ffi.cast("char **", arrays[i].array )[r] != ffi.NULL:\n
32,32,32,32,35,32,32,32,32,32,32,105,102,32,102,102,105,46,99,97,115,116,40,
34,99,104,97,114,32,42,42,34,44,32,97,114,114,97,121,115,91,105,93,46,97,114,
114,97,121,32,41,91,114,93,32,33,61,32,102,102,105,46,78,85,76,76,58,10,
// '    #           lib.free(ffi.cast("char **", arrays[i].array )[r])\n
32,32,32,32,35,32,32,32,32,32,32,32,32,32,32,32,108,105,98,46,102,114,101,101,
40,102,102,105,46,99,97,115,116,40,34,99,104,97,114,32,42,42,34,44,32,97,114,
114,97,121,115,91,105,93,46,97,114,114,97,121,32,41,91,114,93,41,10,
// '\n
10,
// '    #for i in range(num):\n
32,32,32,32,35,102,111,114,32,105,32,105,110,32,114,97,110,103,101,40,110,117,
109,41,58,10,
// '        #ffi.release(arrays[i].array)\n
32,32,32,32,32,32,32,32,35,102,102,105,46,114,101,108,101,97,115,101,40,97,114,
114,97,121,115,91,105,93,46,97,114,114,97,121,41,10,
// '        #del arrays[i].array\n
32,32,32,32,32,32,32,32,35,100,101,108,32,97,114,114,97,121,115,91,105,93,46,
97,114,114,97,121,10,
// '        #lib.free(arrays[i].array)\n
32,32,32,32,32,32,32,32,35,108,105,98,46,102,114,101,101,40,97,114,114,97,121,
115,91,105,93,46,97,114,114,97,121,41,10,
// '    #del arrays\n
32,32,32,32,35,100,101,108,32,97,114,114,97,121,115,10,
// "    #print('ksuhgarghfarghfausdhfhahsdkfhasdghfasdhfjhasdfjhaghsdjhfgjashdgfasdygfjsbfvjhsbfej')\n
32,32,32,32,35,112,114,105,110,116,40,39,107,115,117,104,103,97,114,103,104,
102,97,114,103,104,102,97,117,115,100,104,102,104,97,104,115,100,107,102,104,
97,115,100,103,104,102,97,115,100,104,102,106,104,97,115,100,102,106,104,97,
103,104,115,100,106,104,102,103,106,97,115,104,100,103,102,97,115,100,121,103,
102,106,115,98,102,118,106,104,115,98,102,101,106,39,41,10,
// '    return 1\n
32,32,32,32,114,101,116,117,114,110,32,49,10,
// '    \n
32,32,32,32,10,
// '@ffi.def_extern()\n
64,102,102,105,46,100,101,102,95,101,120,116,101,114,110,40,41,10,
// 'def udfwrapper_parallel(funcname, paramsnum, arrays, resultdouble, resultint, resultstring, insize, errormessage):\n
100,101,102,32,117,100,102,119,114,97,112,112,101,114,95,112,97,114,97,108,108,
101,108,40,102,117,110,99,110,97,109,101,44,32,112,97,114,97,109,115,110,117,
109,44,32,97,114,114,97,121,115,44,32,114,101,115,117,108,116,100,111,117,98,
108,101,44,32,114,101,115,117,108,116,105,110,116,44,32,114,101,115,117,108,
116,115,116,114,105,110,103,44,32,105,110,115,105,122,101,44,32,101,114,114,
111,114,109,101,115,115,97,103,101,41,58,10,
// '  #gc.collect()\n
32,32,35,103,99,46,99,111,108,108,101,99,116,40,41,10,
// '  if resultint!= ffi.NULL:\n
32,32,105,102,32,114,101,115,117,108,116,105,110,116,33,61,32,102,102,105,46,
78,85,76,76,58,10,
// '    shared_memory = multiprocessing.shared_memory.SharedMemory(create=True, size = ffi.sizeof("ArrayInfo1") * paramsnum )\n
32,32,32,32,115,104,97,114,101,100,95,109,101,109,111,114,121,32,61,32,109,117,
108,116,105,112,114,111,99,101,115,115,105,110,103,46,115,104,97,114,101,100,
95,109,101,109,111,114,121,46,83,104,97,114,101,100,77,101,109,111,114,121,40,
99,114,101,97,116,101,61,84,114,117,101,44,32,115,105,122,101,32,61,32,102,102,
105,46,115,105,122,101,111,102,40,34,65,114,114,97,121,73,110,102,111,49,34,
41,32,42,32,112,97,114,97,109,115,110,117,109,32,41,10,
// '    array_info_array_shared = ffi.from_buffer("ArrayInfo1[]",shared_memory.buf)\n
32,32,32,32,97,114,114,97,121,95,105,110,102,111,95,97,114,114,97,121,95,115,
104,97,114,101,100,32,61,32,102,102,105,46,102,114,111,109,95,98,117,102,102,
101,114,40,34,65,114,114,97,121,73,110,102,111,49,91,93,34,44,115,104,97,114,
101,100,95,109,101,109,111,114,121,46,98,117,102,41,10,
// '    shared_memory2 = multiprocessing.shared_memory.SharedMemory(create=True, size = ffi.sizeof("int") * insize )\n
32,32,32,32,115,104,97,114,101,100,95,109,101,109,111,114,121,50,32,61,32,109,
117,108,116,105,112,114,111,99,101,115,115,105,110,103,46,115,104,97,114,101,
100,95,109,101,109,111,114,121,46,83,104,97,114,101,100,77,101,109,111,114,121,
40,99,114,101,97,116,101,61,84,114,117,101,44,32,115,105,122,101,32,61,32,102,
102,105,46,115,105,122,101,111,102,40,34,105,110,116,34,41,32,42,32,105,110,
115,105,122,101,32,41,10,
// '    array_info_array_shared2 = ffi.from_buffer("int[]",shared_memory2.buf)\n
32,32,32,32,97,114,114,97,121,95,105,110,102,111,95,97,114,114,97,121,95,115,
104,97,114,101,100,50,32,61,32,102,102,105,46,102,114,111,109,95,98,117,102,
102,101,114,40,34,105,110,116,91,93,34,44,115,104,97,114,101,100,95,109,101,
109,111,114,121,50,46,98,117,102,41,10,
// '    array_info_array_shared2 = resultint\n
32,32,32,32,97,114,114,97,121,95,105,110,102,111,95,97,114,114,97,121,95,115,
104,97,114,101,100,50,32,61,32,114,101,115,117,108,116,105,110,116,10,
// '    for i in range(paramsnum):\n
32,32,32,32,102,111,114,32,105,32,105,110,32,114,97,110,103,101,40,112,97,114,
97,109,115,110,117,109,41,58,10,
// '        array_info_array_shared[i] = arrays[i]\n
32,32,32,32,32,32,32,32,97,114,114,97,121,95,105,110,102,111,95,97,114,114,97,
121,95,115,104,97,114,101,100,91,105,93,32,61,32,97,114,114,97,121,115,91,105,
93,10,
// '    process = multiprocessing.Process(target=udfwrapperprocess, args=(funcname, paramsnum, shared_memory, resultdouble, shared_memory2, resultstring, insize))\n
32,32,32,32,112,114,111,99,101,115,115,32,61,32,109,117,108,116,105,112,114,
111,99,101,115,115,105,110,103,46,80,114,111,99,101,115,115,40,116,97,114,103,
101,116,61,117,100,102,119,114,97,112,112,101,114,112,114,111,99,101,115,115,
44,32,97,114,103,115,61,40,102,117,110,99,110,97,109,101,44,32,112,97,114,97,
109,115,110,117,109,44,32,115,104,97,114,101,100,95,109,101,109,111,114,121,
44,32,114,101,115,117,108,116,100,111,117,98,108,101,44,32,115,104,97,114,101,
100,95,109,101,109,111,114,121,50,44,32,114,101,115,117,108,116,115,116,114,
105,110,103,44,32,105,110,115,105,122,101,41,41,10,
// '    process.start()\n
32,32,32,32,112,114,111,99,101,115,115,46,115,116,97,114,116,40,41,10,
// '    process.join()\n
32,32,32,32,112,114,111,99,101,115,115,46,106,111,105,110,40,41,10,
// '    array_info_array_shared2 = ffi.from_buffer("int[]",shared_memory2.buf)\n
32,32,32,32,97,114,114,97,121,95,105,110,102,111,95,97,114,114,97,121,95,115,
104,97,114,101,100,50,32,61,32,102,102,105,46,102,114,111,109,95,98,117,102,
102,101,114,40,34,105,110,116,91,93,34,44,115,104,97,114,101,100,95,109,101,
109,111,114,121,50,46,98,117,102,41,10,
// '    for i in range(insize):\n
32,32,32,32,102,111,114,32,105,32,105,110,32,114,97,110,103,101,40,105,110,115,
105,122,101,41,58,10,
// '        resultint[i] = array_info_array_shared2[i]\n
32,32,32,32,32,32,32,32,114,101,115,117,108,116,105,110,116,91,105,93,32,61,
32,97,114,114,97,121,95,105,110,102,111,95,97,114,114,97,121,95,115,104,97,114,
101,100,50,91,105,93,10,
// '    shared_memory.close()\n
32,32,32,32,115,104,97,114,101,100,95,109,101,109,111,114,121,46,99,108,111,
115,101,40,41,10,
// '    shared_memory.unlink()\n
32,32,32,32,115,104,97,114,101,100,95,109,101,109,111,114,121,46,117,110,108,
105,110,107,40,41,10,
// '    shared_memory2.close()\n
32,32,32,32,115,104,97,114,101,100,95,109,101,109,111,114,121,50,46,99,108,111,
115,101,40,41,10,
// '    shared_memory2.unlink()\n
32,32,32,32,115,104,97,114,101,100,95,109,101,109,111,114,121,50,46,117,110,
108,105,110,107,40,41,10,
// '    return 1\n
32,32,32,32,114,101,116,117,114,110,32,49,10,
// '\n
10,
// '@ffi.def_extern()\n
64,102,102,105,46,100,101,102,95,101,120,116,101,114,110,40,41,10,
// 'def udfwrapper(funcname, paramsnum, arrays, resultdouble, resultint, resultstring, insize, isliteral, errormessage):\n
100,101,102,32,117,100,102,119,114,97,112,112,101,114,40,102,117,110,99,110,
97,109,101,44,32,112,97,114,97,109,115,110,117,109,44,32,97,114,114,97,121,115,
44,32,114,101,115,117,108,116,100,111,117,98,108,101,44,32,114,101,115,117,108,
116,105,110,116,44,32,114,101,115,117,108,116,115,116,114,105,110,103,44,32,
105,110,115,105,122,101,44,32,105,115,108,105,116,101,114,97,108,44,32,101,114,
114,111,114,109,101,115,115,97,103,101,41,58,10,
// '   global iters\n
32,32,32,103,108,111,98,97,108,32,105,116,101,114,115,10,
// '   global global_lock\n
32,32,32,103,108,111,98,97,108,32,103,108,111,98,97,108,95,108,111,99,107,10,
// '   global tmpstrs\n
32,32,32,103,108,111,98,97,108,32,116,109,112,115,116,114,115,10,
// '   errorm = 0;\n
32,32,32,101,114,114,111,114,109,32,61,32,48,59,10,
// '   try:\n
32,32,32,116,114,121,58,10,
// '     with global_lock:\n
32,32,32,32,32,119,105,116,104,32,103,108,111,98,97,108,95,108,111,99,107,58,
10,
// '       #del tmpstrs[:]\n
32,32,32,32,32,32,32,35,100,101,108,32,116,109,112,115,116,114,115,91,58,93,
10,
// '       tmpstrs = []\n
32,32,32,32,32,32,32,116,109,112,115,116,114,115,32,61,32,91,93,10,
// '       funcname = ffi.string(funcname).decode()\n
32,32,32,32,32,32,32,102,117,110,99,110,97,109,101,32,61,32,102,102,105,46,115,
116,114,105,110,103,40,102,117,110,99,110,97,109,101,41,46,100,101,99,111,100,
101,40,41,10,
// "       funcname = funcname.split('.')\n
32,32,32,32,32,32,32,102,117,110,99,110,97,109,101,32,61,32,102,117,110,99,110,
97,109,101,46,115,112,108,105,116,40,39,46,39,41,10,
// '       inputd = [None]*paramsnum\n
32,32,32,32,32,32,32,105,110,112,117,116,100,32,61,32,91,78,111,110,101,93,42,
112,97,114,97,109,115,110,117,109,10,
// '       for i in range(paramsnum):\n
32,32,32,32,32,32,32,102,111,114,32,105,32,105,110,32,114,97,110,103,101,40,
112,97,114,97,109,115,110,117,109,41,58,10,
// '         if arrays[i].type == 0:\n
32,32,32,32,32,32,32,32,32,105,102,32,97,114,114,97,121,115,91,105,93,46,116,
121,112,101,32,61,61,32,48,58,10,
// '             inputd[i] = ffi.cast("char **", arrays[i].array )\n
32,32,32,32,32,32,32,32,32,32,32,32,32,105,110,112,117,116,100,91,105,93,32,
61,32,102,102,105,46,99,97,115,116,40,34,99,104,97,114,32,42,42,34,44,32,97,
114,114,97,121,115,91,105,93,46,97,114,114,97,121,32,41,10,
// '         elif arrays[i].type == 1:\n
32,32,32,32,32,32,32,32,32,101,108,105,102,32,97,114,114,97,121,115,91,105,93,
46,116,121,112,101,32,61,61,32,49,58,10,
// '             inputd[i] = ffi.cast("int *", arrays[i].array )\n
32,32,32,32,32,32,32,32,32,32,32,32,32,105,110,112,117,116,100,91,105,93,32,
61,32,102,102,105,46,99,97,115,116,40,34,105,110,116,32,42,34,44,32,97,114,114,
97,121,115,91,105,93,46,97,114,114,97,121,32,41,10,
// '         elif arrays[i].type == 2:\n
32,32,32,32,32,32,32,32,32,101,108,105,102,32,97,114,114,97,121,115,91,105,93,
46,116,121,112,101,32,61,61,32,50,58,10,
// '             inputd[i] = ffi.cast("double *", arrays[i].array)\n
32,32,32,32,32,32,32,32,32,32,32,32,32,105,110,112,117,116,100,91,105,93,32,
61,32,102,102,105,46,99,97,115,116,40,34,100,111,117,98,108,101,32,42,34,44,
32,97,114,114,97,121,115,91,105,93,46,97,114,114,97,121,41,10,
// '         elif arrays[i].type == 4:\n
32,32,32,32,32,32,32,32,32,101,108,105,102,32,97,114,114,97,121,115,91,105,93,
46,116,121,112,101,32,61,61,32,52,58,10,
// '             inputd[i] = ffi.cast("int8_t *", arrays[i].array)\n
32,32,32,32,32,32,32,32,32,32,32,32,32,105,110,112,117,116,100,91,105,93,32,
61,32,102,102,105,46,99,97,115,116,40,34,105,110,116,56,95,116,32,42,34,44,32,
97,114,114,97,121,115,91,105,93,46,97,114,114,97,121,41,10,
// '         elif arrays[i].type == 5:\n
32,32,32,32,32,32,32,32,32,101,108,105,102,32,97,114,114,97,121,115,91,105,93,
46,116,121,112,101,32,61,61,32,53,58,10,
// '             inputd[i] = ffi.cast("int16_t *", arrays[i].array)\n
32,32,32,32,32,32,32,32,32,32,32,32,32,105,110,112,117,116,100,91,105,93,32,
61,32,102,102,105,46,99,97,115,116,40,34,105,110,116,49,54,95,116,32,42,34,44,
32,97,114,114,97,121,115,91,105,93,46,97,114,114,97,121,41,10,
// '       if resultstring != ffi.NULL:\n
32,32,32,32,32,32,32,105,102,32,114,101,115,117,108,116,115,116,114,105,110,
103,32,33,61,32,102,102,105,46,78,85,76,76,58,10,
// "           resultparam = 'resultstring'\n
32,32,32,32,32,32,32,32,32,32,32,114,101,115,117,108,116,112,97,114,97,109,32,
61,32,39,114,101,115,117,108,116,115,116,114,105,110,103,39,10,
// '       elif resultint != ffi.NULL:\n
32,32,32,32,32,32,32,101,108,105,102,32,114,101,115,117,108,116,105,110,116,
32,33,61,32,102,102,105,46,78,85,76,76,58,10,
// "           resultparam = 'resultint'\n
32,32,32,32,32,32,32,32,32,32,32,114,101,115,117,108,116,112,97,114,97,109,32,
61,32,39,114,101,115,117,108,116,105,110,116,39,10,
// '       elif resultdouble != ffi.NULL:\n
32,32,32,32,32,32,32,101,108,105,102,32,114,101,115,117,108,116,100,111,117,
98,108,101,32,33,61,32,102,102,105,46,78,85,76,76,58,10,
// "           resultparam = 'resultdouble'\n
32,32,32,32,32,32,32,32,32,32,32,114,101,115,117,108,116,112,97,114,97,109,32,
61,32,39,114,101,115,117,108,116,100,111,117,98,108,101,39,10,
// '       code_params = \', \'.join([\'inputd[\'+str(j)+\'][n]\' if arrays[j].type != 0 else \'ffi.string(ffi.cast("char **", arrays[\'+str(j)+\'].array )[n])\' for j in range(paramsnum)])\n
32,32,32,32,32,32,32,99,111,100,101,95,112,97,114,97,109,115,32,61,32,39,44,
32,39,46,106,111,105,110,40,91,39,105,110,112,117,116,100,91,39,43,115,116,114,
40,106,41,43,39,93,91,110,93,39,32,105,102,32,97,114,114,97,121,115,91,106,93,
46,116,121,112,101,32,33,61,32,48,32,101,108,115,101,32,39,102,102,105,46,115,
116,114,105,110,103,40,102,102,105,46,99,97,115,116,40,34,99,104,97,114,32,42,
42,34,44,32,97,114,114,97,121,115,91,39,43,115,116,114,40,106,41,43,39,93,46,
97,114,114,97,121,32,41,91,110,93,41,39,32,102,111,114,32,106,32,105,110,32,
114,97,110,103,101,40,112,97,114,97,109,115,110,117,109,41,93,41,10,
// '       ##TODO to correct this with all datatypes\n
32,32,32,32,32,32,32,35,35,84,79,68,79,32,116,111,32,99,111,114,114,101,99,116,
32,116,104,105,115,32,119,105,116,104,32,97,108,108,32,100,97,116,97,116,121,
112,101,115,10,
// '       #code_params = \', \'.join([\'ffi.cast("int*", arrays[\'+str(j)+\'].array )[n]\' if arrays[j].type != 0 else \'ffi.string(ffi.cast("char **", arrays[\'+str(j)+\'].array )[n])\' for j in range(paramsnum)])\n
32,32,32,32,32,32,32,35,99,111,100,101,95,112,97,114,97,109,115,32,61,32,39,
44,32,39,46,106,111,105,110,40,91,39,102,102,105,46,99,97,115,116,40,34,105,
110,116,42,34,44,32,97,114,114,97,121,115,91,39,43,115,116,114,40,106,41,43,
39,93,46,97,114,114,97,121,32,41,91,110,93,39,32,105,102,32,97,114,114,97,121,
115,91,106,93,46,116,121,112,101,32,33,61,32,48,32,101,108,115,101,32,39,102,
102,105,46,115,116,114,105,110,103,40,102,102,105,46,99,97,115,116,40,34,99,
104,97,114,32,42,42,34,44,32,97,114,114,97,121,115,91,39,43,115,116,114,40,106,
41,43,39,93,46,97,114,114,97,121,32,41,91,110,93,41,39,32,102,111,114,32,106,
32,105,110,32,114,97,110,103,101,40,112,97,114,97,109,115,110,117,109,41,93,
41,10,
// '\n
10,
// "       if resultparam != 'resultstring':\n
32,32,32,32,32,32,32,105,102,32,114,101,115,117,108,116,112,97,114,97,109,32,
33,61,32,39,114,101,115,117,108,116,115,116,114,105,110,103,39,58,10,
// "           code_string = '''\n
32,32,32,32,32,32,32,32,32,32,32,99,111,100,101,95,115,116,114,105,110,103,32,
61,32,39,39,39,10,
// 'try:\n
116,114,121,58,10,
// ' try:\n
32,116,114,121,58,10,
// "    from '''+funcname[0]+''' import '''+funcname[1]+'''\n
32,32,32,32,102,114,111,109,32,39,39,39,43,102,117,110,99,110,97,109,101,91,
48,93,43,39,39,39,32,105,109,112,111,114,116,32,39,39,39,43,102,117,110,99,110,
97,109,101,91,49,93,43,39,39,39,10,
// '    if functions.DEBUG:\n
32,32,32,32,105,102,32,102,117,110,99,116,105,111,110,115,46,68,69,66,85,71,
58,10,
// "      mypath = get_module_path(funcname[0]+'.'+funcname[1])\n
32,32,32,32,32,32,109,121,112,97,116,104,32,61,32,103,101,116,95,109,111,100,
117,108,101,95,112,97,116,104,40,102,117,110,99,110,97,109,101,91,48,93,43,39,
46,39,43,102,117,110,99,110,97,109,101,91,49,93,41,10,
// '      #print(mypath)\n
32,32,32,32,32,32,35,112,114,105,110,116,40,109,121,112,97,116,104,41,10,
// '      if mypath not in checksums:\n
32,32,32,32,32,32,105,102,32,109,121,112,97,116,104,32,110,111,116,32,105,110,
32,99,104,101,99,107,115,117,109,115,58,10,
// '        checksums[mypath] = calculate_checksum(mypath)\n
32,32,32,32,32,32,32,32,99,104,101,99,107,115,117,109,115,91,109,121,112,97,
116,104,93,32,61,32,99,97,108,99,117,108,97,116,101,95,99,104,101,99,107,115,
117,109,40,109,121,112,97,116,104,41,10,
// '      elif mypath in checksums:\n
32,32,32,32,32,32,101,108,105,102,32,109,121,112,97,116,104,32,105,110,32,99,
104,101,99,107,115,117,109,115,58,10,
// '        csum = calculate_checksum(mypath)\n
32,32,32,32,32,32,32,32,99,115,117,109,32,61,32,99,97,108,99,117,108,97,116,
101,95,99,104,101,99,107,115,117,109,40,109,121,112,97,116,104,41,10,
// '        if checksums[mypath] != csum:\n
32,32,32,32,32,32,32,32,105,102,32,99,104,101,99,107,115,117,109,115,91,109,
121,112,97,116,104,93,32,33,61,32,99,115,117,109,58,10,
// "          importlib.reload('''+funcname[1]+''')\n
32,32,32,32,32,32,32,32,32,32,105,109,112,111,114,116,108,105,98,46,114,101,
108,111,97,100,40,39,39,39,43,102,117,110,99,110,97,109,101,91,49,93,43,39,39,
39,41,10,
// '          checksums[mypath] = csum\n
32,32,32,32,32,32,32,32,32,32,99,104,101,99,107,115,117,109,115,91,109,121,112,
97,116,104,93,32,61,32,99,115,117,109,10,
// '    for n in range(insize):\n
32,32,32,32,102,111,114,32,110,32,105,110,32,114,97,110,103,101,40,105,110,115,
105,122,101,41,58,10,
// "        '''+resultparam+'''[n] = '''+funcname[1]+'''.'''+funcname[2]+'''('''+code_params+''')\n
32,32,32,32,32,32,32,32,39,39,39,43,114,101,115,117,108,116,112,97,114,97,109,
43,39,39,39,91,110,93,32,61,32,39,39,39,43,102,117,110,99,110,97,109,101,91,
49,93,43,39,39,39,46,39,39,39,43,102,117,110,99,110,97,109,101,91,50,93,43,39,
39,39,40,39,39,39,43,99,111,100,101,95,112,97,114,97,109,115,43,39,39,39,41,
10,
// ' except ImportError as import_err:\n
32,101,120,99,101,112,116,32,73,109,112,111,114,116,69,114,114,111,114,32,97,
115,32,105,109,112,111,114,116,95,101,114,114,58,10,
// "  importlib.reload('''+funcname[0]+''')\n
32,32,105,109,112,111,114,116,108,105,98,46,114,101,108,111,97,100,40,39,39,
39,43,102,117,110,99,110,97,109,101,91,48,93,43,39,39,39,41,10,
// "  from  '''+funcname[0]+''' import '''+funcname[1]+'''\n
32,32,102,114,111,109,32,32,39,39,39,43,102,117,110,99,110,97,109,101,91,48,
93,43,39,39,39,32,105,109,112,111,114,116,32,39,39,39,43,102,117,110,99,110,
97,109,101,91,49,93,43,39,39,39,10,
// '  \n
32,32,10,
// '  for n in range(insize):\n
32,32,102,111,114,32,110,32,105,110,32,114,97,110,103,101,40,105,110,115,105,
122,101,41,58,10,
// "      '''+resultparam+'''[n] = '''+funcname[1]+'''.'''+funcname[2]+'''('''+code_params+''')\n
32,32,32,32,32,32,39,39,39,43,114,101,115,117,108,116,112,97,114,97,109,43,39,
39,39,91,110,93,32,61,32,39,39,39,43,102,117,110,99,110,97,109,101,91,49,93,
43,39,39,39,46,39,39,39,43,102,117,110,99,110,97,109,101,91,50,93,43,39,39,39,
40,39,39,39,43,99,111,100,101,95,112,97,114,97,109,115,43,39,39,39,41,10,
// 'except Exception as e:\n
101,120,99,101,112,116,32,69,120,99,101,112,116,105,111,110,32,97,115,32,101,
58,10,
// "       errormessage[0] = lib.strdup(ffi.from_buffer(memoryview(b'UDFError '+ funcname[0].encode()+b'.'+funcname[1].encode()+b'.'+funcname[2].upper().encode() + b': ' + traceback.format_exc().encode())))\n
32,32,32,32,32,32,32,101,114,114,111,114,109,101,115,115,97,103,101,91,48,93,
32,61,32,108,105,98,46,115,116,114,100,117,112,40,102,102,105,46,102,114,111,
109,95,98,117,102,102,101,114,40,109,101,109,111,114,121,118,105,101,119,40,
98,39,85,68,70,69,114,114,111,114,32,39,43,32,102,117,110,99,110,97,109,101,
91,48,93,46,101,110,99,111,100,101,40,41,43,98,39,46,39,43,102,117,110,99,110,
97,109,101,91,49,93,46,101,110,99,111,100,101,40,41,43,98,39,46,39,43,102,117,
110,99,110,97,109,101,91,50,93,46,117,112,112,101,114,40,41,46,101,110,99,111,
100,101,40,41,32,43,32,98,39,58,32,39,32,43,32,116,114,97,99,101,98,97,99,107,
46,102,111,114,109,97,116,95,101,120,99,40,41,46,101,110,99,111,100,101,40,41,
41,41,41,10,
// '       errorm = 1\n
32,32,32,32,32,32,32,101,114,114,111,114,109,32,61,32,49,10,
// "     '''\n
32,32,32,32,32,39,39,39,10,
// '       elif isliteral == 0:\n
32,32,32,32,32,32,32,101,108,105,102,32,105,115,108,105,116,101,114,97,108,32,
61,61,32,48,58,10,
// "           code_string = '''\n
32,32,32,32,32,32,32,32,32,32,32,99,111,100,101,95,115,116,114,105,110,103,32,
61,32,39,39,39,10,
// 'try:\n
116,114,121,58,10,
// ' try:\n
32,116,114,121,58,10,
// "    from  '''+funcname[0]+''' import '''+funcname[1]+'''\n
32,32,32,32,102,114,111,109,32,32,39,39,39,43,102,117,110,99,110,97,109,101,
91,48,93,43,39,39,39,32,105,109,112,111,114,116,32,39,39,39,43,102,117,110,99,
110,97,109,101,91,49,93,43,39,39,39,10,
// '    if functions.DEBUG:\n
32,32,32,32,105,102,32,102,117,110,99,116,105,111,110,115,46,68,69,66,85,71,
58,10,
// "      mypath = get_module_path(funcname[0]+'.'+funcname[1])\n
32,32,32,32,32,32,109,121,112,97,116,104,32,61,32,103,101,116,95,109,111,100,
117,108,101,95,112,97,116,104,40,102,117,110,99,110,97,109,101,91,48,93,43,39,
46,39,43,102,117,110,99,110,97,109,101,91,49,93,41,10,
// '      #print(mypath)\n
32,32,32,32,32,32,35,112,114,105,110,116,40,109,121,112,97,116,104,41,10,
// '      if mypath not in checksums:\n
32,32,32,32,32,32,105,102,32,109,121,112,97,116,104,32,110,111,116,32,105,110,
32,99,104,101,99,107,115,117,109,115,58,10,
// '        checksums[mypath] = calculate_checksum(mypath)\n
32,32,32,32,32,32,32,32,99,104,101,99,107,115,117,109,115,91,109,121,112,97,
116,104,93,32,61,32,99,97,108,99,117,108,97,116,101,95,99,104,101,99,107,115,
117,109,40,109,121,112,97,116,104,41,10,
// '      elif mypath in checksums:\n
32,32,32,32,32,32,101,108,105,102,32,109,121,112,97,116,104,32,105,110,32,99,
104,101,99,107,115,117,109,115,58,10,
// '        csum = calculate_checksum(mypath)\n
32,32,32,32,32,32,32,32,99,115,117,109,32,61,32,99,97,108,99,117,108,97,116,
101,95,99,104,101,99,107,115,117,109,40,109,121,112,97,116,104,41,10,
// '        if checksums[mypath] != csum:\n
32,32,32,32,32,32,32,32,105,102,32,99,104,101,99,107,115,117,109,115,91,109,
121,112,97,116,104,93,32,33,61,32,99,115,117,109,58,10,
// "          importlib.reload('''+funcname[1]+''')\n
32,32,32,32,32,32,32,32,32,32,105,109,112,111,114,116,108,105,98,46,114,101,
108,111,97,100,40,39,39,39,43,102,117,110,99,110,97,109,101,91,49,93,43,39,39,
39,41,10,
// '          checksums[mypath] = csum\n
32,32,32,32,32,32,32,32,32,32,99,104,101,99,107,115,117,109,115,91,109,121,112,
97,116,104,93,32,61,32,99,115,117,109,10,
// ' except ImportError as import_err:\n
32,101,120,99,101,112,116,32,73,109,112,111,114,116,69,114,114,111,114,32,97,
115,32,105,109,112,111,114,116,95,101,114,114,58,10,
// "    importlib.reload('''+funcname[0]+''')\n
32,32,32,32,105,109,112,111,114,116,108,105,98,46,114,101,108,111,97,100,40,
39,39,39,43,102,117,110,99,110,97,109,101,91,48,93,43,39,39,39,41,10,
// "    from  '''+funcname[0]+''' import '''+funcname[1]+'''\n
32,32,32,32,102,114,111,109,32,32,39,39,39,43,102,117,110,99,110,97,109,101,
91,48,93,43,39,39,39,32,105,109,112,111,114,116,32,39,39,39,43,102,117,110,99,
110,97,109,101,91,49,93,43,39,39,39,10,
// ' try:\n
32,116,114,121,58,10,
// "    if inspect.isgeneratorfunction('''+funcname[1]+'''.'''+funcname[2]+'''):\n
32,32,32,32,105,102,32,105,110,115,112,101,99,116,46,105,115,103,101,110,101,
114,97,116,111,114,102,117,110,99,116,105,111,110,40,39,39,39,43,102,117,110,
99,110,97,109,101,91,49,93,43,39,39,39,46,39,39,39,43,102,117,110,99,110,97,
109,101,91,50,93,43,39,39,39,41,58,10,
// '        for n in range(insize):\n
32,32,32,32,32,32,32,32,102,111,114,32,110,32,105,110,32,114,97,110,103,101,
40,105,110,115,105,122,101,41,58,10,
// "            func = '''+funcname[1]+'''.'''+funcname[2]+'''('''+code_params+''')\n
32,32,32,32,32,32,32,32,32,32,32,32,102,117,110,99,32,61,32,39,39,39,43,102,
117,110,99,110,97,109,101,91,49,93,43,39,39,39,46,39,39,39,43,102,117,110,99,
110,97,109,101,91,50,93,43,39,39,39,40,39,39,39,43,99,111,100,101,95,112,97,
114,97,109,115,43,39,39,39,41,10,
// '            val = str(func)[-19:-1]\n
32,32,32,32,32,32,32,32,32,32,32,32,118,97,108,32,61,32,115,116,114,40,102,117,
110,99,41,91,45,49,57,58,45,49,93,10,
// '            iters[val] = func\n
32,32,32,32,32,32,32,32,32,32,32,32,105,116,101,114,115,91,118,97,108,93,32,
61,32,102,117,110,99,10,
// '            resultstring[n] = ffi.from_buffer(memoryview(val))\n
32,32,32,32,32,32,32,32,32,32,32,32,114,101,115,117,108,116,115,116,114,105,
110,103,91,110,93,32,61,32,102,102,105,46,102,114,111,109,95,98,117,102,102,
101,114,40,109,101,109,111,114,121,118,105,101,119,40,118,97,108,41,41,10,
// '    else:\n
32,32,32,32,101,108,115,101,58,10,
// '        def tmpfunc(arrays, inputd, insize, func):\n
32,32,32,32,32,32,32,32,100,101,102,32,116,109,112,102,117,110,99,40,97,114,
114,97,121,115,44,32,105,110,112,117,116,100,44,32,105,110,115,105,122,101,44,
32,102,117,110,99,41,58,10,
// "            return [func('''+code_params+''') for n in range(insize)]\n
32,32,32,32,32,32,32,32,32,32,32,32,114,101,116,117,114,110,32,91,102,117,110,
99,40,39,39,39,43,99,111,100,101,95,112,97,114,97,109,115,43,39,39,39,41,32,
102,111,114,32,110,32,105,110,32,114,97,110,103,101,40,105,110,115,105,122,101,
41,93,10,
// "        tmpstrs = tmpfunc(arrays,inputd, insize, '''+funcname[1]+'''.'''+funcname[2]+''')\n
32,32,32,32,32,32,32,32,116,109,112,115,116,114,115,32,61,32,116,109,112,102,
117,110,99,40,97,114,114,97,121,115,44,105,110,112,117,116,100,44,32,105,110,
115,105,122,101,44,32,39,39,39,43,102,117,110,99,110,97,109,101,91,49,93,43,
39,39,39,46,39,39,39,43,102,117,110,99,110,97,109,101,91,50,93,43,39,39,39,41,
10,
// '        #def tmpfunc(arrays, insize, func):\n
32,32,32,32,32,32,32,32,35,100,101,102,32,116,109,112,102,117,110,99,40,97,114,
114,97,121,115,44,32,105,110,115,105,122,101,44,32,102,117,110,99,41,58,10,
// '        #    return [ffi.cast("char **", arrays[0].array )[n] for n in range(insize)]\n
32,32,32,32,32,32,32,32,35,32,32,32,32,114,101,116,117,114,110,32,91,102,102,
105,46,99,97,115,116,40,34,99,104,97,114,32,42,42,34,44,32,97,114,114,97,121,
115,91,48,93,46,97,114,114,97,121,32,41,91,110,93,32,102,111,114,32,110,32,105,
110,32,114,97,110,103,101,40,105,110,115,105,122,101,41,93,10,
// "        #tmpstrs = tmpfunc(arrays, insize, '''+funcname[1]+'''.'''+funcname[2]+''')\n
32,32,32,32,32,32,32,32,35,116,109,112,115,116,114,115,32,61,32,116,109,112,
102,117,110,99,40,97,114,114,97,121,115,44,32,105,110,115,105,122,101,44,32,
39,39,39,43,102,117,110,99,110,97,109,101,91,49,93,43,39,39,39,46,39,39,39,43,
102,117,110,99,110,97,109,101,91,50,93,43,39,39,39,41,10,
// '        for n in range(insize):\n
32,32,32,32,32,32,32,32,102,111,114,32,110,32,105,110,32,114,97,110,103,101,
40,105,110,115,105,122,101,41,58,10,
// '            #resultstring[n] = tmpstrs[n]\n
32,32,32,32,32,32,32,32,32,32,32,32,35,114,101,115,117,108,116,115,116,114,105,
110,103,91,110,93,32,61,32,116,109,112,115,116,114,115,91,110,93,10,
// '            resultstring[n] = ffi.from_buffer(memoryview(tmpstrs[n]))\n
32,32,32,32,32,32,32,32,32,32,32,32,114,101,115,117,108,116,115,116,114,105,
110,103,91,110,93,32,61,32,102,102,105,46,102,114,111,109,95,98,117,102,102,
101,114,40,109,101,109,111,114,121,118,105,101,119,40,116,109,112,115,116,114,
115,91,110,93,41,41,10,
// "            #resultstring[n] = lib.strdup(ffi.from_buffer(memoryview('''+funcname[1]+'''.'''+funcname[2]+'''('''+code_params+'''))))\n
32,32,32,32,32,32,32,32,32,32,32,32,35,114,101,115,117,108,116,115,116,114,105,
110,103,91,110,93,32,61,32,108,105,98,46,115,116,114,100,117,112,40,102,102,
105,46,102,114,111,109,95,98,117,102,102,101,114,40,109,101,109,111,114,121,
118,105,101,119,40,39,39,39,43,102,117,110,99,110,97,109,101,91,49,93,43,39,
39,39,46,39,39,39,43,102,117,110,99,110,97,109,101,91,50,93,43,39,39,39,40,39,
39,39,43,99,111,100,101,95,112,97,114,97,109,115,43,39,39,39,41,41,41,41,10,
// ' except ImportError as import_err:\n
32,101,120,99,101,112,116,32,73,109,112,111,114,116,69,114,114,111,114,32,97,
115,32,105,109,112,111,114,116,95,101,114,114,58,10,
// "    importlib.reload('''+funcname[0]+''')\n
32,32,32,32,105,109,112,111,114,116,108,105,98,46,114,101,108,111,97,100,40,
39,39,39,43,102,117,110,99,110,97,109,101,91,48,93,43,39,39,39,41,10,
// "    from  '''+funcname[0]+''' import '''+funcname[1]+'''\n
32,32,32,32,102,114,111,109,32,32,39,39,39,43,102,117,110,99,110,97,109,101,
91,48,93,43,39,39,39,32,105,109,112,111,114,116,32,39,39,39,43,102,117,110,99,
110,97,109,101,91,49,93,43,39,39,39,10,
// "    if inspect.isgeneratorfunction('''+funcname[1]+'''.'''+funcname[2]+'''):\n
32,32,32,32,105,102,32,105,110,115,112,101,99,116,46,105,115,103,101,110,101,
114,97,116,111,114,102,117,110,99,116,105,111,110,40,39,39,39,43,102,117,110,
99,110,97,109,101,91,49,93,43,39,39,39,46,39,39,39,43,102,117,110,99,110,97,
109,101,91,50,93,43,39,39,39,41,58,10,
// '        for n in range(insize):\n
32,32,32,32,32,32,32,32,102,111,114,32,110,32,105,110,32,114,97,110,103,101,
40,105,110,115,105,122,101,41,58,10,
// "            func = '''+funcname[1]+'''.'''+funcname[2]+'''('''+code_params+''')\n
32,32,32,32,32,32,32,32,32,32,32,32,102,117,110,99,32,61,32,39,39,39,43,102,
117,110,99,110,97,109,101,91,49,93,43,39,39,39,46,39,39,39,43,102,117,110,99,
110,97,109,101,91,50,93,43,39,39,39,40,39,39,39,43,99,111,100,101,95,112,97,
114,97,109,115,43,39,39,39,41,10,
// '            val = str(func)[-19:-1]\n
32,32,32,32,32,32,32,32,32,32,32,32,118,97,108,32,61,32,115,116,114,40,102,117,
110,99,41,91,45,49,57,58,45,49,93,10,
// '            iters[val] = func\n
32,32,32,32,32,32,32,32,32,32,32,32,105,116,101,114,115,91,118,97,108,93,32,
61,32,102,117,110,99,10,
// '            resultstring[n] = ffi.from_buffer(memoryview(val))\n
32,32,32,32,32,32,32,32,32,32,32,32,114,101,115,117,108,116,115,116,114,105,
110,103,91,110,93,32,61,32,102,102,105,46,102,114,111,109,95,98,117,102,102,
101,114,40,109,101,109,111,114,121,118,105,101,119,40,118,97,108,41,41,10,
// '    else:\n
32,32,32,32,101,108,115,101,58,10,
// '        def tmpfunc(arrays, inputd, insize, func):\n
32,32,32,32,32,32,32,32,100,101,102,32,116,109,112,102,117,110,99,40,97,114,
114,97,121,115,44,32,105,110,112,117,116,100,44,32,105,110,115,105,122,101,44,
32,102,117,110,99,41,58,10,
// "            return [func('''+code_params+''') for n in range(insize)]\n
32,32,32,32,32,32,32,32,32,32,32,32,114,101,116,117,114,110,32,91,102,117,110,
99,40,39,39,39,43,99,111,100,101,95,112,97,114,97,109,115,43,39,39,39,41,32,
102,111,114,32,110,32,105,110,32,114,97,110,103,101,40,105,110,115,105,122,101,
41,93,10,
// "        tmpstrs = tmpfunc(arrays,inputd, insize, '''+funcname[1]+'''.'''+funcname[2]+''')\n
32,32,32,32,32,32,32,32,116,109,112,115,116,114,115,32,61,32,116,109,112,102,
117,110,99,40,97,114,114,97,121,115,44,105,110,112,117,116,100,44,32,105,110,
115,105,122,101,44,32,39,39,39,43,102,117,110,99,110,97,109,101,91,49,93,43,
39,39,39,46,39,39,39,43,102,117,110,99,110,97,109,101,91,50,93,43,39,39,39,41,
10,
// '        for n in range(insize):\n
32,32,32,32,32,32,32,32,102,111,114,32,110,32,105,110,32,114,97,110,103,101,
40,105,110,115,105,122,101,41,58,10,
// '            resultstring[n] = ffi.from_buffer(memoryview(tmpstrs[n]))\n
32,32,32,32,32,32,32,32,32,32,32,32,114,101,115,117,108,116,115,116,114,105,
110,103,91,110,93,32,61,32,102,102,105,46,102,114,111,109,95,98,117,102,102,
101,114,40,109,101,109,111,114,121,118,105,101,119,40,116,109,112,115,116,114,
115,91,110,93,41,41,10,
// "            #resultstring[n] = lib.strdup(ffi.from_buffer(memoryview('''+funcname[1]+'''.'''+funcname[2]+'''('''+code_params+'''))))\n
32,32,32,32,32,32,32,32,32,32,32,32,35,114,101,115,117,108,116,115,116,114,105,
110,103,91,110,93,32,61,32,108,105,98,46,115,116,114,100,117,112,40,102,102,
105,46,102,114,111,109,95,98,117,102,102,101,114,40,109,101,109,111,114,121,
118,105,101,119,40,39,39,39,43,102,117,110,99,110,97,109,101,91,49,93,43,39,
39,39,46,39,39,39,43,102,117,110,99,110,97,109,101,91,50,93,43,39,39,39,40,39,
39,39,43,99,111,100,101,95,112,97,114,97,109,115,43,39,39,39,41,41,41,41,10,
// 'except Exception as e:\n
101,120,99,101,112,116,32,69,120,99,101,112,116,105,111,110,32,97,115,32,101,
58,10,
// "       errormessage[0] = lib.strdup(ffi.from_buffer(memoryview(b'UDFError '+ funcname[0].encode()+b'.'+funcname[1].encode()+b'.'+funcname[2].upper().encode() + b': ' + traceback.format_exc().encode())))\n
32,32,32,32,32,32,32,101,114,114,111,114,109,101,115,115,97,103,101,91,48,93,
32,61,32,108,105,98,46,115,116,114,100,117,112,40,102,102,105,46,102,114,111,
109,95,98,117,102,102,101,114,40,109,101,109,111,114,121,118,105,101,119,40,
98,39,85,68,70,69,114,114,111,114,32,39,43,32,102,117,110,99,110,97,109,101,
91,48,93,46,101,110,99,111,100,101,40,41,43,98,39,46,39,43,102,117,110,99,110,
97,109,101,91,49,93,46,101,110,99,111,100,101,40,41,43,98,39,46,39,43,102,117,
110,99,110,97,109,101,91,50,93,46,117,112,112,101,114,40,41,46,101,110,99,111,
100,101,40,41,32,43,32,98,39,58,32,39,32,43,32,116,114,97,99,101,98,97,99,107,
46,102,111,114,109,97,116,95,101,120,99,40,41,46,101,110,99,111,100,101,40,41,
41,41,41,10,
// '       errorm = 1\n
32,32,32,32,32,32,32,101,114,114,111,114,109,32,61,32,49,10,
// "       '''\n
32,32,32,32,32,32,32,39,39,39,10,
// '       elif isliteral == 1:\n
32,32,32,32,32,32,32,101,108,105,102,32,105,115,108,105,116,101,114,97,108,32,
61,61,32,49,58,10,
// "           code_string = '''\n
32,32,32,32,32,32,32,32,32,32,32,99,111,100,101,95,115,116,114,105,110,103,32,
61,32,39,39,39,10,
// 'try:\n
116,114,121,58,10,
// '  try:\n
32,32,116,114,121,58,10,
// "    from  '''+funcname[0]+''' import '''+funcname[1]+'''\n
32,32,32,32,102,114,111,109,32,32,39,39,39,43,102,117,110,99,110,97,109,101,
91,48,93,43,39,39,39,32,105,109,112,111,114,116,32,39,39,39,43,102,117,110,99,
110,97,109,101,91,49,93,43,39,39,39,10,
// '  except:\n
32,32,101,120,99,101,112,116,58,10,
// "    importlib.reload('''+funcname[0]+''')\n
32,32,32,32,105,109,112,111,114,116,108,105,98,46,114,101,108,111,97,100,40,
39,39,39,43,102,117,110,99,110,97,109,101,91,48,93,43,39,39,39,41,10,
// "    from  '''+funcname[0]+''' import '''+funcname[1]+'''\n
32,32,32,32,102,114,111,109,32,32,39,39,39,43,102,117,110,99,110,97,109,101,
91,48,93,43,39,39,39,32,105,109,112,111,114,116,32,39,39,39,43,102,117,110,99,
110,97,109,101,91,49,93,43,39,39,39,10,
// '  try:\n
32,32,116,114,121,58,10,
// "    if inspect.isgeneratorfunction('''+funcname[1]+'''.'''+funcname[2]+'''):\n
32,32,32,32,105,102,32,105,110,115,112,101,99,116,46,105,115,103,101,110,101,
114,97,116,111,114,102,117,110,99,116,105,111,110,40,39,39,39,43,102,117,110,
99,110,97,109,101,91,49,93,43,39,39,39,46,39,39,39,43,102,117,110,99,110,97,
109,101,91,50,93,43,39,39,39,41,58,10,
// '        for n in range(insize):\n
32,32,32,32,32,32,32,32,102,111,114,32,110,32,105,110,32,114,97,110,103,101,
40,105,110,115,105,122,101,41,58,10,
// "            func = '''+funcname[1]+'''.'''+funcname[2]+'''('''+code_params+''')\n
32,32,32,32,32,32,32,32,32,32,32,32,102,117,110,99,32,61,32,39,39,39,43,102,
117,110,99,110,97,109,101,91,49,93,43,39,39,39,46,39,39,39,43,102,117,110,99,
110,97,109,101,91,50,93,43,39,39,39,40,39,39,39,43,99,111,100,101,95,112,97,
114,97,109,115,43,39,39,39,41,10,
// '            val = str(func)[-19:-1]\n
32,32,32,32,32,32,32,32,32,32,32,32,118,97,108,32,61,32,115,116,114,40,102,117,
110,99,41,91,45,49,57,58,45,49,93,10,
// '            iters[val] = func\n
32,32,32,32,32,32,32,32,32,32,32,32,105,116,101,114,115,91,118,97,108,93,32,
61,32,102,117,110,99,10,
// '            resultstring[n] = ffi.from_buffer(memoryview(val))\n
32,32,32,32,32,32,32,32,32,32,32,32,114,101,115,117,108,116,115,116,114,105,
110,103,91,110,93,32,61,32,102,102,105,46,102,114,111,109,95,98,117,102,102,
101,114,40,109,101,109,111,114,121,118,105,101,119,40,118,97,108,41,41,10,
// '    else:\n
32,32,32,32,101,108,115,101,58,10,
// '        for n in range(insize):\n
32,32,32,32,32,32,32,32,102,111,114,32,110,32,105,110,32,114,97,110,103,101,
40,105,110,115,105,122,101,41,58,10,
// "            resultstring[n] = ffi.from_buffer(memoryview('''+funcname[1]+'''.'''+funcname[2]+'''('''+code_params+''')))\n
32,32,32,32,32,32,32,32,32,32,32,32,114,101,115,117,108,116,115,116,114,105,
110,103,91,110,93,32,61,32,102,102,105,46,102,114,111,109,95,98,117,102,102,
101,114,40,109,101,109,111,114,121,118,105,101,119,40,39,39,39,43,102,117,110,
99,110,97,109,101,91,49,93,43,39,39,39,46,39,39,39,43,102,117,110,99,110,97,
109,101,91,50,93,43,39,39,39,40,39,39,39,43,99,111,100,101,95,112,97,114,97,
109,115,43,39,39,39,41,41,41,10,
// '  except:\n
32,32,101,120,99,101,112,116,58,10,
// "    importlib.reload('''+funcname[0]+''')\n
32,32,32,32,105,109,112,111,114,116,108,105,98,46,114,101,108,111,97,100,40,
39,39,39,43,102,117,110,99,110,97,109,101,91,48,93,43,39,39,39,41,10,
// "    from  '''+funcname[0]+''' import '''+funcname[1]+'''\n
32,32,32,32,102,114,111,109,32,32,39,39,39,43,102,117,110,99,110,97,109,101,
91,48,93,43,39,39,39,32,105,109,112,111,114,116,32,39,39,39,43,102,117,110,99,
110,97,109,101,91,49,93,43,39,39,39,10,
// "    if inspect.isgeneratorfunction('''+funcname[1]+'''.'''+funcname[2]+'''):\n
32,32,32,32,105,102,32,105,110,115,112,101,99,116,46,105,115,103,101,110,101,
114,97,116,111,114,102,117,110,99,116,105,111,110,40,39,39,39,43,102,117,110,
99,110,97,109,101,91,49,93,43,39,39,39,46,39,39,39,43,102,117,110,99,110,97,
109,101,91,50,93,43,39,39,39,41,58,10,
// '        for n in range(insize):\n
32,32,32,32,32,32,32,32,102,111,114,32,110,32,105,110,32,114,97,110,103,101,
40,105,110,115,105,122,101,41,58,10,
// "            func = '''+funcname[1]+'''.'''+funcname[2]+'''('''+code_params+''')\n
32,32,32,32,32,32,32,32,32,32,32,32,102,117,110,99,32,61,32,39,39,39,43,102,
117,110,99,110,97,109,101,91,49,93,43,39,39,39,46,39,39,39,43,102,117,110,99,
110,97,109,101,91,50,93,43,39,39,39,40,39,39,39,43,99,111,100,101,95,112,97,
114,97,109,115,43,39,39,39,41,10,
// '            val = str(func)[-19:-1]\n
32,32,32,32,32,32,32,32,32,32,32,32,118,97,108,32,61,32,115,116,114,40,102,117,
110,99,41,91,45,49,57,58,45,49,93,10,
// '            iters[val] = func\n
32,32,32,32,32,32,32,32,32,32,32,32,105,116,101,114,115,91,118,97,108,93,32,
61,32,102,117,110,99,10,
// '            resultstring[n] = ffi.from_buffer(memoryview(val))\n
32,32,32,32,32,32,32,32,32,32,32,32,114,101,115,117,108,116,115,116,114,105,
110,103,91,110,93,32,61,32,102,102,105,46,102,114,111,109,95,98,117,102,102,
101,114,40,109,101,109,111,114,121,118,105,101,119,40,118,97,108,41,41,10,
// '    else:\n
32,32,32,32,101,108,115,101,58,10,
// '        for n in range(insize):\n
32,32,32,32,32,32,32,32,102,111,114,32,110,32,105,110,32,114,97,110,103,101,
40,105,110,115,105,122,101,41,58,10,
// "            resultstring[n] = ffi.from_buffer(memoryview('''+funcname[1]+'''.'''+funcname[2]+'''('''+code_params+''')))\n
32,32,32,32,32,32,32,32,32,32,32,32,114,101,115,117,108,116,115,116,114,105,
110,103,91,110,93,32,61,32,102,102,105,46,102,114,111,109,95,98,117,102,102,
101,114,40,109,101,109,111,114,121,118,105,101,119,40,39,39,39,43,102,117,110,
99,110,97,109,101,91,49,93,43,39,39,39,46,39,39,39,43,102,117,110,99,110,97,
109,101,91,50,93,43,39,39,39,40,39,39,39,43,99,111,100,101,95,112,97,114,97,
109,115,43,39,39,39,41,41,41,10,
// 'except Exception as e:\n
101,120,99,101,112,116,32,69,120,99,101,112,116,105,111,110,32,97,115,32,101,
58,10,
// "       errormessage[0] = lib.strdup(ffi.from_buffer(memoryview(b'UDFError '+ funcname[0].encode()+b'.'+funcname[1].encode()+b'.'+funcname[2].upper().encode() + b': ' + traceback.format_exc().encode())))\n
32,32,32,32,32,32,32,101,114,114,111,114,109,101,115,115,97,103,101,91,48,93,
32,61,32,108,105,98,46,115,116,114,100,117,112,40,102,102,105,46,102,114,111,
109,95,98,117,102,102,101,114,40,109,101,109,111,114,121,118,105,101,119,40,
98,39,85,68,70,69,114,114,111,114,32,39,43,32,102,117,110,99,110,97,109,101,
91,48,93,46,101,110,99,111,100,101,40,41,43,98,39,46,39,43,102,117,110,99,110,
97,109,101,91,49,93,46,101,110,99,111,100,101,40,41,43,98,39,46,39,43,102,117,
110,99,110,97,109,101,91,50,93,46,117,112,112,101,114,40,41,46,101,110,99,111,
100,101,40,41,32,43,32,98,39,58,32,39,32,43,32,116,114,97,99,101,98,97,99,107,
46,102,111,114,109,97,116,95,101,120,99,40,41,46,101,110,99,111,100,101,40,41,
41,41,41,10,
// '       errorm = 1\n
32,32,32,32,32,32,32,101,114,114,111,114,109,32,61,32,49,10,
// "       '''\n
32,32,32,32,32,32,32,39,39,39,10,
// '       print(code_string)\n
32,32,32,32,32,32,32,112,114,105,110,116,40,99,111,100,101,95,115,116,114,105,
110,103,41,10,
// '       exec(code_string)\n
32,32,32,32,32,32,32,101,120,101,99,40,99,111,100,101,95,115,116,114,105,110,
103,41,10,
// '       if (errorm == 1):\n
32,32,32,32,32,32,32,105,102,32,40,101,114,114,111,114,109,32,61,61,32,49,41,
58,10,
// '           return 0\n
32,32,32,32,32,32,32,32,32,32,32,114,101,116,117,114,110,32,48,10,
// '       else:\n
32,32,32,32,32,32,32,101,108,115,101,58,10,
// '           return 1\n
32,32,32,32,32,32,32,32,32,32,32,114,101,116,117,114,110,32,49,10,
// '   except Exception as e:\n
32,32,32,101,120,99,101,112,116,32,69,120,99,101,112,116,105,111,110,32,97,115,
32,101,58,10,
// '    # Capture and return the error message\n
32,32,32,32,35,32,67,97,112,116,117,114,101,32,97,110,100,32,114,101,116,117,
114,110,32,116,104,101,32,101,114,114,111,114,32,109,101,115,115,97,103,101,
10,
// "       errormessage[0] = lib.strdup(ffi.from_buffer(memoryview(b'UDFError '+ funcname[0].encode()+b'.'+funcname[1].encode()+b'.'+funcname[2].upper().encode() + b': ' + traceback.format_exc().encode())))\n
32,32,32,32,32,32,32,101,114,114,111,114,109,101,115,115,97,103,101,91,48,93,
32,61,32,108,105,98,46,115,116,114,100,117,112,40,102,102,105,46,102,114,111,
109,95,98,117,102,102,101,114,40,109,101,109,111,114,121,118,105,101,119,40,
98,39,85,68,70,69,114,114,111,114,32,39,43,32,102,117,110,99,110,97,109,101,
91,48,93,46,101,110,99,111,100,101,40,41,43,98,39,46,39,43,102,117,110,99,110,
97,109,101,91,49,93,46,101,110,99,111,100,101,40,41,43,98,39,46,39,43,102,117,
110,99,110,97,109,101,91,50,93,46,117,112,112,101,114,40,41,46,101,110,99,111,
100,101,40,41,32,43,32,98,39,58,32,39,32,43,32,116,114,97,99,101,98,97,99,107,
46,102,111,114,109,97,116,95,101,120,99,40,41,46,101,110,99,111,100,101,40,41,
41,41,41,10,
// '       return 0\n
32,32,32,32,32,32,32,114,101,116,117,114,110,32,48,10,
// '\n
10,
// '@ffi.def_extern()\n
64,102,102,105,46,100,101,102,95,101,120,116,101,114,110,40,41,10,
// 'def myfree(array):\n
100,101,102,32,109,121,102,114,101,101,40,97,114,114,97,121,41,58,10,
// '    lib.free(array)\n
32,32,32,32,108,105,98,46,102,114,101,101,40,97,114,114,97,121,41,10,
// '\n
10,
// '@ffi.def_extern()\n
64,102,102,105,46,100,101,102,95,101,120,116,101,114,110,40,41,10,
// 'def scalarfusionwrapper(funcnames, nfuncs, paramsnum, arrays, resultdouble, resultint, resultstring, insize, isliteral):\n
100,101,102,32,115,99,97,108,97,114,102,117,115,105,111,110,119,114,97,112,112,
101,114,40,102,117,110,99,110,97,109,101,115,44,32,110,102,117,110,99,115,44,
32,112,97,114,97,109,115,110,117,109,44,32,97,114,114,97,121,115,44,32,114,101,
115,117,108,116,100,111,117,98,108,101,44,32,114,101,115,117,108,116,105,110,
116,44,32,114,101,115,117,108,116,115,116,114,105,110,103,44,32,105,110,115,
105,122,101,44,32,105,115,108,105,116,101,114,97,108,41,58,10,
// '   global global_lock\n
32,32,32,103,108,111,98,97,108,32,103,108,111,98,97,108,95,108,111,99,107,10,
// '   with global_lock:\n
32,32,32,119,105,116,104,32,103,108,111,98,97,108,95,108,111,99,107,58,10,
// '       fnames = [None]*nfuncs\n
32,32,32,32,32,32,32,102,110,97,109,101,115,32,61,32,91,78,111,110,101,93,42,
110,102,117,110,99,115,10,
// '       for i in range(nfuncs):\n
32,32,32,32,32,32,32,102,111,114,32,105,32,105,110,32,114,97,110,103,101,40,
110,102,117,110,99,115,41,58,10,
// '           tmpfuncname = ffi.string(funcnames[i]).decode()\n
32,32,32,32,32,32,32,32,32,32,32,116,109,112,102,117,110,99,110,97,109,101,32,
61,32,102,102,105,46,115,116,114,105,110,103,40,102,117,110,99,110,97,109,101,
115,91,105,93,41,46,100,101,99,111,100,101,40,41,10,
// "           fnames[i] = tmpfuncname.split('.')\n
32,32,32,32,32,32,32,32,32,32,32,102,110,97,109,101,115,91,105,93,32,61,32,116,
109,112,102,117,110,99,110,97,109,101,46,115,112,108,105,116,40,39,46,39,41,
10,
// '       inputd = [None]*paramsnum\n
32,32,32,32,32,32,32,105,110,112,117,116,100,32,61,32,91,78,111,110,101,93,42,
112,97,114,97,109,115,110,117,109,10,
// '       for i in range(paramsnum):\n
32,32,32,32,32,32,32,102,111,114,32,105,32,105,110,32,114,97,110,103,101,40,
112,97,114,97,109,115,110,117,109,41,58,10,
// '         if arrays[i].type == 0:\n
32,32,32,32,32,32,32,32,32,105,102,32,97,114,114,97,121,115,91,105,93,46,116,
121,112,101,32,61,61,32,48,58,10,
// '             inputd[i] = ffi.cast("char **", arrays[i].array )\n
32,32,32,32,32,32,32,32,32,32,32,32,32,105,110,112,117,116,100,91,105,93,32,
61,32,102,102,105,46,99,97,115,116,40,34,99,104,97,114,32,42,42,34,44,32,97,
114,114,97,121,115,91,105,93,46,97,114,114,97,121,32,41,10,
// '         elif arrays[i].type == 1:\n
32,32,32,32,32,32,32,32,32,101,108,105,102,32,97,114,114,97,121,115,91,105,93,
46,116,121,112,101,32,61,61,32,49,58,10,
// '             inputd[i] = ffi.cast("int *", arrays[i].array )\n
32,32,32,32,32,32,32,32,32,32,32,32,32,105,110,112,117,116,100,91,105,93,32,
61,32,102,102,105,46,99,97,115,116,40,34,105,110,116,32,42,34,44,32,97,114,114,
97,121,115,91,105,93,46,97,114,114,97,121,32,41,10,
// '         elif arrays[i].type == 2:\n
32,32,32,32,32,32,32,32,32,101,108,105,102,32,97,114,114,97,121,115,91,105,93,
46,116,121,112,101,32,61,61,32,50,58,10,
// '             inputd[i] = ffi.cast("double *", arrays[i].array)\n
32,32,32,32,32,32,32,32,32,32,32,32,32,105,110,112,117,116,100,91,105,93,32,
61,32,102,102,105,46,99,97,115,116,40,34,100,111,117,98,108,101,32,42,34,44,
32,97,114,114,97,121,115,91,105,93,46,97,114,114,97,121,41,10,
// '       if resultstring != ffi.NULL:\n
32,32,32,32,32,32,32,105,102,32,114,101,115,117,108,116,115,116,114,105,110,
103,32,33,61,32,102,102,105,46,78,85,76,76,58,10,
// "           resultparam = 'resultstring'\n
32,32,32,32,32,32,32,32,32,32,32,114,101,115,117,108,116,112,97,114,97,109,32,
61,32,39,114,101,115,117,108,116,115,116,114,105,110,103,39,10,
// '       elif resultint != ffi.NULL:\n
32,32,32,32,32,32,32,101,108,105,102,32,114,101,115,117,108,116,105,110,116,
32,33,61,32,102,102,105,46,78,85,76,76,58,10,
// "           resultparam = 'resultint'\n
32,32,32,32,32,32,32,32,32,32,32,114,101,115,117,108,116,112,97,114,97,109,32,
61,32,39,114,101,115,117,108,116,105,110,116,39,10,
// '       elif resultdouble != ffi.NULL:\n
32,32,32,32,32,32,32,101,108,105,102,32,114,101,115,117,108,116,100,111,117,
98,108,101,32,33,61,32,102,102,105,46,78,85,76,76,58,10,
// "           resultparam = 'resultdouble'\n
32,32,32,32,32,32,32,32,32,32,32,114,101,115,117,108,116,112,97,114,97,109,32,
61,32,39,114,101,115,117,108,116,100,111,117,98,108,101,39,10,
// '       code_params = \', \'.join([\'inputd[\'+str(j)+\'][n]\' if arrays[j].type != 0 else \'ffi.string(ffi.cast("char **", arrays[\'+str(j)+\'].array )[n])\' for j in range(paramsnum)])\n
32,32,32,32,32,32,32,99,111,100,101,95,112,97,114,97,109,115,32,61,32,39,44,
32,39,46,106,111,105,110,40,91,39,105,110,112,117,116,100,91,39,43,115,116,114,
40,106,41,43,39,93,91,110,93,39,32,105,102,32,97,114,114,97,121,115,91,106,93,
46,116,121,112,101,32,33,61,32,48,32,101,108,115,101,32,39,102,102,105,46,115,
116,114,105,110,103,40,102,102,105,46,99,97,115,116,40,34,99,104,97,114,32,42,
42,34,44,32,97,114,114,97,121,115,91,39,43,115,116,114,40,106,41,43,39,93,46,
97,114,114,97,121,32,41,91,110,93,41,39,32,102,111,114,32,106,32,105,110,32,
114,97,110,103,101,40,112,97,114,97,109,115,110,117,109,41,93,41,10,
// "       importcode = '\\n    '.join([f'from {fnames[j][0]} import {fnames[j][1]}' for j in range(nfuncs)])\n
32,32,32,32,32,32,32,105,109,112,111,114,116,99,111,100,101,32,61,32,39,92,110,
32,32,32,32,39,46,106,111,105,110,40,91,102,39,102,114,111,109,32,123,102,110,
97,109,101,115,91,106,93,91,48,93,125,32,105,109,112,111,114,116,32,123,102,
110,97,109,101,115,91,106,93,91,49,93,125,39,32,102,111,114,32,106,32,105,110,
32,114,97,110,103,101,40,110,102,117,110,99,115,41,93,41,10,
// "       reloadcode = '\\n    '.join([f'importlib.reload({fnames[j][0]})' for j in range(nfuncs)])\n
32,32,32,32,32,32,32,114,101,108,111,97,100,99,111,100,101,32,61,32,39,92,110,
32,32,32,32,39,46,106,111,105,110,40,91,102,39,105,109,112,111,114,116,108,105,
98,46,114,101,108,111,97,100,40,123,102,110,97,109,101,115,91,106,93,91,48,93,
125,41,39,32,102,111,114,32,106,32,105,110,32,114,97,110,103,101,40,110,102,
117,110,99,115,41,93,41,10,
// '       fused_code_call = \'\'.join(f"{v2}.{v3}(" for _, v2, v3 in fnames) + code_params + \')\' * nfuncs\n
32,32,32,32,32,32,32,102,117,115,101,100,95,99,111,100,101,95,99,97,108,108,
32,61,32,39,39,46,106,111,105,110,40,102,34,123,118,50,125,46,123,118,51,125,
40,34,32,102,111,114,32,95,44,32,118,50,44,32,118,51,32,105,110,32,102,110,97,
109,101,115,41,32,43,32,99,111,100,101,95,112,97,114,97,109,115,32,43,32,39,
41,39,32,42,32,110,102,117,110,99,115,10,
// '       fused_code_call_inside = \'\'.join(f"fnames[{str(i)}](" for i, v in enumerate(fnames)) + code_params + \')\' * nfuncs\n
32,32,32,32,32,32,32,102,117,115,101,100,95,99,111,100,101,95,99,97,108,108,
95,105,110,115,105,100,101,32,61,32,39,39,46,106,111,105,110,40,102,34,102,110,
97,109,101,115,91,123,115,116,114,40,105,41,125,93,40,34,32,102,111,114,32,105,
44,32,118,32,105,110,32,101,110,117,109,101,114,97,116,101,40,102,110,97,109,
101,115,41,41,32,43,32,99,111,100,101,95,112,97,114,97,109,115,32,43,32,39,41,
39,32,42,32,110,102,117,110,99,115,10,
// '       fnamesembed = \',\'.join(f"{v2}.{v3}" for _, v2, v3 in fnames)\n
32,32,32,32,32,32,32,102,110,97,109,101,115,101,109,98,101,100,32,61,32,39,44,
39,46,106,111,105,110,40,102,34,123,118,50,125,46,123,118,51,125,34,32,102,111,
114,32,95,44,32,118,50,44,32,118,51,32,105,110,32,102,110,97,109,101,115,41,
10,
// "       if resultparam != 'resultstring':\n
32,32,32,32,32,32,32,105,102,32,114,101,115,117,108,116,112,97,114,97,109,32,
33,61,32,39,114,101,115,117,108,116,115,116,114,105,110,103,39,58,10,
// "           code_string = '''\n
32,32,32,32,32,32,32,32,32,32,32,99,111,100,101,95,115,116,114,105,110,103,32,
61,32,39,39,39,10,
// 'try:\n
116,114,121,58,10,
// "    '''+importcode+'''\n
32,32,32,32,39,39,39,43,105,109,112,111,114,116,99,111,100,101,43,39,39,39,10,
// '    for n in range(insize):\n
32,32,32,32,102,111,114,32,110,32,105,110,32,114,97,110,103,101,40,105,110,115,
105,122,101,41,58,10,
// "      '''+resultparam+'''[n] = '''+fused_code_call+'''\n
32,32,32,32,32,32,39,39,39,43,114,101,115,117,108,116,112,97,114,97,109,43,39,
39,39,91,110,93,32,61,32,39,39,39,43,102,117,115,101,100,95,99,111,100,101,95,
99,97,108,108,43,39,39,39,10,
// 'except:\n
101,120,99,101,112,116,58,10,
// "    '''+reloadcode+'''\n
32,32,32,32,39,39,39,43,114,101,108,111,97,100,99,111,100,101,43,39,39,39,10,
// "    '''+importcode+'''\n
32,32,32,32,39,39,39,43,105,109,112,111,114,116,99,111,100,101,43,39,39,39,10,
// '    for n in range(insize):\n
32,32,32,32,102,111,114,32,110,32,105,110,32,114,97,110,103,101,40,105,110,115,
105,122,101,41,58,10,
// "      '''+resultparam+'''[n] = '''+fused_code_call+'''\n
32,32,32,32,32,32,39,39,39,43,114,101,115,117,108,116,112,97,114,97,109,43,39,
39,39,91,110,93,32,61,32,39,39,39,43,102,117,115,101,100,95,99,111,100,101,95,
99,97,108,108,43,39,39,39,10,
// '\n
10,
// "     '''\n
32,32,32,32,32,39,39,39,10,
// '       elif isliteral == 0:\n
32,32,32,32,32,32,32,101,108,105,102,32,105,115,108,105,116,101,114,97,108,32,
61,61,32,48,58,10,
// "           code_string = '''\n
32,32,32,32,32,32,32,32,32,32,32,99,111,100,101,95,115,116,114,105,110,103,32,
61,32,39,39,39,10,
// 'try:\n
116,114,121,58,10,
// "    '''+importcode+'''\n
32,32,32,32,39,39,39,43,105,109,112,111,114,116,99,111,100,101,43,39,39,39,10,
// 'except:\n
101,120,99,101,112,116,58,10,
// "    '''+reloadcode+'''\n
32,32,32,32,39,39,39,43,114,101,108,111,97,100,99,111,100,101,43,39,39,39,10,
// "    '''+importcode+'''\n
32,32,32,32,39,39,39,43,105,109,112,111,114,116,99,111,100,101,43,39,39,39,10,
// '\n
10,
// 'def tmpfunc(*args):\n
100,101,102,32,116,109,112,102,117,110,99,40,42,97,114,103,115,41,58,10,
// '    arrays = args[0]\n
32,32,32,32,97,114,114,97,121,115,32,61,32,97,114,103,115,91,48,93,10,
// '    insize = args[1]\n
32,32,32,32,105,110,115,105,122,101,32,61,32,97,114,103,115,91,49,93,10,
// '    fnames = args[2:]\n
32,32,32,32,102,110,97,109,101,115,32,61,32,97,114,103,115,91,50,58,93,10,
// "    return ['''+fused_code_call_inside+''' for n in range(insize)]\n
32,32,32,32,114,101,116,117,114,110,32,91,39,39,39,43,102,117,115,101,100,95,
99,111,100,101,95,99,97,108,108,95,105,110,115,105,100,101,43,39,39,39,32,102,
111,114,32,110,32,105,110,32,114,97,110,103,101,40,105,110,115,105,122,101,41,
93,10,
// "tmpstrs = tmpfunc(arrays, insize, '''+fnamesembed+''')\n
116,109,112,115,116,114,115,32,61,32,116,109,112,102,117,110,99,40,97,114,114,
97,121,115,44,32,105,110,115,105,122,101,44,32,39,39,39,43,102,110,97,109,101,
115,101,109,98,101,100,43,39,39,39,41,10,
// 'for n in range(insize):\n
102,111,114,32,110,32,105,110,32,114,97,110,103,101,40,105,110,115,105,122,101,
41,58,10,
// '    resultstring[n] = ffi.from_buffer(memoryview(tmpstrs[n]))\n
32,32,32,32,114,101,115,117,108,116,115,116,114,105,110,103,91,110,93,32,61,
32,102,102,105,46,102,114,111,109,95,98,117,102,102,101,114,40,109,101,109,111,
114,121,118,105,101,119,40,116,109,112,115,116,114,115,91,110,93,41,41,10,
// "   #resultstring[n] = lib.strdup(ffi.from_buffer(memoryview('''+fused_code_call+'''))))\n
32,32,32,35,114,101,115,117,108,116,115,116,114,105,110,103,91,110,93,32,61,
32,108,105,98,46,115,116,114,100,117,112,40,102,102,105,46,102,114,111,109,95,
98,117,102,102,101,114,40,109,101,109,111,114,121,118,105,101,119,40,39,39,39,
43,102,117,115,101,100,95,99,111,100,101,95,99,97,108,108,43,39,39,39,41,41,
41,41,10,
// "       '''\n
32,32,32,32,32,32,32,39,39,39,10,
// '       elif isliteral == 1:\n
32,32,32,32,32,32,32,101,108,105,102,32,105,115,108,105,116,101,114,97,108,32,
61,61,32,49,58,10,
// "           code_string = '''\n
32,32,32,32,32,32,32,32,32,32,32,99,111,100,101,95,115,116,114,105,110,103,32,
61,32,39,39,39,10,
// 'try:\n
116,114,121,58,10,
// "    '''+importcode+'''\n
32,32,32,32,39,39,39,43,105,109,112,111,114,116,99,111,100,101,43,39,39,39,10,
// 'except:\n
101,120,99,101,112,116,58,10,
// "     '''+reloadcode+'''\n
32,32,32,32,32,39,39,39,43,114,101,108,111,97,100,99,111,100,101,43,39,39,39,
10,
// "     '''+importcode+'''\n
32,32,32,32,32,39,39,39,43,105,109,112,111,114,116,99,111,100,101,43,39,39,39,
10,
// 'for n in range(insize):\n
102,111,114,32,110,32,105,110,32,114,97,110,103,101,40,105,110,115,105,122,101,
41,58,10,
// "    resultstring[n] = ffi.from_buffer(memoryview('''+fused_code_call+''')))\n
32,32,32,32,114,101,115,117,108,116,115,116,114,105,110,103,91,110,93,32,61,
32,102,102,105,46,102,114,111,109,95,98,117,102,102,101,114,40,109,101,109,111,
114,121,118,105,101,119,40,39,39,39,43,102,117,115,101,100,95,99,111,100,101,
95,99,97,108,108,43,39,39,39,41,41,41,10,
// "       '''\n
32,32,32,32,32,32,32,39,39,39,10,
// '       print(code_string)\n
32,32,32,32,32,32,32,112,114,105,110,116,40,99,111,100,101,95,115,116,114,105,
110,103,41,10,
// '       exec(code_string)\n
32,32,32,32,32,32,32,101,120,101,99,40,99,111,100,101,95,115,116,114,105,110,
103,41,10,
// '       return 1\n
32,32,32,32,32,32,32,114,101,116,117,114,110,32,49,10,
// '\n
10,
// '\n
10,
// '@ffi.def_extern()\n
64,102,102,105,46,100,101,102,95,101,120,116,101,114,110,40,41,10,
// 'def rowtablewrapper(funcname, paramsnum, arrays, resultnum, resultarrays, insize):\n
100,101,102,32,114,111,119,116,97,98,108,101,119,114,97,112,112,101,114,40,102,
117,110,99,110,97,109,101,44,32,112,97,114,97,109,115,110,117,109,44,32,97,114,
114,97,121,115,44,32,114,101,115,117,108,116,110,117,109,44,32,114,101,115,117,
108,116,97,114,114,97,121,115,44,32,105,110,115,105,122,101,41,58,10,
// '     global tmpstrs\n
32,32,32,32,32,103,108,111,98,97,108,32,116,109,112,115,116,114,115,10,
// '     del tmpstrs[:]\n
32,32,32,32,32,100,101,108,32,116,109,112,115,116,114,115,91,58,93,10,
// '     tmpstrs = []\n
32,32,32,32,32,116,109,112,115,116,114,115,32,61,32,91,93,10,
// '     #global inc\n
32,32,32,32,32,35,103,108,111,98,97,108,32,105,110,99,10,
// '     funcname = ffi.string(funcname).decode()\n
32,32,32,32,32,102,117,110,99,110,97,109,101,32,61,32,102,102,105,46,115,116,
114,105,110,103,40,102,117,110,99,110,97,109,101,41,46,100,101,99,111,100,101,
40,41,10,
// "     funcname = funcname.split('.')\n
32,32,32,32,32,102,117,110,99,110,97,109,101,32,61,32,102,117,110,99,110,97,
109,101,46,115,112,108,105,116,40,39,46,39,41,10,
// '     inputd = [None]*paramsnum\n
32,32,32,32,32,105,110,112,117,116,100,32,61,32,91,78,111,110,101,93,42,112,
97,114,97,109,115,110,117,109,10,
// '     outputd = [None]*resultnum\n
32,32,32,32,32,111,117,116,112,117,116,100,32,61,32,91,78,111,110,101,93,42,
114,101,115,117,108,116,110,117,109,10,
// '     for i in range(paramsnum):\n
32,32,32,32,32,102,111,114,32,105,32,105,110,32,114,97,110,103,101,40,112,97,
114,97,109,115,110,117,109,41,58,10,
// '       if arrays[i].type == 0:\n
32,32,32,32,32,32,32,105,102,32,97,114,114,97,121,115,91,105,93,46,116,121,112,
101,32,61,61,32,48,58,10,
// '           inputd[i] = ffi.cast("char **", arrays[i].array )\n
32,32,32,32,32,32,32,32,32,32,32,105,110,112,117,116,100,91,105,93,32,61,32,
102,102,105,46,99,97,115,116,40,34,99,104,97,114,32,42,42,34,44,32,97,114,114,
97,121,115,91,105,93,46,97,114,114,97,121,32,41,10,
// '       elif arrays[i].type == 1:\n
32,32,32,32,32,32,32,101,108,105,102,32,97,114,114,97,121,115,91,105,93,46,116,
121,112,101,32,61,61,32,49,58,10,
// '           inputd[i] = ffi.cast("int *", arrays[i].array )\n
32,32,32,32,32,32,32,32,32,32,32,105,110,112,117,116,100,91,105,93,32,61,32,
102,102,105,46,99,97,115,116,40,34,105,110,116,32,42,34,44,32,97,114,114,97,
121,115,91,105,93,46,97,114,114,97,121,32,41,10,
// '       elif arrays[i].type == 2:\n
32,32,32,32,32,32,32,101,108,105,102,32,97,114,114,97,121,115,91,105,93,46,116,
121,112,101,32,61,61,32,50,58,10,
// '           inputd[i] = ffi.cast("double *", arrays[i].array)\n
32,32,32,32,32,32,32,32,32,32,32,105,110,112,117,116,100,91,105,93,32,61,32,
102,102,105,46,99,97,115,116,40,34,100,111,117,98,108,101,32,42,34,44,32,97,
114,114,97,121,115,91,105,93,46,97,114,114,97,121,41,10,
// '     code_params = \', \'.join([\'int(inputd[\'+str(j)+\'][n])\' if arrays[j].type == 1 else \'ffi.string(ffi.cast("char **", arrays[\'+str(j)+\'].array )[n])\' if arrays[j].type == 0 else \'float(inputd[\'+str(j)+\'][n])\' for j in range(paramsnum)])\n
32,32,32,32,32,99,111,100,101,95,112,97,114,97,109,115,32,61,32,39,44,32,39,
46,106,111,105,110,40,91,39,105,110,116,40,105,110,112,117,116,100,91,39,43,
115,116,114,40,106,41,43,39,93,91,110,93,41,39,32,105,102,32,97,114,114,97,121,
115,91,106,93,46,116,121,112,101,32,61,61,32,49,32,101,108,115,101,32,39,102,
102,105,46,115,116,114,105,110,103,40,102,102,105,46,99,97,115,116,40,34,99,
104,97,114,32,42,42,34,44,32,97,114,114,97,121,115,91,39,43,115,116,114,40,106,
41,43,39,93,46,97,114,114,97,121,32,41,91,110,93,41,39,32,105,102,32,97,114,
114,97,121,115,91,106,93,46,116,121,112,101,32,61,61,32,48,32,101,108,115,101,
32,39,102,108,111,97,116,40,105,110,112,117,116,100,91,39,43,115,116,114,40,
106,41,43,39,93,91,110,93,41,39,32,102,111,114,32,106,32,105,110,32,114,97,110,
103,101,40,112,97,114,97,109,115,110,117,109,41,93,41,10,
// '     retlen = insize*2\n
32,32,32,32,32,114,101,116,108,101,110,32,61,32,105,110,115,105,122,101,42,50,
10,
// '     for i in range(resultnum):\n
32,32,32,32,32,102,111,114,32,105,32,105,110,32,114,97,110,103,101,40,114,101,
115,117,108,116,110,117,109,41,58,10,
// '         if resultarrays[i].type == 0:\n
32,32,32,32,32,32,32,32,32,105,102,32,114,101,115,117,108,116,97,114,114,97,
121,115,91,105,93,46,116,121,112,101,32,61,61,32,48,58,10,
// '             resultarrays[i].array = ffi.cast("char**", lib.malloc(retlen*ffi.sizeof("char *")))\n
32,32,32,32,32,32,32,32,32,32,32,32,32,114,101,115,117,108,116,97,114,114,97,
121,115,91,105,93,46,97,114,114,97,121,32,61,32,102,102,105,46,99,97,115,116,
40,34,99,104,97,114,42,42,34,44,32,108,105,98,46,109,97,108,108,111,99,40,114,
101,116,108,101,110,42,102,102,105,46,115,105,122,101,111,102,40,34,99,104,97,
114,32,42,34,41,41,41,10,
// '             outputd[i] = ffi.cast("char **", resultarrays[i].array )\n
32,32,32,32,32,32,32,32,32,32,32,32,32,111,117,116,112,117,116,100,91,105,93,
32,61,32,102,102,105,46,99,97,115,116,40,34,99,104,97,114,32,42,42,34,44,32,
114,101,115,117,108,116,97,114,114,97,121,115,91,105,93,46,97,114,114,97,121,
32,41,10,
// '         elif resultarrays[i].type == 1:\n
32,32,32,32,32,32,32,32,32,101,108,105,102,32,114,101,115,117,108,116,97,114,
114,97,121,115,91,105,93,46,116,121,112,101,32,61,61,32,49,58,10,
// '             resultarrays[i].array = ffi.cast("int*", lib.malloc(retlen*ffi.sizeof("int")))\n
32,32,32,32,32,32,32,32,32,32,32,32,32,114,101,115,117,108,116,97,114,114,97,
121,115,91,105,93,46,97,114,114,97,121,32,61,32,102,102,105,46,99,97,115,116,
40,34,105,110,116,42,34,44,32,108,105,98,46,109,97,108,108,111,99,40,114,101,
116,108,101,110,42,102,102,105,46,115,105,122,101,111,102,40,34,105,110,116,
34,41,41,41,10,
// '             outputd[i] = ffi.cast("int *", resultarrays[i].array )\n
32,32,32,32,32,32,32,32,32,32,32,32,32,111,117,116,112,117,116,100,91,105,93,
32,61,32,102,102,105,46,99,97,115,116,40,34,105,110,116,32,42,34,44,32,114,101,
115,117,108,116,97,114,114,97,121,115,91,105,93,46,97,114,114,97,121,32,41,10,
// '         elif resultarrays[i].type == 2:\n
32,32,32,32,32,32,32,32,32,101,108,105,102,32,114,101,115,117,108,116,97,114,
114,97,121,115,91,105,93,46,116,121,112,101,32,61,61,32,50,58,10,
// '             resultarrays[i].array = ffi.cast("double*", lib.malloc(retlen*ffi.sizeof("double")))\n
32,32,32,32,32,32,32,32,32,32,32,32,32,114,101,115,117,108,116,97,114,114,97,
121,115,91,105,93,46,97,114,114,97,121,32,61,32,102,102,105,46,99,97,115,116,
40,34,100,111,117,98,108,101,42,34,44,32,108,105,98,46,109,97,108,108,111,99,
40,114,101,116,108,101,110,42,102,102,105,46,115,105,122,101,111,102,40,34,100,
111,117,98,108,101,34,41,41,41,10,
// '             outputd[i] = ffi.cast("double *", resultarrays[i].array)\n
32,32,32,32,32,32,32,32,32,32,32,32,32,111,117,116,112,117,116,100,91,105,93,
32,61,32,102,102,105,46,99,97,115,116,40,34,100,111,117,98,108,101,32,42,34,
44,32,114,101,115,117,108,116,97,114,114,97,121,115,91,105,93,46,97,114,114,
97,121,41,10,
// '     if resultnum > 1:\n
32,32,32,32,32,105,102,32,114,101,115,117,108,116,110,117,109,32,62,32,49,58,
10,
// "         codeloop = '\\n    '.join(['outputd['+str(i)+'][cc] = lib.strdup(ffi.from_buffer(memoryview(row['+str(i)+'])))' if resultarrays[i].type == 0 else 'outputd['+str(i)+'][cc] = row['+str(i)+']' for i in range(resultnum)])\n
32,32,32,32,32,32,32,32,32,99,111,100,101,108,111,111,112,32,61,32,39,92,110,
32,32,32,32,39,46,106,111,105,110,40,91,39,111,117,116,112,117,116,100,91,39,
43,115,116,114,40,105,41,43,39,93,91,99,99,93,32,61,32,108,105,98,46,115,116,
114,100,117,112,40,102,102,105,46,102,114,111,109,95,98,117,102,102,101,114,
40,109,101,109,111,114,121,118,105,101,119,40,114,111,119,91,39,43,115,116,114,
40,105,41,43,39,93,41,41,41,39,32,105,102,32,114,101,115,117,108,116,97,114,
114,97,121,115,91,105,93,46,116,121,112,101,32,61,61,32,48,32,101,108,115,101,
32,39,111,117,116,112,117,116,100,91,39,43,115,116,114,40,105,41,43,39,93,91,
99,99,93,32,61,32,114,111,119,91,39,43,115,116,114,40,105,41,43,39,93,39,32,
102,111,114,32,105,32,105,110,32,114,97,110,103,101,40,114,101,115,117,108,116,
110,117,109,41,93,41,10,
// '     else:\n
32,32,32,32,32,101,108,115,101,58,10,
// "         codeloop = 'outputd['+str(i)+'][cc] = lib.strdup(ffi.from_buffer(memoryview(row)))' if resultarrays[i].type == 0 else 'outputd['+str(i)+'][cc] = row'\n
32,32,32,32,32,32,32,32,32,99,111,100,101,108,111,111,112,32,61,32,39,111,117,
116,112,117,116,100,91,39,43,115,116,114,40,105,41,43,39,93,91,99,99,93,32,61,
32,108,105,98,46,115,116,114,100,117,112,40,102,102,105,46,102,114,111,109,95,
98,117,102,102,101,114,40,109,101,109,111,114,121,118,105,101,119,40,114,111,
119,41,41,41,39,32,105,102,32,114,101,115,117,108,116,97,114,114,97,121,115,
91,105,93,46,116,121,112,101,32,61,61,32,48,32,101,108,115,101,32,39,111,117,
116,112,117,116,100,91,39,43,115,116,114,40,105,41,43,39,93,91,99,99,93,32,61,
32,114,111,119,39,10,
// "     code_string = '''\n
32,32,32,32,32,99,111,100,101,95,115,116,114,105,110,103,32,61,32,39,39,39,10,
// 'try:\n
116,114,121,58,10,
// "    from  '''+funcname[0]+''' import '''+funcname[1]+'''\n
32,32,32,32,102,114,111,109,32,32,39,39,39,43,102,117,110,99,110,97,109,101,
91,48,93,43,39,39,39,32,105,109,112,111,114,116,32,39,39,39,43,102,117,110,99,
110,97,109,101,91,49,93,43,39,39,39,10,
// 'except:\n
101,120,99,101,112,116,58,10,
// "    importlib.reload('''+funcname[0]+''')\n
32,32,32,32,105,109,112,111,114,116,108,105,98,46,114,101,108,111,97,100,40,
39,39,39,43,102,117,110,99,110,97,109,101,91,48,93,43,39,39,39,41,10,
// "    from  '''+funcname[0]+''' import '''+funcname[1]+'''\n
32,32,32,32,102,114,111,109,32,32,39,39,39,43,102,117,110,99,110,97,109,101,
91,48,93,43,39,39,39,32,105,109,112,111,114,116,32,39,39,39,43,102,117,110,99,
110,97,109,101,91,49,93,43,39,39,39,10,
// 'cc = -1\n
99,99,32,61,32,45,49,10,
// 'for n in range(insize):\n
102,111,114,32,110,32,105,110,32,114,97,110,103,101,40,105,110,115,105,122,101,
41,58,10,
// "  for row in '''+funcname[1]+'''.'''+funcname[2]+'''('''+code_params+'''):\n
32,32,102,111,114,32,114,111,119,32,105,110,32,39,39,39,43,102,117,110,99,110,
97,109,101,91,49,93,43,39,39,39,46,39,39,39,43,102,117,110,99,110,97,109,101,
91,50,93,43,39,39,39,40,39,39,39,43,99,111,100,101,95,112,97,114,97,109,115,
43,39,39,39,41,58,10,
// '    cc += 1\n
32,32,32,32,99,99,32,43,61,32,49,10,
// '    resultarrays[0].size = cc+1\n
32,32,32,32,114,101,115,117,108,116,97,114,114,97,121,115,91,48,93,46,115,105,
122,101,32,61,32,99,99,43,49,10,
// '    if cc >= retlen:\n
32,32,32,32,105,102,32,99,99,32,62,61,32,114,101,116,108,101,110,58,10,
// '        retlen = retlen*2\n
32,32,32,32,32,32,32,32,114,101,116,108,101,110,32,61,32,114,101,116,108,101,
110,42,50,10,
// '        for i in range(resultnum):\n
32,32,32,32,32,32,32,32,102,111,114,32,105,32,105,110,32,114,97,110,103,101,
40,114,101,115,117,108,116,110,117,109,41,58,10,
// '         if resultarrays[i].type == 0:\n
32,32,32,32,32,32,32,32,32,105,102,32,114,101,115,117,108,116,97,114,114,97,
121,115,91,105,93,46,116,121,112,101,32,61,61,32,48,58,10,
// '             resultarrays[i].array = ffi.cast("char**", lib.realloc(resultarrays[i].array,retlen*ffi.sizeof("char *")))\n
32,32,32,32,32,32,32,32,32,32,32,32,32,114,101,115,117,108,116,97,114,114,97,
121,115,91,105,93,46,97,114,114,97,121,32,61,32,102,102,105,46,99,97,115,116,
40,34,99,104,97,114,42,42,34,44,32,108,105,98,46,114,101,97,108,108,111,99,40,
114,101,115,117,108,116,97,114,114,97,121,115,91,105,93,46,97,114,114,97,121,
44,114,101,116,108,101,110,42,102,102,105,46,115,105,122,101,111,102,40,34,99,
104,97,114,32,42,34,41,41,41,10,
// '             outputd[i] = ffi.cast("char **", resultarrays[i].array )\n
32,32,32,32,32,32,32,32,32,32,32,32,32,111,117,116,112,117,116,100,91,105,93,
32,61,32,102,102,105,46,99,97,115,116,40,34,99,104,97,114,32,42,42,34,44,32,
114,101,115,117,108,116,97,114,114,97,121,115,91,105,93,46,97,114,114,97,121,
32,41,10,
// '         elif resultarrays[i].type == 1:\n
32,32,32,32,32,32,32,32,32,101,108,105,102,32,114,101,115,117,108,116,97,114,
114,97,121,115,91,105,93,46,116,121,112,101,32,61,61,32,49,58,10,
// '             resultarrays[i].array = ffi.cast("int*", lib.realloc(resultarrays[i].array, retlen*ffi.sizeof("int")))\n
32,32,32,32,32,32,32,32,32,32,32,32,32,114,101,115,117,108,116,97,114,114,97,
121,115,91,105,93,46,97,114,114,97,121,32,61,32,102,102,105,46,99,97,115,116,
40,34,105,110,116,42,34,44,32,108,105,98,46,114,101,97,108,108,111,99,40,114,
101,115,117,108,116,97,114,114,97,121,115,91,105,93,46,97,114,114,97,121,44,
32,114,101,116,108,101,110,42,102,102,105,46,115,105,122,101,111,102,40,34,105,
110,116,34,41,41,41,10,
// '             outputd[i] = ffi.cast("int*", resultarrays[i].array )\n
32,32,32,32,32,32,32,32,32,32,32,32,32,111,117,116,112,117,116,100,91,105,93,
32,61,32,102,102,105,46,99,97,115,116,40,34,105,110,116,42,34,44,32,114,101,
115,117,108,116,97,114,114,97,121,115,91,105,93,46,97,114,114,97,121,32,41,10,
// '         elif resultarrays[i].type == 2:\n
32,32,32,32,32,32,32,32,32,101,108,105,102,32,114,101,115,117,108,116,97,114,
114,97,121,115,91,105,93,46,116,121,112,101,32,61,61,32,50,58,10,
// '             resultarrays[i].array = ffi.cast("double*", lib.realloc(resultarrays[i].array, retlen*ffi.sizeof("double")))\n
32,32,32,32,32,32,32,32,32,32,32,32,32,114,101,115,117,108,116,97,114,114,97,
121,115,91,105,93,46,97,114,114,97,121,32,61,32,102,102,105,46,99,97,115,116,
40,34,100,111,117,98,108,101,42,34,44,32,108,105,98,46,114,101,97,108,108,111,
99,40,114,101,115,117,108,116,97,114,114,97,121,115,91,105,93,46,97,114,114,
97,121,44,32,114,101,116,108,101,110,42,102,102,105,46,115,105,122,101,111,102,
40,34,100,111,117,98,108,101,34,41,41,41,10,
// '             outputd[i] = ffi.cast("double", resultarrays[i].array )\n
32,32,32,32,32,32,32,32,32,32,32,32,32,111,117,116,112,117,116,100,91,105,93,
32,61,32,102,102,105,46,99,97,115,116,40,34,100,111,117,98,108,101,34,44,32,
114,101,115,117,108,116,97,114,114,97,121,115,91,105,93,46,97,114,114,97,121,
32,41,10,
// "    '''+codeloop\n
32,32,32,32,39,39,39,43,99,111,100,101,108,111,111,112,10,
// '     \n
32,32,32,32,32,10,
// '     print(code_string)\n
32,32,32,32,32,112,114,105,110,116,40,99,111,100,101,95,115,116,114,105,110,
103,41,10,
// '     exec(code_string)\n
32,32,32,32,32,101,120,101,99,40,99,111,100,101,95,115,116,114,105,110,103,41,
10,
// '     return 1\n
32,32,32,32,32,114,101,116,117,114,110,32,49,10,
// '\n
10,
// '@ffi.def_extern()\n
64,102,102,105,46,100,101,102,95,101,120,116,101,114,110,40,41,10,
// 'def rowtuplewrapper(funcname, paramsnum, arrays, resultnum, resultarrays, insize):\n
100,101,102,32,114,111,119,116,117,112,108,101,119,114,97,112,112,101,114,40,
102,117,110,99,110,97,109,101,44,32,112,97,114,97,109,115,110,117,109,44,32,
97,114,114,97,121,115,44,32,114,101,115,117,108,116,110,117,109,44,32,114,101,
115,117,108,116,97,114,114,97,121,115,44,32,105,110,115,105,122,101,41,58,10,
// '     #global tmpstrs\n
32,32,32,32,32,35,103,108,111,98,97,108,32,116,109,112,115,116,114,115,10,
// '     #del tmpstrs[:]\n
32,32,32,32,32,35,100,101,108,32,116,109,112,115,116,114,115,91,58,93,10,
// '     #tmpstrs = []\n
32,32,32,32,32,35,116,109,112,115,116,114,115,32,61,32,91,93,10,
// '     #global inc\n
32,32,32,32,32,35,103,108,111,98,97,108,32,105,110,99,10,
// '\n
10,
// '     funcname = ffi.string(funcname).decode()\n
32,32,32,32,32,102,117,110,99,110,97,109,101,32,61,32,102,102,105,46,115,116,
114,105,110,103,40,102,117,110,99,110,97,109,101,41,46,100,101,99,111,100,101,
40,41,10,
// "     funcname = funcname.split('.')\n
32,32,32,32,32,102,117,110,99,110,97,109,101,32,61,32,102,117,110,99,110,97,
109,101,46,115,112,108,105,116,40,39,46,39,41,10,
// '     inputd = [None]*paramsnum\n
32,32,32,32,32,105,110,112,117,116,100,32,61,32,91,78,111,110,101,93,42,112,
97,114,97,109,115,110,117,109,10,
// '     outputd = [None]*resultnum\n
32,32,32,32,32,111,117,116,112,117,116,100,32,61,32,91,78,111,110,101,93,42,
114,101,115,117,108,116,110,117,109,10,
// '     for i in range(paramsnum):\n
32,32,32,32,32,102,111,114,32,105,32,105,110,32,114,97,110,103,101,40,112,97,
114,97,109,115,110,117,109,41,58,10,
// '       if arrays[i].type == 0:\n
32,32,32,32,32,32,32,105,102,32,97,114,114,97,121,115,91,105,93,46,116,121,112,
101,32,61,61,32,48,58,10,
// '           inputd[i] = ffi.cast("char **", arrays[i].array )\n
32,32,32,32,32,32,32,32,32,32,32,105,110,112,117,116,100,91,105,93,32,61,32,
102,102,105,46,99,97,115,116,40,34,99,104,97,114,32,42,42,34,44,32,97,114,114,
97,121,115,91,105,93,46,97,114,114,97,121,32,41,10,
// '       elif arrays[i].type == 1:\n
32,32,32,32,32,32,32,101,108,105,102,32,97,114,114,97,121,115,91,105,93,46,116,
121,112,101,32,61,61,32,49,58,10,
// '           inputd[i] = ffi.cast("int *", arrays[i].array )\n
32,32,32,32,32,32,32,32,32,32,32,105,110,112,117,116,100,91,105,93,32,61,32,
102,102,105,46,99,97,115,116,40,34,105,110,116,32,42,34,44,32,97,114,114,97,
121,115,91,105,93,46,97,114,114,97,121,32,41,10,
// '       elif arrays[i].type == 2:\n
32,32,32,32,32,32,32,101,108,105,102,32,97,114,114,97,121,115,91,105,93,46,116,
121,112,101,32,61,61,32,50,58,10,
// '           inputd[i] = ffi.cast("double *", arrays[i].array)\n
32,32,32,32,32,32,32,32,32,32,32,105,110,112,117,116,100,91,105,93,32,61,32,
102,102,105,46,99,97,115,116,40,34,100,111,117,98,108,101,32,42,34,44,32,97,
114,114,97,121,115,91,105,93,46,97,114,114,97,121,41,10,
// '     for i in range(resultnum):\n
32,32,32,32,32,102,111,114,32,105,32,105,110,32,114,97,110,103,101,40,114,101,
115,117,108,116,110,117,109,41,58,10,
// '       if resultarrays[i].type == 0:\n
32,32,32,32,32,32,32,105,102,32,114,101,115,117,108,116,97,114,114,97,121,115,
91,105,93,46,116,121,112,101,32,61,61,32,48,58,10,
// '           outputd[i] = ffi.cast("char **", resultarrays[i].array )\n
32,32,32,32,32,32,32,32,32,32,32,111,117,116,112,117,116,100,91,105,93,32,61,
32,102,102,105,46,99,97,115,116,40,34,99,104,97,114,32,42,42,34,44,32,114,101,
115,117,108,116,97,114,114,97,121,115,91,105,93,46,97,114,114,97,121,32,41,10,
// '       elif resultarrays[i].type == 1:\n
32,32,32,32,32,32,32,101,108,105,102,32,114,101,115,117,108,116,97,114,114,97,
121,115,91,105,93,46,116,121,112,101,32,61,61,32,49,58,10,
// '           outputd[i] = ffi.cast("int *", resultarrays[i].array )\n
32,32,32,32,32,32,32,32,32,32,32,111,117,116,112,117,116,100,91,105,93,32,61,
32,102,102,105,46,99,97,115,116,40,34,105,110,116,32,42,34,44,32,114,101,115,
117,108,116,97,114,114,97,121,115,91,105,93,46,97,114,114,97,121,32,41,10,
// '       elif resultarrays[i].type == 2:\n
32,32,32,32,32,32,32,101,108,105,102,32,114,101,115,117,108,116,97,114,114,97,
121,115,91,105,93,46,116,121,112,101,32,61,61,32,50,58,10,
// '           outputd[i] = ffi.cast("double *", resultarrays[i].array)\n
32,32,32,32,32,32,32,32,32,32,32,111,117,116,112,117,116,100,91,105,93,32,61,
32,102,102,105,46,99,97,115,116,40,34,100,111,117,98,108,101,32,42,34,44,32,
114,101,115,117,108,116,97,114,114,97,121,115,91,105,93,46,97,114,114,97,121,
41,10,
// "     code_params = ', '.join(['inputd['+str(j)+'][n]' if arrays[j].type != 0 else 'ffi.string(inputd['+str(j)+'][n])' for j in range(paramsnum)])\n
32,32,32,32,32,99,111,100,101,95,112,97,114,97,109,115,32,61,32,39,44,32,39,
46,106,111,105,110,40,91,39,105,110,112,117,116,100,91,39,43,115,116,114,40,
106,41,43,39,93,91,110,93,39,32,105,102,32,97,114,114,97,121,115,91,106,93,46,
116,121,112,101,32,33,61,32,48,32,101,108,115,101,32,39,102,102,105,46,115,116,
114,105,110,103,40,105,110,112,117,116,100,91,39,43,115,116,114,40,106,41,43,
39,93,91,110,93,41,39,32,102,111,114,32,106,32,105,110,32,114,97,110,103,101,
40,112,97,114,97,109,115,110,117,109,41,93,41,10,
// "     code_string = '''\n
32,32,32,32,32,99,111,100,101,95,115,116,114,105,110,103,32,61,32,39,39,39,10,
// 'try:\n
116,114,121,58,10,
// "    from  '''+funcname[0]+''' import '''+funcname[1]+'''\n
32,32,32,32,102,114,111,109,32,32,39,39,39,43,102,117,110,99,110,97,109,101,
91,48,93,43,39,39,39,32,105,109,112,111,114,116,32,39,39,39,43,102,117,110,99,
110,97,109,101,91,49,93,43,39,39,39,10,
// 'except:\n
101,120,99,101,112,116,58,10,
// "    importlib.reload('''+funcname[0]+''')\n
32,32,32,32,105,109,112,111,114,116,108,105,98,46,114,101,108,111,97,100,40,
39,39,39,43,102,117,110,99,110,97,109,101,91,48,93,43,39,39,39,41,10,
// "    from  '''+funcname[0]+''' import '''+funcname[1]+'''\n
32,32,32,32,102,114,111,109,32,32,39,39,39,43,102,117,110,99,110,97,109,101,
91,48,93,43,39,39,39,32,105,109,112,111,114,116,32,39,39,39,43,102,117,110,99,
110,97,109,101,91,49,93,43,39,39,39,10,
// '#for n in range(insize):\n
35,102,111,114,32,110,32,105,110,32,114,97,110,103,101,40,105,110,115,105,122,
101,41,58,10,
// "#    tmpstrs.append('''+funcname[1]+'''.'''+funcname[2]+'''('''+code_params+'''))\n
35,32,32,32,32,116,109,112,115,116,114,115,46,97,112,112,101,110,100,40,39,39,
39,43,102,117,110,99,110,97,109,101,91,49,93,43,39,39,39,46,39,39,39,43,102,
117,110,99,110,97,109,101,91,50,93,43,39,39,39,40,39,39,39,43,99,111,100,101,
95,112,97,114,97,109,115,43,39,39,39,41,41,10,
// "     '''\n
32,32,32,32,32,39,39,39,10,
// '     print(code_string)\n
32,32,32,32,32,112,114,105,110,116,40,99,111,100,101,95,115,116,114,105,110,
103,41,10,
// '     exec(code_string)\n
32,32,32,32,32,101,120,101,99,40,99,111,100,101,95,115,116,114,105,110,103,41,
10,
// "     myvals = ','.join(['val'+str(n) for n in range(resultnum)])\n
32,32,32,32,32,109,121,118,97,108,115,32,61,32,39,44,39,46,106,111,105,110,40,
91,39,118,97,108,39,43,115,116,114,40,110,41,32,102,111,114,32,110,32,105,110,
32,114,97,110,103,101,40,114,101,115,117,108,116,110,117,109,41,93,41,10,
// "     funccallcode = myvals+ ' ='+funcname[1]+'.'+funcname[2]+'('+code_params+')'\n
32,32,32,32,32,102,117,110,99,99,97,108,108,99,111,100,101,32,61,32,109,121,
118,97,108,115,43,32,39,32,61,39,43,102,117,110,99,110,97,109,101,91,49,93,43,
39,46,39,43,102,117,110,99,110,97,109,101,91,50,93,43,39,40,39,43,99,111,100,
101,95,112,97,114,97,109,115,43,39,41,39,10,
// "     codeloop = '\\n    '.join(['outputd['+str(i)+'][n] = lib.strdup(ffi.from_buffer(memoryview(val'+str(i)+')))' if resultarrays[i].type == 0 else 'outputd['+str(i)+'][n] = val'+str(i)+'' for i in range(resultnum)])\n
32,32,32,32,32,99,111,100,101,108,111,111,112,32,61,32,39,92,110,32,32,32,32,
39,46,106,111,105,110,40,91,39,111,117,116,112,117,116,100,91,39,43,115,116,
114,40,105,41,43,39,93,91,110,93,32,61,32,108,105,98,46,115,116,114,100,117,
112,40,102,102,105,46,102,114,111,109,95,98,117,102,102,101,114,40,109,101,109,
111,114,121,118,105,101,119,40,118,97,108,39,43,115,116,114,40,105,41,43,39,
41,41,41,39,32,105,102,32,114,101,115,117,108,116,97,114,114,97,121,115,91,105,
93,46,116,121,112,101,32,61,61,32,48,32,101,108,115,101,32,39,111,117,116,112,
117,116,100,91,39,43,115,116,114,40,105,41,43,39,93,91,110,93,32,61,32,118,97,
108,39,43,115,116,114,40,105,41,43,39,39,32,102,111,114,32,105,32,105,110,32,
114,97,110,103,101,40,114,101,115,117,108,116,110,117,109,41,93,41,10,
// "     code_string = '''\n
32,32,32,32,32,99,111,100,101,95,115,116,114,105,110,103,32,61,32,39,39,39,10,
// 'for n in range(insize):\n
102,111,114,32,110,32,105,110,32,114,97,110,103,101,40,105,110,115,105,122,101,
41,58,10,
// "    '''+funccallcode+'''\n
32,32,32,32,39,39,39,43,102,117,110,99,99,97,108,108,99,111,100,101,43,39,39,
39,10,
// "    '''+codeloop+'''\n
32,32,32,32,39,39,39,43,99,111,100,101,108,111,111,112,43,39,39,39,10,
// "     '''\n
32,32,32,32,32,39,39,39,10,
// '     print(code_string)\n
32,32,32,32,32,112,114,105,110,116,40,99,111,100,101,95,115,116,114,105,110,
103,41,10,
// '     exec(code_string)\n
32,32,32,32,32,101,120,101,99,40,99,111,100,101,95,115,116,114,105,110,103,41,
10,
// '     return 1\n
32,32,32,32,32,114,101,116,117,114,110,32,49,10,
// '\n
10,
// '@ffi.def_extern()\n
64,102,102,105,46,100,101,102,95,101,120,116,101,114,110,40,41,10,
// 'def tablematerwrapper(paramsnum, arrays, resultnum, resultarrays, insize):\n
100,101,102,32,116,97,98,108,101,109,97,116,101,114,119,114,97,112,112,101,114,
40,112,97,114,97,109,115,110,117,109,44,32,97,114,114,97,121,115,44,32,114,101,
115,117,108,116,110,117,109,44,32,114,101,115,117,108,116,97,114,114,97,121,
115,44,32,105,110,115,105,122,101,41,58,10,
// '     inputd = [None]*paramsnum\n
32,32,32,32,32,105,110,112,117,116,100,32,61,32,91,78,111,110,101,93,42,112,
97,114,97,109,115,110,117,109,10,
// '     import functions\n
32,32,32,32,32,105,109,112,111,114,116,32,102,117,110,99,116,105,111,110,115,
10,
// '     outputd = [None]*resultnum\n
32,32,32,32,32,111,117,116,112,117,116,100,32,61,32,91,78,111,110,101,93,42,
114,101,115,117,108,116,110,117,109,10,
// '     for i in range(paramsnum):\n
32,32,32,32,32,102,111,114,32,105,32,105,110,32,114,97,110,103,101,40,112,97,
114,97,109,115,110,117,109,41,58,10,
// '       if arrays[i].type == 0:\n
32,32,32,32,32,32,32,105,102,32,97,114,114,97,121,115,91,105,93,46,116,121,112,
101,32,61,61,32,48,58,10,
// '           inputd[i] = ffi.cast("char **", arrays[i].array )\n
32,32,32,32,32,32,32,32,32,32,32,105,110,112,117,116,100,91,105,93,32,61,32,
102,102,105,46,99,97,115,116,40,34,99,104,97,114,32,42,42,34,44,32,97,114,114,
97,121,115,91,105,93,46,97,114,114,97,121,32,41,10,
// '       elif arrays[i].type == 1:\n
32,32,32,32,32,32,32,101,108,105,102,32,97,114,114,97,121,115,91,105,93,46,116,
121,112,101,32,61,61,32,49,58,10,
// '           inputd[i] = ffi.cast("int *", arrays[i].array )\n
32,32,32,32,32,32,32,32,32,32,32,105,110,112,117,116,100,91,105,93,32,61,32,
102,102,105,46,99,97,115,116,40,34,105,110,116,32,42,34,44,32,97,114,114,97,
121,115,91,105,93,46,97,114,114,97,121,32,41,10,
// '       elif arrays[i].type == 2:\n
32,32,32,32,32,32,32,101,108,105,102,32,97,114,114,97,121,115,91,105,93,46,116,
121,112,101,32,61,61,32,50,58,10,
// '           inputd[i] = ffi.cast("double *", arrays[i].array)\n
32,32,32,32,32,32,32,32,32,32,32,105,110,112,117,116,100,91,105,93,32,61,32,
102,102,105,46,99,97,115,116,40,34,100,111,117,98,108,101,32,42,34,44,32,97,
114,114,97,121,115,91,105,93,46,97,114,114,97,121,41,10,
// '     import uuid\n
32,32,32,32,32,105,109,112,111,114,116,32,117,117,105,100,10,
// '\n
10,
// '     results = [None]*paramsnum\n
32,32,32,32,32,114,101,115,117,108,116,115,32,61,32,91,78,111,110,101,93,42,
112,97,114,97,109,115,110,117,109,10,
// '     for i in range(paramsnum):\n
32,32,32,32,32,102,111,114,32,105,32,105,110,32,114,97,110,103,101,40,112,97,
114,97,109,115,110,117,109,41,58,10,
// '         if arrays[i].type != 0:\n
32,32,32,32,32,32,32,32,32,105,102,32,97,114,114,97,121,115,91,105,93,46,116,
121,112,101,32,33,61,32,48,58,10,
// '             results[i] = ffi.unpack(inputd[i], insize)\n
32,32,32,32,32,32,32,32,32,32,32,32,32,114,101,115,117,108,116,115,91,105,93,
32,61,32,102,102,105,46,117,110,112,97,99,107,40,105,110,112,117,116,100,91,
105,93,44,32,105,110,115,105,122,101,41,10,
// '         else:\n
32,32,32,32,32,32,32,32,32,101,108,115,101,58,10,
// '             results[i] = [ffi.string(inputd[i][x]) for x in range(insize)]\n
32,32,32,32,32,32,32,32,32,32,32,32,32,114,101,115,117,108,116,115,91,105,93,
32,61,32,91,102,102,105,46,115,116,114,105,110,103,40,105,110,112,117,116,100,
91,105,93,91,120,93,41,32,102,111,114,32,120,32,105,110,32,114,97,110,103,101,
40,105,110,115,105,122,101,41,93,10,
// '\n
10,
// '     resultarrays[0].array = ffi.cast("char**", lib.malloc(1*ffi.sizeof("char *")))\n
32,32,32,32,32,114,101,115,117,108,116,97,114,114,97,121,115,91,48,93,46,97,
114,114,97,121,32,61,32,102,102,105,46,99,97,115,116,40,34,99,104,97,114,42,
42,34,44,32,108,105,98,46,109,97,108,108,111,99,40,49,42,102,102,105,46,115,
105,122,101,111,102,40,34,99,104,97,114,32,42,34,41,41,41,10,
// '     outputd[0] = ffi.cast("char **", resultarrays[0].array )\n
32,32,32,32,32,111,117,116,112,117,116,100,91,48,93,32,61,32,102,102,105,46,
99,97,115,116,40,34,99,104,97,114,32,42,42,34,44,32,114,101,115,117,108,116,
97,114,114,97,121,115,91,48,93,46,97,114,114,97,121,32,41,10,
// '     resultarrays[0].size = 1\n
32,32,32,32,32,114,101,115,117,108,116,97,114,114,97,121,115,91,48,93,46,115,
105,122,101,32,61,32,49,10,
// '     uid = uuid.uuid4()\n
32,32,32,32,32,117,105,100,32,61,32,117,117,105,100,46,117,117,105,100,52,40,
41,10,
// '     functions.results[str(uid.bytes)] = results\n
32,32,32,32,32,102,117,110,99,116,105,111,110,115,46,114,101,115,117,108,116,
115,91,115,116,114,40,117,105,100,46,98,121,116,101,115,41,93,32,61,32,114,101,
115,117,108,116,115,10,
// "     outputd[0][0] = lib.strdup(ffi.from_buffer(memoryview(str(uid.bytes).encode('utf-8'))))\n
32,32,32,32,32,111,117,116,112,117,116,100,91,48,93,91,48,93,32,61,32,108,105,
98,46,115,116,114,100,117,112,40,102,102,105,46,102,114,111,109,95,98,117,102,
102,101,114,40,109,101,109,111,114,121,118,105,101,119,40,115,116,114,40,117,
105,100,46,98,121,116,101,115,41,46,101,110,99,111,100,101,40,39,117,116,102,
45,56,39,41,41,41,41,10,
// '     return 1\n
32,32,32,32,32,114,101,116,117,114,110,32,49,10,
// '\n
10,
// '@ffi.def_extern()\n
64,102,102,105,46,100,101,102,95,101,120,116,101,114,110,40,41,10,
// 'def expandwrapper(funcname, paramsnum, arrays, resultnum, resultarrays, genindices, lengenindices, insize, udfargs ,errormessage):\n
100,101,102,32,101,120,112,97,110,100,119,114,97,112,112,101,114,40,102,117,
110,99,110,97,109,101,44,32,112,97,114,97,109,115,110,117,109,44,32,97,114,114,
97,121,115,44,32,114,101,115,117,108,116,110,117,109,44,32,114,101,115,117,108,
116,97,114,114,97,121,115,44,32,103,101,110,105,110,100,105,99,101,115,44,32,
108,101,110,103,101,110,105,110,100,105,99,101,115,44,32,105,110,115,105,122,
101,44,32,117,100,102,97,114,103,115,32,44,101,114,114,111,114,109,101,115,115,
97,103,101,41,58,10,
// '  inputd = [None]*paramsnum\n
32,32,105,110,112,117,116,100,32,61,32,91,78,111,110,101,93,42,112,97,114,97,
109,115,110,117,109,10,
// '  outputd = [None]*resultnum\n
32,32,111,117,116,112,117,116,100,32,61,32,91,78,111,110,101,93,42,114,101,115,
117,108,116,110,117,109,10,
// '  funcname = ffi.string(funcname).decode()\n
32,32,102,117,110,99,110,97,109,101,32,61,32,102,102,105,46,115,116,114,105,
110,103,40,102,117,110,99,110,97,109,101,41,46,100,101,99,111,100,101,40,41,
10,
// "  funcname = funcname.split('.')\n
32,32,102,117,110,99,110,97,109,101,32,61,32,102,117,110,99,110,97,109,101,46,
115,112,108,105,116,40,39,46,39,41,10,
// '  if lengenindices == 2:\n
32,32,105,102,32,108,101,110,103,101,110,105,110,100,105,99,101,115,32,61,61,
32,50,58,10,
// '      for i in range(paramsnum):\n
32,32,32,32,32,32,102,111,114,32,105,32,105,110,32,114,97,110,103,101,40,112,
97,114,97,109,115,110,117,109,41,58,10,
// '          if arrays[i].type == 0:\n
32,32,32,32,32,32,32,32,32,32,105,102,32,97,114,114,97,121,115,91,105,93,46,
116,121,112,101,32,61,61,32,48,58,10,
// '              inputd[i] = ffi.cast("char **", arrays[i].array )\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,105,110,112,117,116,100,91,105,93,
32,61,32,102,102,105,46,99,97,115,116,40,34,99,104,97,114,32,42,42,34,44,32,
97,114,114,97,121,115,91,105,93,46,97,114,114,97,121,32,41,10,
// '          elif arrays[i].type == 1:\n
32,32,32,32,32,32,32,32,32,32,101,108,105,102,32,97,114,114,97,121,115,91,105,
93,46,116,121,112,101,32,61,61,32,49,58,10,
// '              inputd[i] = ffi.cast("int*", arrays[i].array )\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,105,110,112,117,116,100,91,105,93,
32,61,32,102,102,105,46,99,97,115,116,40,34,105,110,116,42,34,44,32,97,114,114,
97,121,115,91,105,93,46,97,114,114,97,121,32,41,10,
// '          elif arrays[i].type == 2:\n
32,32,32,32,32,32,32,32,32,32,101,108,105,102,32,97,114,114,97,121,115,91,105,
93,46,116,121,112,101,32,61,61,32,50,58,10,
// '              inputd[i] = ffi.cast("double *", arrays[i].array)\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,105,110,112,117,116,100,91,105,93,
32,61,32,102,102,105,46,99,97,115,116,40,34,100,111,117,98,108,101,32,42,34,
44,32,97,114,114,97,121,115,91,105,93,46,97,114,114,97,121,41,10,
// '          elif arrays[i].type == 4:\n
32,32,32,32,32,32,32,32,32,32,101,108,105,102,32,97,114,114,97,121,115,91,105,
93,46,116,121,112,101,32,61,61,32,52,58,10,
// '             inputd[i] = ffi.cast("int8_t *", arrays[i].array)\n
32,32,32,32,32,32,32,32,32,32,32,32,32,105,110,112,117,116,100,91,105,93,32,
61,32,102,102,105,46,99,97,115,116,40,34,105,110,116,56,95,116,32,42,34,44,32,
97,114,114,97,121,115,91,105,93,46,97,114,114,97,121,41,10,
// '          elif arrays[i].type == 5:\n
32,32,32,32,32,32,32,32,32,32,101,108,105,102,32,97,114,114,97,121,115,91,105,
93,46,116,121,112,101,32,61,61,32,53,58,10,
// '             inputd[i] = ffi.cast("int16_t *", arrays[i].array)\n
32,32,32,32,32,32,32,32,32,32,32,32,32,105,110,112,117,116,100,91,105,93,32,
61,32,102,102,105,46,99,97,115,116,40,34,105,110,116,49,54,95,116,32,42,34,44,
32,97,114,114,97,121,115,91,105,93,46,97,114,114,97,121,41,10,
// '      retlen = insize+1000000*2\n
32,32,32,32,32,32,114,101,116,108,101,110,32,61,32,105,110,115,105,122,101,43,
49,48,48,48,48,48,48,42,50,10,
// '      for i in range(resultnum):\n
32,32,32,32,32,32,102,111,114,32,105,32,105,110,32,114,97,110,103,101,40,114,
101,115,117,108,116,110,117,109,41,58,10,
// '           if resultarrays[i].type == 0:\n
32,32,32,32,32,32,32,32,32,32,32,105,102,32,114,101,115,117,108,116,97,114,114,
97,121,115,91,105,93,46,116,121,112,101,32,61,61,32,48,58,10,
// '               resultarrays[i].array = lib.malloc(retlen * ffi.sizeof("char*"))\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,114,101,115,117,108,116,97,114,
114,97,121,115,91,105,93,46,97,114,114,97,121,32,61,32,108,105,98,46,109,97,
108,108,111,99,40,114,101,116,108,101,110,32,42,32,102,102,105,46,115,105,122,
101,111,102,40,34,99,104,97,114,42,34,41,41,10,
// '               outputd[i] = ffi.cast("char **", resultarrays[i].array)\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,111,117,116,112,117,116,100,91,
105,93,32,61,32,102,102,105,46,99,97,115,116,40,34,99,104,97,114,32,42,42,34,
44,32,114,101,115,117,108,116,97,114,114,97,121,115,91,105,93,46,97,114,114,
97,121,41,10,
// '           elif resultarrays[i].type == 1:\n
32,32,32,32,32,32,32,32,32,32,32,101,108,105,102,32,114,101,115,117,108,116,
97,114,114,97,121,115,91,105,93,46,116,121,112,101,32,61,61,32,49,58,10,
// '               resultarrays[i].array = ffi.cast("int *", lib.malloc(retlen*ffi.sizeof("int")))\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,114,101,115,117,108,116,97,114,
114,97,121,115,91,105,93,46,97,114,114,97,121,32,61,32,102,102,105,46,99,97,
115,116,40,34,105,110,116,32,42,34,44,32,108,105,98,46,109,97,108,108,111,99,
40,114,101,116,108,101,110,42,102,102,105,46,115,105,122,101,111,102,40,34,105,
110,116,34,41,41,41,10,
// '               outputd[i] = ffi.cast("int *", resultarrays[i].array )\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,111,117,116,112,117,116,100,91,
105,93,32,61,32,102,102,105,46,99,97,115,116,40,34,105,110,116,32,42,34,44,32,
114,101,115,117,108,116,97,114,114,97,121,115,91,105,93,46,97,114,114,97,121,
32,41,10,
// '           elif resultarrays[i].type == 2:\n
32,32,32,32,32,32,32,32,32,32,32,101,108,105,102,32,114,101,115,117,108,116,
97,114,114,97,121,115,91,105,93,46,116,121,112,101,32,61,61,32,50,58,10,
// '               resultarrays[i].array = ffi.cast("double*", lib.malloc(retlen*ffi.sizeof("double")))\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,114,101,115,117,108,116,97,114,
114,97,121,115,91,105,93,46,97,114,114,97,121,32,61,32,102,102,105,46,99,97,
115,116,40,34,100,111,117,98,108,101,42,34,44,32,108,105,98,46,109,97,108,108,
111,99,40,114,101,116,108,101,110,42,102,102,105,46,115,105,122,101,111,102,
40,34,100,111,117,98,108,101,34,41,41,41,10,
// '               outputd[i] = ffi.cast("double *", resultarrays[i].array)\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,111,117,116,112,117,116,100,91,
105,93,32,61,32,102,102,105,46,99,97,115,116,40,34,100,111,117,98,108,101,32,
42,34,44,32,114,101,115,117,108,116,97,114,114,97,121,115,91,105,93,46,97,114,
114,97,121,41,10,
// '      cc = -1\n
32,32,32,32,32,32,99,99,32,61,32,45,49,10,
// '      try:\n
32,32,32,32,32,32,116,114,121,58,10,
// '          code_params = \', \'.join([\'inputd[\'+str(j)+\'][n]\' if arrays[j].type != 0 else \'ffi.string(ffi.cast("char **", arrays[\'+str(j)+\'].array )[n])\' for j in range(genindices[0], genindices[0]+udfargs[0])])\n
32,32,32,32,32,32,32,32,32,32,99,111,100,101,95,112,97,114,97,109,115,32,61,
32,39,44,32,39,46,106,111,105,110,40,91,39,105,110,112,117,116,100,91,39,43,
115,116,114,40,106,41,43,39,93,91,110,93,39,32,105,102,32,97,114,114,97,121,
115,91,106,93,46,116,121,112,101,32,33,61,32,48,32,101,108,115,101,32,39,102,
102,105,46,115,116,114,105,110,103,40,102,102,105,46,99,97,115,116,40,34,99,
104,97,114,32,42,42,34,44,32,97,114,114,97,121,115,91,39,43,115,116,114,40,106,
41,43,39,93,46,97,114,114,97,121,32,41,91,110,93,41,39,32,102,111,114,32,106,
32,105,110,32,114,97,110,103,101,40,103,101,110,105,110,100,105,99,101,115,91,
48,93,44,32,103,101,110,105,110,100,105,99,101,115,91,48,93,43,117,100,102,97,
114,103,115,91,48,93,41,93,41,10,
// '      except:\n
32,32,32,32,32,32,101,120,99,101,112,116,58,10,
// "          code_params = ''\n
32,32,32,32,32,32,32,32,32,32,99,111,100,101,95,112,97,114,97,109,115,32,61,
32,39,39,10,
// '      #code_params = \', \'.join([\'2\' if arrays[j].type != 0 else \'ffi.string(ffi.cast("char **", arrays[\'+str(j)+\'].array )[n])\' for j in range(genindices[0], genindices[0]+udfargs[0])])\n
32,32,32,32,32,32,35,99,111,100,101,95,112,97,114,97,109,115,32,61,32,39,44,
32,39,46,106,111,105,110,40,91,39,50,39,32,105,102,32,97,114,114,97,121,115,
91,106,93,46,116,121,112,101,32,33,61,32,48,32,101,108,115,101,32,39,102,102,
105,46,115,116,114,105,110,103,40,102,102,105,46,99,97,115,116,40,34,99,104,
97,114,32,42,42,34,44,32,97,114,114,97,121,115,91,39,43,115,116,114,40,106,41,
43,39,93,46,97,114,114,97,121,32,41,91,110,93,41,39,32,102,111,114,32,106,32,
105,110,32,114,97,110,103,101,40,103,101,110,105,110,100,105,99,101,115,91,48,
93,44,32,103,101,110,105,110,100,105,99,101,115,91,48,93,43,117,100,102,97,114,
103,115,91,48,93,41,93,41,10,
// "      code_loop_iterator = '\\n              '.join(['outputd['+str(i)+'][cc] = lib.strdup(ffi.from_buffer(memoryview(val'+str(kk)+')))' if resultarrays[i].type == 0 else 'outputd['+str(i)+'][cc] = val'+str(kk)+'' for kk, i in enumerate(range(genindices[0], genindices[0]+genindices[1]))])\n
32,32,32,32,32,32,99,111,100,101,95,108,111,111,112,95,105,116,101,114,97,116,
111,114,32,61,32,39,92,110,32,32,32,32,32,32,32,32,32,32,32,32,32,32,39,46,106,
111,105,110,40,91,39,111,117,116,112,117,116,100,91,39,43,115,116,114,40,105,
41,43,39,93,91,99,99,93,32,61,32,108,105,98,46,115,116,114,100,117,112,40,102,
102,105,46,102,114,111,109,95,98,117,102,102,101,114,40,109,101,109,111,114,
121,118,105,101,119,40,118,97,108,39,43,115,116,114,40,107,107,41,43,39,41,41,
41,39,32,105,102,32,114,101,115,117,108,116,97,114,114,97,121,115,91,105,93,
46,116,121,112,101,32,61,61,32,48,32,101,108,115,101,32,39,111,117,116,112,117,
116,100,91,39,43,115,116,114,40,105,41,43,39,93,91,99,99,93,32,61,32,118,97,
108,39,43,115,116,114,40,107,107,41,43,39,39,32,102,111,114,32,107,107,44,32,
105,32,105,110,32,101,110,117,109,101,114,97,116,101,40,114,97,110,103,101,40,
103,101,110,105,110,100,105,99,101,115,91,48,93,44,32,103,101,110,105,110,100,
105,99,101,115,91,48,93,43,103,101,110,105,110,100,105,99,101,115,91,49,93,41,
41,93,41,10,
// "      code_loop_rest_prev = '\\n              '.join(['outputd['+str(i)+'][cc] = inputd['+str(i)+'][n]'  for i in range(genindices[0])])\n
32,32,32,32,32,32,99,111,100,101,95,108,111,111,112,95,114,101,115,116,95,112,
114,101,118,32,61,32,39,92,110,32,32,32,32,32,32,32,32,32,32,32,32,32,32,39,
46,106,111,105,110,40,91,39,111,117,116,112,117,116,100,91,39,43,115,116,114,
40,105,41,43,39,93,91,99,99,93,32,61,32,105,110,112,117,116,100,91,39,43,115,
116,114,40,105,41,43,39,93,91,110,93,39,32,32,102,111,114,32,105,32,105,110,
32,114,97,110,103,101,40,103,101,110,105,110,100,105,99,101,115,91,48,93,41,
93,41,10,
// "      code_loop_rest_next = '\\n              '.join(['outputd['+str(i)+'][cc] = inputd['+str(i-genindices[1]+udfargs[0])+'][n]'  for i in range(genindices[0]+genindices[1], resultnum)])\n
32,32,32,32,32,32,99,111,100,101,95,108,111,111,112,95,114,101,115,116,95,110,
101,120,116,32,61,32,39,92,110,32,32,32,32,32,32,32,32,32,32,32,32,32,32,39,
46,106,111,105,110,40,91,39,111,117,116,112,117,116,100,91,39,43,115,116,114,
40,105,41,43,39,93,91,99,99,93,32,61,32,105,110,112,117,116,100,91,39,43,115,
116,114,40,105,45,103,101,110,105,110,100,105,99,101,115,91,49,93,43,117,100,
102,97,114,103,115,91,48,93,41,43,39,93,91,110,93,39,32,32,102,111,114,32,105,
32,105,110,32,114,97,110,103,101,40,103,101,110,105,110,100,105,99,101,115,91,
48,93,43,103,101,110,105,110,100,105,99,101,115,91,49,93,44,32,114,101,115,117,
108,116,110,117,109,41,93,41,10,
// '      strdups = {}\n
32,32,32,32,32,32,115,116,114,100,117,112,115,32,61,32,123,125,10,
// '      iterids = [kk for kk in range(genindices[0], genindices[0]+genindices[1])]\n
32,32,32,32,32,32,105,116,101,114,105,100,115,32,61,32,91,107,107,32,102,111,
114,32,107,107,32,105,110,32,114,97,110,103,101,40,103,101,110,105,110,100,105,
99,101,115,91,48,93,44,32,103,101,110,105,110,100,105,99,101,115,91,48,93,43,
103,101,110,105,110,100,105,99,101,115,91,49,93,41,93,10,
// '      for id in iterids:\n
32,32,32,32,32,32,102,111,114,32,105,100,32,105,110,32,105,116,101,114,105,100,
115,58,10,
// '          strdups[id] = True\n
32,32,32,32,32,32,32,32,32,32,115,116,114,100,117,112,115,91,105,100,93,32,61,
32,84,114,117,101,10,
// "      code_string = '''\n
32,32,32,32,32,32,99,111,100,101,95,115,116,114,105,110,103,32,61,32,39,39,39,
10,
// 'try:\n
116,114,121,58,10,
// "    from  '''+funcname[0]+''' import '''+funcname[1]+'''\n
32,32,32,32,102,114,111,109,32,32,39,39,39,43,102,117,110,99,110,97,109,101,
91,48,93,43,39,39,39,32,105,109,112,111,114,116,32,39,39,39,43,102,117,110,99,
110,97,109,101,91,49,93,43,39,39,39,10,
// '    if functions.DEBUG:\n
32,32,32,32,105,102,32,102,117,110,99,116,105,111,110,115,46,68,69,66,85,71,
58,10,
// "      mypath = get_module_path(funcname[0]+'.'+funcname[1])\n
32,32,32,32,32,32,109,121,112,97,116,104,32,61,32,103,101,116,95,109,111,100,
117,108,101,95,112,97,116,104,40,102,117,110,99,110,97,109,101,91,48,93,43,39,
46,39,43,102,117,110,99,110,97,109,101,91,49,93,41,10,
// '      if mypath not in checksums:\n
32,32,32,32,32,32,105,102,32,109,121,112,97,116,104,32,110,111,116,32,105,110,
32,99,104,101,99,107,115,117,109,115,58,10,
// '        checksums[mypath] = calculate_checksum(mypath)\n
32,32,32,32,32,32,32,32,99,104,101,99,107,115,117,109,115,91,109,121,112,97,
116,104,93,32,61,32,99,97,108,99,117,108,97,116,101,95,99,104,101,99,107,115,
117,109,40,109,121,112,97,116,104,41,10,
// '      elif mypath in checksums:\n
32,32,32,32,32,32,101,108,105,102,32,109,121,112,97,116,104,32,105,110,32,99,
104,101,99,107,115,117,109,115,58,10,
// '        csum = calculate_checksum(mypath)\n
32,32,32,32,32,32,32,32,99,115,117,109,32,61,32,99,97,108,99,117,108,97,116,
101,95,99,104,101,99,107,115,117,109,40,109,121,112,97,116,104,41,10,
// '        if checksums[mypath] != csum:\n
32,32,32,32,32,32,32,32,105,102,32,99,104,101,99,107,115,117,109,115,91,109,
121,112,97,116,104,93,32,33,61,32,99,115,117,109,58,10,
// "          importlib.reload('''+funcname[1]+''')\n
32,32,32,32,32,32,32,32,32,32,105,109,112,111,114,116,108,105,98,46,114,101,
108,111,97,100,40,39,39,39,43,102,117,110,99,110,97,109,101,91,49,93,43,39,39,
39,41,10,
// '          checksums[mypath] = csum\n
32,32,32,32,32,32,32,32,32,32,99,104,101,99,107,115,117,109,115,91,109,121,112,
97,116,104,93,32,61,32,99,115,117,109,10,
// 'except ImportError as import_err:\n
101,120,99,101,112,116,32,73,109,112,111,114,116,69,114,114,111,114,32,97,115,
32,105,109,112,111,114,116,95,101,114,114,58,10,
// "    importlib.reload('''+funcname[0]+''')\n
32,32,32,32,105,109,112,111,114,116,108,105,98,46,114,101,108,111,97,100,40,
39,39,39,43,102,117,110,99,110,97,109,101,91,48,93,43,39,39,39,41,10,
// "    from  '''+funcname[0]+''' import '''+funcname[1]+'''\n
32,32,32,32,102,114,111,109,32,32,39,39,39,43,102,117,110,99,110,97,109,101,
91,48,93,43,39,39,39,32,105,109,112,111,114,116,32,39,39,39,43,102,117,110,99,
110,97,109,101,91,49,93,43,39,39,39,10,
// 'try:\n
116,114,121,58,10,
// '  resultarrays[0].size = 0\n
32,32,114,101,115,117,108,116,97,114,114,97,121,115,91,48,93,46,115,105,122,
101,32,61,32,48,10,
// '  for n in range(insize):\n
32,32,102,111,114,32,110,32,105,110,32,114,97,110,103,101,40,105,110,115,105,
122,101,41,58,10,
// "           #for '''+','.join(['val'+str(x) for x in range(genindices[1])])+''' in iters[ffi.string(inputd['''+str(genindices[0])+'''][n])]:\n
32,32,32,32,32,32,32,32,32,32,32,35,102,111,114,32,39,39,39,43,39,44,39,46,106,
111,105,110,40,91,39,118,97,108,39,43,115,116,114,40,120,41,32,102,111,114,32,
120,32,105,110,32,114,97,110,103,101,40,103,101,110,105,110,100,105,99,101,115,
91,49,93,41,93,41,43,39,39,39,32,105,110,32,105,116,101,114,115,91,102,102,105,
46,115,116,114,105,110,103,40,105,110,112,117,116,100,91,39,39,39,43,115,116,
114,40,103,101,110,105,110,100,105,99,101,115,91,48,93,41,43,39,39,39,93,91,
110,93,41,93,58,10,
// "           for '''+','.join(['val'+str(x) for x in range(genindices[1])])+'''  in '''+funcname[1]+'''.'''+funcname[2]+'''('''+code_params+'''): #ffi.string(inputd['''+str(genindices[0])+'''][n])]:\n
32,32,32,32,32,32,32,32,32,32,32,102,111,114,32,39,39,39,43,39,44,39,46,106,
111,105,110,40,91,39,118,97,108,39,43,115,116,114,40,120,41,32,102,111,114,32,
120,32,105,110,32,114,97,110,103,101,40,103,101,110,105,110,100,105,99,101,115,
91,49,93,41,93,41,43,39,39,39,32,32,105,110,32,39,39,39,43,102,117,110,99,110,
97,109,101,91,49,93,43,39,39,39,46,39,39,39,43,102,117,110,99,110,97,109,101,
91,50,93,43,39,39,39,40,39,39,39,43,99,111,100,101,95,112,97,114,97,109,115,
43,39,39,39,41,58,32,35,102,102,105,46,115,116,114,105,110,103,40,105,110,112,
117,116,100,91,39,39,39,43,115,116,114,40,103,101,110,105,110,100,105,99,101,
115,91,48,93,41,43,39,39,39,93,91,110,93,41,93,58,10,
// '              cc += 1\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,99,99,32,43,61,32,49,10,
// '              resultarrays[0].size = cc+1\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,114,101,115,117,108,116,97,114,114,
97,121,115,91,48,93,46,115,105,122,101,32,61,32,99,99,43,49,10,
// '              if cc >= retlen:\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,105,102,32,99,99,32,62,61,32,114,101,
116,108,101,110,58,10,
// '                retlen = retlen*2\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,114,101,116,108,101,110,32,61,
32,114,101,116,108,101,110,42,50,10,
// "                #print('double realloc: ',cc)\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,35,112,114,105,110,116,40,39,
100,111,117,98,108,101,32,114,101,97,108,108,111,99,58,32,39,44,99,99,41,10,
// '                for i in range(resultnum):\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,102,111,114,32,105,32,105,110,
32,114,97,110,103,101,40,114,101,115,117,108,116,110,117,109,41,58,10,
// '                  if resultarrays[i].type == 0:\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,105,102,32,114,101,115,
117,108,116,97,114,114,97,121,115,91,105,93,46,116,121,112,101,32,61,61,32,48,
58,10,
// '                      resultarrays[i].array = lib.realloc(resultarrays[i].array, (retlen+1) * ffi.sizeof("char*"))\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,114,101,115,
117,108,116,97,114,114,97,121,115,91,105,93,46,97,114,114,97,121,32,61,32,108,
105,98,46,114,101,97,108,108,111,99,40,114,101,115,117,108,116,97,114,114,97,
121,115,91,105,93,46,97,114,114,97,121,44,32,40,114,101,116,108,101,110,43,49,
41,32,42,32,102,102,105,46,115,105,122,101,111,102,40,34,99,104,97,114,42,34,
41,41,10,
// '                      # Wrap the allocated memory with ffi.gc to ensure it is freed\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,35,32,87,114,
97,112,32,116,104,101,32,97,108,108,111,99,97,116,101,100,32,109,101,109,111,
114,121,32,119,105,116,104,32,102,102,105,46,103,99,32,116,111,32,101,110,115,
117,114,101,32,105,116,32,105,115,32,102,114,101,101,100,10,
// '                      #resultarrays[i].array = ffi.gc(ffi.cast("char**", resultarrays[i].array), free_strings, size=retlen)\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,35,114,101,
115,117,108,116,97,114,114,97,121,115,91,105,93,46,97,114,114,97,121,32,61,32,
102,102,105,46,103,99,40,102,102,105,46,99,97,115,116,40,34,99,104,97,114,42,
42,34,44,32,114,101,115,117,108,116,97,114,114,97,121,115,91,105,93,46,97,114,
114,97,121,41,44,32,102,114,101,101,95,115,116,114,105,110,103,115,44,32,115,
105,122,101,61,114,101,116,108,101,110,41,10,
// '                      outputd[i] = ffi.cast("char **", resultarrays[i].array)\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,111,117,116,
112,117,116,100,91,105,93,32,61,32,102,102,105,46,99,97,115,116,40,34,99,104,
97,114,32,42,42,34,44,32,114,101,115,117,108,116,97,114,114,97,121,115,91,105,
93,46,97,114,114,97,121,41,10,
// '                  elif resultarrays[i].type == 1:\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,101,108,105,102,32,114,
101,115,117,108,116,97,114,114,97,121,115,91,105,93,46,116,121,112,101,32,61,
61,32,49,58,10,
// '                      resultarrays[i].array = ffi.cast("int*", lib.realloc(resultarrays[i].array, retlen*ffi.sizeof("int")))\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,114,101,115,
117,108,116,97,114,114,97,121,115,91,105,93,46,97,114,114,97,121,32,61,32,102,
102,105,46,99,97,115,116,40,34,105,110,116,42,34,44,32,108,105,98,46,114,101,
97,108,108,111,99,40,114,101,115,117,108,116,97,114,114,97,121,115,91,105,93,
46,97,114,114,97,121,44,32,114,101,116,108,101,110,42,102,102,105,46,115,105,
122,101,111,102,40,34,105,110,116,34,41,41,41,10,
// '                      outputd[i] = ffi.cast("int*", resultarrays[i].array )\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,111,117,116,
112,117,116,100,91,105,93,32,61,32,102,102,105,46,99,97,115,116,40,34,105,110,
116,42,34,44,32,114,101,115,117,108,116,97,114,114,97,121,115,91,105,93,46,97,
114,114,97,121,32,41,10,
// '                  elif resultarrays[i].type == 2:\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,101,108,105,102,32,114,
101,115,117,108,116,97,114,114,97,121,115,91,105,93,46,116,121,112,101,32,61,
61,32,50,58,10,
// '                      resultarrays[i].array = ffi.cast("double*", lib.realloc(resultarrays[i].array, retlen*ffi.sizeof("double")))\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,114,101,115,
117,108,116,97,114,114,97,121,115,91,105,93,46,97,114,114,97,121,32,61,32,102,
102,105,46,99,97,115,116,40,34,100,111,117,98,108,101,42,34,44,32,108,105,98,
46,114,101,97,108,108,111,99,40,114,101,115,117,108,116,97,114,114,97,121,115,
91,105,93,46,97,114,114,97,121,44,32,114,101,116,108,101,110,42,102,102,105,
46,115,105,122,101,111,102,40,34,100,111,117,98,108,101,34,41,41,41,10,
// '                      outputd[i] = ffi.cast("double*", resultarrays[i].array )\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,111,117,116,
112,117,116,100,91,105,93,32,61,32,102,102,105,46,99,97,115,116,40,34,100,111,
117,98,108,101,42,34,44,32,114,101,115,117,108,116,97,114,114,97,121,115,91,
105,93,46,97,114,114,97,121,32,41,10,
// "              '''+code_loop_iterator+'''\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,39,39,39,43,99,111,100,101,95,108,
111,111,112,95,105,116,101,114,97,116,111,114,43,39,39,39,10,
// "              '''+code_loop_rest_prev+'''\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,39,39,39,43,99,111,100,101,95,108,
111,111,112,95,114,101,115,116,95,112,114,101,118,43,39,39,39,10,
// "              '''+code_loop_rest_next+'''\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,39,39,39,43,99,111,100,101,95,108,
111,111,112,95,114,101,115,116,95,110,101,120,116,43,39,39,39,10,
// "              #del iters[ffi.string(inputd['''+str(genindices[0])+'''][n])]\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,35,100,101,108,32,105,116,101,114,
115,91,102,102,105,46,115,116,114,105,110,103,40,105,110,112,117,116,100,91,
39,39,39,43,115,116,114,40,103,101,110,105,110,100,105,99,101,115,91,48,93,41,
43,39,39,39,93,91,110,93,41,93,10,
// '              #outputd[0][cc] = lib.strdup(ffi.from_buffer(memoryview(prev)))\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,35,111,117,116,112,117,116,100,91,
48,93,91,99,99,93,32,61,32,108,105,98,46,115,116,114,100,117,112,40,102,102,
105,46,102,114,111,109,95,98,117,102,102,101,114,40,109,101,109,111,114,121,
118,105,101,119,40,112,114,101,118,41,41,41,10,
// '              #outputd[1][cc] = lib.strdup(ffi.from_buffer(memoryview(middle.encode())))\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,35,111,117,116,112,117,116,100,91,
49,93,91,99,99,93,32,61,32,108,105,98,46,115,116,114,100,117,112,40,102,102,
105,46,102,114,111,109,95,98,117,102,102,101,114,40,109,101,109,111,114,121,
118,105,101,119,40,109,105,100,100,108,101,46,101,110,99,111,100,101,40,41,41,
41,41,10,
// '              #outputd[2][cc] = lib.strdup(ffi.from_buffer(memoryview(next.encode())))\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,35,111,117,116,112,117,116,100,91,
50,93,91,99,99,93,32,61,32,108,105,98,46,115,116,114,100,117,112,40,102,102,
105,46,102,114,111,109,95,98,117,102,102,101,114,40,109,101,109,111,114,121,
118,105,101,119,40,110,101,120,116,46,101,110,99,111,100,101,40,41,41,41,41,
10,
// '              ##outputd[0][cc] = inputd[0][n]\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,35,35,111,117,116,112,117,116,100,
91,48,93,91,99,99,93,32,61,32,105,110,112,117,116,100,91,48,93,91,110,93,10,
// '              ##outputd[1][cc] = inputd[1][n]\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,35,35,111,117,116,112,117,116,100,
91,49,93,91,99,99,93,32,61,32,105,110,112,117,116,100,91,49,93,91,110,93,10,
// '  for i in range(resultnum):\n
32,32,102,111,114,32,105,32,105,110,32,114,97,110,103,101,40,114,101,115,117,
108,116,110,117,109,41,58,10,
// "                  #print('all: ', i)\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,35,112,114,105,110,116,
40,39,97,108,108,58,32,39,44,32,105,41,10,
// '                  if resultarrays[i].type == 0 and i in strdups:\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,105,102,32,114,101,115,
117,108,116,97,114,114,97,121,115,91,105,93,46,116,121,112,101,32,61,61,32,48,
32,97,110,100,32,105,32,105,110,32,115,116,114,100,117,112,115,58,10,
// "                      #print('dups: ', i)\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,35,112,114,
105,110,116,40,39,100,117,112,115,58,32,39,44,32,105,41,10,
// '                      #resultarrays[i].array = ffi.gc(ffi.cast("char**", resultarrays[i].array), lib.custom_free, size=resultarrays[0].size)\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,35,114,101,
115,117,108,116,97,114,114,97,121,115,91,105,93,46,97,114,114,97,121,32,61,32,
102,102,105,46,103,99,40,102,102,105,46,99,97,115,116,40,34,99,104,97,114,42,
42,34,44,32,114,101,115,117,108,116,97,114,114,97,121,115,91,105,93,46,97,114,
114,97,121,41,44,32,108,105,98,46,99,117,115,116,111,109,95,102,114,101,101,
44,32,115,105,122,101,61,114,101,115,117,108,116,97,114,114,97,121,115,91,48,
93,46,115,105,122,101,41,10,
// '                      try:\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,116,114,121,
58,10,
// '                          __pypy__.add_memory_pressure(retlen*2*ffi.sizeof("char*"))\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,
95,95,112,121,112,121,95,95,46,97,100,100,95,109,101,109,111,114,121,95,112,
114,101,115,115,117,114,101,40,114,101,116,108,101,110,42,50,42,102,102,105,
46,115,105,122,101,111,102,40,34,99,104,97,114,42,34,41,41,10,
// '                          resultarrays[i].array = ffi.gc(ffi.cast("char**", resultarrays[i].array), lib.custom_free, size=resultarrays[0].size)\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,
114,101,115,117,108,116,97,114,114,97,121,115,91,105,93,46,97,114,114,97,121,
32,61,32,102,102,105,46,103,99,40,102,102,105,46,99,97,115,116,40,34,99,104,
97,114,42,42,34,44,32,114,101,115,117,108,116,97,114,114,97,121,115,91,105,93,
46,97,114,114,97,121,41,44,32,108,105,98,46,99,117,115,116,111,109,95,102,114,
101,101,44,32,115,105,122,101,61,114,101,115,117,108,116,97,114,114,97,121,115,
91,48,93,46,115,105,122,101,41,10,
// '                      except:\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,101,120,99,
101,112,116,58,10,
// '                          pass\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,
112,97,115,115,10,
// '                      outputd[i] = ffi.cast("char **", resultarrays[i].array)\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,111,117,116,
112,117,116,100,91,105,93,32,61,32,102,102,105,46,99,97,115,116,40,34,99,104,
97,114,32,42,42,34,44,32,114,101,115,117,108,116,97,114,114,97,121,115,91,105,
93,46,97,114,114,97,121,41,10,
// '                      outputd[i][resultarrays[0].size] = ffi.NULL\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,111,117,116,
112,117,116,100,91,105,93,91,114,101,115,117,108,116,97,114,114,97,121,115,91,
48,93,46,115,105,122,101,93,32,61,32,102,102,105,46,78,85,76,76,10,
// 'except Exception as e:\n
101,120,99,101,112,116,32,69,120,99,101,112,116,105,111,110,32,97,115,32,101,
58,10,
// "      errormessage[0] = lib.strdup(ffi.from_buffer(memoryview(b'UDFError '+ funcname[0].encode()+b'.'+funcname[1].encode()+b'.'+funcname[2].upper().encode() + b': ' + traceback.format_exc().encode())))\n
32,32,32,32,32,32,101,114,114,111,114,109,101,115,115,97,103,101,91,48,93,32,
61,32,108,105,98,46,115,116,114,100,117,112,40,102,102,105,46,102,114,111,109,
95,98,117,102,102,101,114,40,109,101,109,111,114,121,118,105,101,119,40,98,39,
85,68,70,69,114,114,111,114,32,39,43,32,102,117,110,99,110,97,109,101,91,48,
93,46,101,110,99,111,100,101,40,41,43,98,39,46,39,43,102,117,110,99,110,97,109,
101,91,49,93,46,101,110,99,111,100,101,40,41,43,98,39,46,39,43,102,117,110,99,
110,97,109,101,91,50,93,46,117,112,112,101,114,40,41,46,101,110,99,111,100,101,
40,41,32,43,32,98,39,58,32,39,32,43,32,116,114,97,99,101,98,97,99,107,46,102,
111,114,109,97,116,95,101,120,99,40,41,46,101,110,99,111,100,101,40,41,41,41,
41,10,
// "      '''\n
32,32,32,32,32,32,39,39,39,10,
// '      print(code_string)\n
32,32,32,32,32,32,112,114,105,110,116,40,99,111,100,101,95,115,116,114,105,110,
103,41,10,
// '      exec(code_string)\n
32,32,32,32,32,32,101,120,101,99,40,99,111,100,101,95,115,116,114,105,110,103,
41,10,
// '      return 1\n
32,32,32,32,32,32,114,101,116,117,114,110,32,49,10,
// '  if lengenindices > 2:\n
32,32,105,102,32,108,101,110,103,101,110,105,110,100,105,99,101,115,32,62,32,
50,58,10,
// "      errormessage[0] = lib.strdup(ffi.from_buffer(memoryview(b'UDFError '+ funcname[0].encode()+b'.'+funcname[1].encode()+b'.'+funcname[2].upper().encode() + b': Multiple multiset UDFs in the same projection is not supported yet')))\n
32,32,32,32,32,32,101,114,114,111,114,109,101,115,115,97,103,101,91,48,93,32,
61,32,108,105,98,46,115,116,114,100,117,112,40,102,102,105,46,102,114,111,109,
95,98,117,102,102,101,114,40,109,101,109,111,114,121,118,105,101,119,40,98,39,
85,68,70,69,114,114,111,114,32,39,43,32,102,117,110,99,110,97,109,101,91,48,
93,46,101,110,99,111,100,101,40,41,43,98,39,46,39,43,102,117,110,99,110,97,109,
101,91,49,93,46,101,110,99,111,100,101,40,41,43,98,39,46,39,43,102,117,110,99,
110,97,109,101,91,50,93,46,117,112,112,101,114,40,41,46,101,110,99,111,100,101,
40,41,32,43,32,98,39,58,32,77,117,108,116,105,112,108,101,32,109,117,108,116,
105,115,101,116,32,85,68,70,115,32,105,110,32,116,104,101,32,115,97,109,101,
32,112,114,111,106,101,99,116,105,111,110,32,105,115,32,110,111,116,32,115,117,
112,112,111,114,116,101,100,32,121,101,116,39,41,41,41,10,
// '      pass     ## TODO cross join - 2 OR MORE MULTISET UDFs  NOT SUPPORTED YET in a single projection\n
32,32,32,32,32,32,112,97,115,115,32,32,32,32,32,35,35,32,84,79,68,79,32,99,114,
111,115,115,32,106,111,105,110,32,45,32,50,32,79,82,32,77,79,82,69,32,77,85,
76,84,73,83,69,84,32,85,68,70,115,32,32,78,79,84,32,83,85,80,80,79,82,84,69,
68,32,89,69,84,32,105,110,32,97,32,115,105,110,103,108,101,32,112,114,111,106,
101,99,116,105,111,110,10,
// '  return 1\n
32,32,114,101,116,117,114,110,32,49,10,
// '\n
10,
// '\n
10,
// '\n
10,
// '@ffi.def_extern()\n
64,102,102,105,46,100,101,102,95,101,120,116,101,114,110,40,41,10,
// 'def expandaggrwrapper(funcname, paramsnum, arrays, resultnum, resultarrays, genindices, lengenindices, insize, udfargs, errormessage):\n
100,101,102,32,101,120,112,97,110,100,97,103,103,114,119,114,97,112,112,101,
114,40,102,117,110,99,110,97,109,101,44,32,112,97,114,97,109,115,110,117,109,
44,32,97,114,114,97,121,115,44,32,114,101,115,117,108,116,110,117,109,44,32,
114,101,115,117,108,116,97,114,114,97,121,115,44,32,103,101,110,105,110,100,
105,99,101,115,44,32,108,101,110,103,101,110,105,110,100,105,99,101,115,44,32,
105,110,115,105,122,101,44,32,117,100,102,97,114,103,115,44,32,101,114,114,111,
114,109,101,115,115,97,103,101,41,58,10,
// '  inputd = [None]*paramsnum\n
32,32,105,110,112,117,116,100,32,61,32,91,78,111,110,101,93,42,112,97,114,97,
109,115,110,117,109,10,
// '  outputd = [None]*resultnum\n
32,32,111,117,116,112,117,116,100,32,61,32,91,78,111,110,101,93,42,114,101,115,
117,108,116,110,117,109,10,
// '  funcname = ffi.string(funcname).decode()\n
32,32,102,117,110,99,110,97,109,101,32,61,32,102,102,105,46,115,116,114,105,
110,103,40,102,117,110,99,110,97,109,101,41,46,100,101,99,111,100,101,40,41,
10,
// "  funcname = funcname.split('.')\n
32,32,102,117,110,99,110,97,109,101,32,61,32,102,117,110,99,110,97,109,101,46,
115,112,108,105,116,40,39,46,39,41,10,
// "  #print('lala: ', arrays[0].array[0] , arrays[0].array[1])\n
32,32,35,112,114,105,110,116,40,39,108,97,108,97,58,32,39,44,32,97,114,114,97,
121,115,91,48,93,46,97,114,114,97,121,91,48,93,32,44,32,97,114,114,97,121,115,
91,48,93,46,97,114,114,97,121,91,49,93,41,10,
// '  if lengenindices == 2:\n
32,32,105,102,32,108,101,110,103,101,110,105,110,100,105,99,101,115,32,61,61,
32,50,58,10,
// '      for i in range(paramsnum):\n
32,32,32,32,32,32,102,111,114,32,105,32,105,110,32,114,97,110,103,101,40,112,
97,114,97,109,115,110,117,109,41,58,10,
// '          if arrays[i].type == 0:\n
32,32,32,32,32,32,32,32,32,32,105,102,32,97,114,114,97,121,115,91,105,93,46,
116,121,112,101,32,61,61,32,48,58,10,
// '              inputd[i] = ffi.cast("char **", arrays[i].array )\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,105,110,112,117,116,100,91,105,93,
32,61,32,102,102,105,46,99,97,115,116,40,34,99,104,97,114,32,42,42,34,44,32,
97,114,114,97,121,115,91,105,93,46,97,114,114,97,121,32,41,10,
// '          elif arrays[i].type == 1:\n
32,32,32,32,32,32,32,32,32,32,101,108,105,102,32,97,114,114,97,121,115,91,105,
93,46,116,121,112,101,32,61,61,32,49,58,10,
// '              inputd[i] = ffi.cast("int*", arrays[i].array )\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,105,110,112,117,116,100,91,105,93,
32,61,32,102,102,105,46,99,97,115,116,40,34,105,110,116,42,34,44,32,97,114,114,
97,121,115,91,105,93,46,97,114,114,97,121,32,41,10,
// '          elif arrays[i].type == 2:\n
32,32,32,32,32,32,32,32,32,32,101,108,105,102,32,97,114,114,97,121,115,91,105,
93,46,116,121,112,101,32,61,61,32,50,58,10,
// '              inputd[i] = ffi.cast("double *", arrays[i].array)\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,105,110,112,117,116,100,91,105,93,
32,61,32,102,102,105,46,99,97,115,116,40,34,100,111,117,98,108,101,32,42,34,
44,32,97,114,114,97,121,115,91,105,93,46,97,114,114,97,121,41,10,
// '          elif arrays[i].type == 4:\n
32,32,32,32,32,32,32,32,32,32,101,108,105,102,32,97,114,114,97,121,115,91,105,
93,46,116,121,112,101,32,61,61,32,52,58,10,
// '             inputd[i] = ffi.cast("int8_t *", arrays[i].array)\n
32,32,32,32,32,32,32,32,32,32,32,32,32,105,110,112,117,116,100,91,105,93,32,
61,32,102,102,105,46,99,97,115,116,40,34,105,110,116,56,95,116,32,42,34,44,32,
97,114,114,97,121,115,91,105,93,46,97,114,114,97,121,41,10,
// '          elif arrays[i].type == 5:\n
32,32,32,32,32,32,32,32,32,32,101,108,105,102,32,97,114,114,97,121,115,91,105,
93,46,116,121,112,101,32,61,61,32,53,58,10,
// '             inputd[i] = ffi.cast("int16_t *", arrays[i].array)\n
32,32,32,32,32,32,32,32,32,32,32,32,32,105,110,112,117,116,100,91,105,93,32,
61,32,102,102,105,46,99,97,115,116,40,34,105,110,116,49,54,95,116,32,42,34,44,
32,97,114,114,97,121,115,91,105,93,46,97,114,114,97,121,41,10,
// '      retlen = insize+1000000*2\n
32,32,32,32,32,32,114,101,116,108,101,110,32,61,32,105,110,115,105,122,101,43,
49,48,48,48,48,48,48,42,50,10,
// '      for i in range(resultnum):\n
32,32,32,32,32,32,102,111,114,32,105,32,105,110,32,114,97,110,103,101,40,114,
101,115,117,108,116,110,117,109,41,58,10,
// '           if resultarrays[i].type == 0:\n
32,32,32,32,32,32,32,32,32,32,32,105,102,32,114,101,115,117,108,116,97,114,114,
97,121,115,91,105,93,46,116,121,112,101,32,61,61,32,48,58,10,
// '               resultarrays[i].array = ffi.cast("char**", lib.malloc(retlen*ffi.sizeof("double")))\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,114,101,115,117,108,116,97,114,
114,97,121,115,91,105,93,46,97,114,114,97,121,32,61,32,102,102,105,46,99,97,
115,116,40,34,99,104,97,114,42,42,34,44,32,108,105,98,46,109,97,108,108,111,
99,40,114,101,116,108,101,110,42,102,102,105,46,115,105,122,101,111,102,40,34,
100,111,117,98,108,101,34,41,41,41,10,
// '               outputd[i] = ffi.cast("char **", resultarrays[i].array )\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,111,117,116,112,117,116,100,91,
105,93,32,61,32,102,102,105,46,99,97,115,116,40,34,99,104,97,114,32,42,42,34,
44,32,114,101,115,117,108,116,97,114,114,97,121,115,91,105,93,46,97,114,114,
97,121,32,41,10,
// '           elif resultarrays[i].type == 1:\n
32,32,32,32,32,32,32,32,32,32,32,101,108,105,102,32,114,101,115,117,108,116,
97,114,114,97,121,115,91,105,93,46,116,121,112,101,32,61,61,32,49,58,10,
// '               resultarrays[i].array = ffi.cast("int *", lib.malloc(retlen*ffi.sizeof("double")))\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,114,101,115,117,108,116,97,114,
114,97,121,115,91,105,93,46,97,114,114,97,121,32,61,32,102,102,105,46,99,97,
115,116,40,34,105,110,116,32,42,34,44,32,108,105,98,46,109,97,108,108,111,99,
40,114,101,116,108,101,110,42,102,102,105,46,115,105,122,101,111,102,40,34,100,
111,117,98,108,101,34,41,41,41,10,
// '               outputd[i] = ffi.cast("int *", resultarrays[i].array )\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,111,117,116,112,117,116,100,91,
105,93,32,61,32,102,102,105,46,99,97,115,116,40,34,105,110,116,32,42,34,44,32,
114,101,115,117,108,116,97,114,114,97,121,115,91,105,93,46,97,114,114,97,121,
32,41,10,
// '           elif resultarrays[i].type == 2:\n
32,32,32,32,32,32,32,32,32,32,32,101,108,105,102,32,114,101,115,117,108,116,
97,114,114,97,121,115,91,105,93,46,116,121,112,101,32,61,61,32,50,58,10,
// '               resultarrays[i].array = ffi.cast("float*", lib.malloc(retlen*ffi.sizeof("double")))\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,114,101,115,117,108,116,97,114,
114,97,121,115,91,105,93,46,97,114,114,97,121,32,61,32,102,102,105,46,99,97,
115,116,40,34,102,108,111,97,116,42,34,44,32,108,105,98,46,109,97,108,108,111,
99,40,114,101,116,108,101,110,42,102,102,105,46,115,105,122,101,111,102,40,34,
100,111,117,98,108,101,34,41,41,41,10,
// '               outputd[i] = ffi.cast("double *", resultarrays[i].array)\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,111,117,116,112,117,116,100,91,
105,93,32,61,32,102,102,105,46,99,97,115,116,40,34,100,111,117,98,108,101,32,
42,34,44,32,114,101,115,117,108,116,97,114,114,97,121,115,91,105,93,46,97,114,
114,97,121,41,10,
// '      cc = -1\n
32,32,32,32,32,32,99,99,32,61,32,45,49,10,
// '      try:\n
32,32,32,32,32,32,116,114,121,58,10,
// '          code_params = \', \'.join([\'inputd[\'+str(j)+\'][n]\' if arrays[j].type != 0 else \'ffi.string(ffi.cast("char **", arrays[\'+str(j)+\'].array )[n])\' for j in range(genindices[0], genindices[0]+udfargs[0])])\n
32,32,32,32,32,32,32,32,32,32,99,111,100,101,95,112,97,114,97,109,115,32,61,
32,39,44,32,39,46,106,111,105,110,40,91,39,105,110,112,117,116,100,91,39,43,
115,116,114,40,106,41,43,39,93,91,110,93,39,32,105,102,32,97,114,114,97,121,
115,91,106,93,46,116,121,112,101,32,33,61,32,48,32,101,108,115,101,32,39,102,
102,105,46,115,116,114,105,110,103,40,102,102,105,46,99,97,115,116,40,34,99,
104,97,114,32,42,42,34,44,32,97,114,114,97,121,115,91,39,43,115,116,114,40,106,
41,43,39,93,46,97,114,114,97,121,32,41,91,110,93,41,39,32,102,111,114,32,106,
32,105,110,32,114,97,110,103,101,40,103,101,110,105,110,100,105,99,101,115,91,
48,93,44,32,103,101,110,105,110,100,105,99,101,115,91,48,93,43,117,100,102,97,
114,103,115,91,48,93,41,93,41,10,
// '      except:\n
32,32,32,32,32,32,101,120,99,101,112,116,58,10,
// "          code_params = ''\n
32,32,32,32,32,32,32,32,32,32,99,111,100,101,95,112,97,114,97,109,115,32,61,
32,39,39,10,
// '\n
10,
// '      #code_params = \', \'.join([\'2\' if arrays[j].type != 0 else \'ffi.string(ffi.cast("char **", arrays[\'+str(j)+\'].array )[n])\' for j in range(genindices[0], genindices[0]+udfargs[0])])\n
32,32,32,32,32,32,35,99,111,100,101,95,112,97,114,97,109,115,32,61,32,39,44,
32,39,46,106,111,105,110,40,91,39,50,39,32,105,102,32,97,114,114,97,121,115,
91,106,93,46,116,121,112,101,32,33,61,32,48,32,101,108,115,101,32,39,102,102,
105,46,115,116,114,105,110,103,40,102,102,105,46,99,97,115,116,40,34,99,104,
97,114,32,42,42,34,44,32,97,114,114,97,121,115,91,39,43,115,116,114,40,106,41,
43,39,93,46,97,114,114,97,121,32,41,91,110,93,41,39,32,102,111,114,32,106,32,
105,110,32,114,97,110,103,101,40,103,101,110,105,110,100,105,99,101,115,91,48,
93,44,32,103,101,110,105,110,100,105,99,101,115,91,48,93,43,117,100,102,97,114,
103,115,91,48,93,41,93,41,10,
// "      code_loop_iterator = '\\n              '.join(['outputd['+str(i)+'][cc] = lib.strdup(ffi.from_buffer(memoryview(val'+str(kk)+')))' if resultarrays[i].type == 0 else 'outputd['+str(i)+'][cc] = val'+str(kk)+'' for kk, i in enumerate(range(genindices[0], genindices[0]+genindices[1]))])\n
32,32,32,32,32,32,99,111,100,101,95,108,111,111,112,95,105,116,101,114,97,116,
111,114,32,61,32,39,92,110,32,32,32,32,32,32,32,32,32,32,32,32,32,32,39,46,106,
111,105,110,40,91,39,111,117,116,112,117,116,100,91,39,43,115,116,114,40,105,
41,43,39,93,91,99,99,93,32,61,32,108,105,98,46,115,116,114,100,117,112,40,102,
102,105,46,102,114,111,109,95,98,117,102,102,101,114,40,109,101,109,111,114,
121,118,105,101,119,40,118,97,108,39,43,115,116,114,40,107,107,41,43,39,41,41,
41,39,32,105,102,32,114,101,115,117,108,116,97,114,114,97,121,115,91,105,93,
46,116,121,112,101,32,61,61,32,48,32,101,108,115,101,32,39,111,117,116,112,117,
116,100,91,39,43,115,116,114,40,105,41,43,39,93,91,99,99,93,32,61,32,118,97,
108,39,43,115,116,114,40,107,107,41,43,39,39,32,102,111,114,32,107,107,44,32,
105,32,105,110,32,101,110,117,109,101,114,97,116,101,40,114,97,110,103,101,40,
103,101,110,105,110,100,105,99,101,115,91,48,93,44,32,103,101,110,105,110,100,
105,99,101,115,91,48,93,43,103,101,110,105,110,100,105,99,101,115,91,49,93,41,
41,93,41,10,
// "      code_loop_rest_prev = '\\n              '.join(['outputd['+str(i)+'][cc] = inputd['+str(i)+'][n]'  for i in range(genindices[0])])\n
32,32,32,32,32,32,99,111,100,101,95,108,111,111,112,95,114,101,115,116,95,112,
114,101,118,32,61,32,39,92,110,32,32,32,32,32,32,32,32,32,32,32,32,32,32,39,
46,106,111,105,110,40,91,39,111,117,116,112,117,116,100,91,39,43,115,116,114,
40,105,41,43,39,93,91,99,99,93,32,61,32,105,110,112,117,116,100,91,39,43,115,
116,114,40,105,41,43,39,93,91,110,93,39,32,32,102,111,114,32,105,32,105,110,
32,114,97,110,103,101,40,103,101,110,105,110,100,105,99,101,115,91,48,93,41,
93,41,10,
// "      code_loop_rest_next = '\\n              '.join(['outputd['+str(i)+'][cc] = inputd['+str(i-genindices[1]+udfargs[0])+'][n]'  for i in range(genindices[0]+genindices[1], resultnum)])\n
32,32,32,32,32,32,99,111,100,101,95,108,111,111,112,95,114,101,115,116,95,110,
101,120,116,32,61,32,39,92,110,32,32,32,32,32,32,32,32,32,32,32,32,32,32,39,
46,106,111,105,110,40,91,39,111,117,116,112,117,116,100,91,39,43,115,116,114,
40,105,41,43,39,93,91,99,99,93,32,61,32,105,110,112,117,116,100,91,39,43,115,
116,114,40,105,45,103,101,110,105,110,100,105,99,101,115,91,49,93,43,117,100,
102,97,114,103,115,91,48,93,41,43,39,93,91,110,93,39,32,32,102,111,114,32,105,
32,105,110,32,114,97,110,103,101,40,103,101,110,105,110,100,105,99,101,115,91,
48,93,43,103,101,110,105,110,100,105,99,101,115,91,49,93,44,32,114,101,115,117,
108,116,110,117,109,41,93,41,10,
// "      code_string = '''\n
32,32,32,32,32,32,99,111,100,101,95,115,116,114,105,110,103,32,61,32,39,39,39,
10,
// 'try:\n
116,114,121,58,10,
// "    from  '''+funcname[0]+''' import '''+funcname[1]+'''\n
32,32,32,32,102,114,111,109,32,32,39,39,39,43,102,117,110,99,110,97,109,101,
91,48,93,43,39,39,39,32,105,109,112,111,114,116,32,39,39,39,43,102,117,110,99,
110,97,109,101,91,49,93,43,39,39,39,10,
// '    if functions.DEBUG:\n
32,32,32,32,105,102,32,102,117,110,99,116,105,111,110,115,46,68,69,66,85,71,
58,10,
// "      mypath = get_module_path(funcname[0]+'.'+funcname[1])\n
32,32,32,32,32,32,109,121,112,97,116,104,32,61,32,103,101,116,95,109,111,100,
117,108,101,95,112,97,116,104,40,102,117,110,99,110,97,109,101,91,48,93,43,39,
46,39,43,102,117,110,99,110,97,109,101,91,49,93,41,10,
// '      #print(mypath)\n
32,32,32,32,32,32,35,112,114,105,110,116,40,109,121,112,97,116,104,41,10,
// '      if mypath not in checksums:\n
32,32,32,32,32,32,105,102,32,109,121,112,97,116,104,32,110,111,116,32,105,110,
32,99,104,101,99,107,115,117,109,115,58,10,
// '        checksums[mypath] = calculate_checksum(mypath)\n
32,32,32,32,32,32,32,32,99,104,101,99,107,115,117,109,115,91,109,121,112,97,
116,104,93,32,61,32,99,97,108,99,117,108,97,116,101,95,99,104,101,99,107,115,
117,109,40,109,121,112,97,116,104,41,10,
// '      elif mypath in checksums:\n
32,32,32,32,32,32,101,108,105,102,32,109,121,112,97,116,104,32,105,110,32,99,
104,101,99,107,115,117,109,115,58,10,
// '        csum = calculate_checksum(mypath)\n
32,32,32,32,32,32,32,32,99,115,117,109,32,61,32,99,97,108,99,117,108,97,116,
101,95,99,104,101,99,107,115,117,109,40,109,121,112,97,116,104,41,10,
// '        if checksums[mypath] != csum:\n
32,32,32,32,32,32,32,32,105,102,32,99,104,101,99,107,115,117,109,115,91,109,
121,112,97,116,104,93,32,33,61,32,99,115,117,109,58,10,
// "          importlib.reload('''+funcname[1]+''')\n
32,32,32,32,32,32,32,32,32,32,105,109,112,111,114,116,108,105,98,46,114,101,
108,111,97,100,40,39,39,39,43,102,117,110,99,110,97,109,101,91,49,93,43,39,39,
39,41,10,
// '          checksums[mypath] = csum\n
32,32,32,32,32,32,32,32,32,32,99,104,101,99,107,115,117,109,115,91,109,121,112,
97,116,104,93,32,61,32,99,115,117,109,10,
// 'except ImportError as import_err:\n
101,120,99,101,112,116,32,73,109,112,111,114,116,69,114,114,111,114,32,97,115,
32,105,109,112,111,114,116,95,101,114,114,58,10,
// "    importlib.reload('''+funcname[0]+''')\n
32,32,32,32,105,109,112,111,114,116,108,105,98,46,114,101,108,111,97,100,40,
39,39,39,43,102,117,110,99,110,97,109,101,91,48,93,43,39,39,39,41,10,
// "    from  '''+funcname[0]+''' import '''+funcname[1]+'''\n
32,32,32,32,102,114,111,109,32,32,39,39,39,43,102,117,110,99,110,97,109,101,
91,48,93,43,39,39,39,32,105,109,112,111,114,116,32,39,39,39,43,102,117,110,99,
110,97,109,101,91,49,93,43,39,39,39,10,
// 'try:\n
116,114,121,58,10,
// '    resultarrays[0].size = 0\n
32,32,32,32,114,101,115,117,108,116,97,114,114,97,121,115,91,48,93,46,115,105,
122,101,32,61,32,48,10,
// '    for n in range(insize):\n
32,32,32,32,102,111,114,32,110,32,105,110,32,114,97,110,103,101,40,105,110,115,
105,122,101,41,58,10,
// "           for '''+','.join(['val'+str(x) for x in range(genindices[1])])+''' in iters[inputd['''+str(genindices[0])+'''][n]]:\n
32,32,32,32,32,32,32,32,32,32,32,102,111,114,32,39,39,39,43,39,44,39,46,106,
111,105,110,40,91,39,118,97,108,39,43,115,116,114,40,120,41,32,102,111,114,32,
120,32,105,110,32,114,97,110,103,101,40,103,101,110,105,110,100,105,99,101,115,
91,49,93,41,93,41,43,39,39,39,32,105,110,32,105,116,101,114,115,91,105,110,112,
117,116,100,91,39,39,39,43,115,116,114,40,103,101,110,105,110,100,105,99,101,
115,91,48,93,41,43,39,39,39,93,91,110,93,93,58,10,
// "           #for '''+','.join(['val'+str(x) for x in range(genindices[1])])+'''  in '''+funcname[1]+'''.'''+funcname[2]+'''('''+code_params+'''): #ffi.string(inputd['''+str(genindices[0])+'''][n])]:\n
32,32,32,32,32,32,32,32,32,32,32,35,102,111,114,32,39,39,39,43,39,44,39,46,106,
111,105,110,40,91,39,118,97,108,39,43,115,116,114,40,120,41,32,102,111,114,32,
120,32,105,110,32,114,97,110,103,101,40,103,101,110,105,110,100,105,99,101,115,
91,49,93,41,93,41,43,39,39,39,32,32,105,110,32,39,39,39,43,102,117,110,99,110,
97,109,101,91,49,93,43,39,39,39,46,39,39,39,43,102,117,110,99,110,97,109,101,
91,50,93,43,39,39,39,40,39,39,39,43,99,111,100,101,95,112,97,114,97,109,115,
43,39,39,39,41,58,32,35,102,102,105,46,115,116,114,105,110,103,40,105,110,112,
117,116,100,91,39,39,39,43,115,116,114,40,103,101,110,105,110,100,105,99,101,
115,91,48,93,41,43,39,39,39,93,91,110,93,41,93,58,10,
// '              cc += 1\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,99,99,32,43,61,32,49,10,
// '              resultarrays[0].size = cc+1\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,114,101,115,117,108,116,97,114,114,
97,121,115,91,48,93,46,115,105,122,101,32,61,32,99,99,43,49,10,
// '              if cc >= retlen:\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,105,102,32,99,99,32,62,61,32,114,101,
116,108,101,110,58,10,
// '                retlen = retlen*2\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,114,101,116,108,101,110,32,61,
32,114,101,116,108,101,110,42,50,10,
// '                for i in range(resultnum):\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,102,111,114,32,105,32,105,110,
32,114,97,110,103,101,40,114,101,115,117,108,116,110,117,109,41,58,10,
// '                  if resultarrays[i].type == 0:\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,105,102,32,114,101,115,
117,108,116,97,114,114,97,121,115,91,105,93,46,116,121,112,101,32,61,61,32,48,
58,10,
// '                      resultarrays[i].array = ffi.cast("char**", lib.realloc(resultarrays[i].array,retlen*ffi.sizeof("char *")))\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,114,101,115,
117,108,116,97,114,114,97,121,115,91,105,93,46,97,114,114,97,121,32,61,32,102,
102,105,46,99,97,115,116,40,34,99,104,97,114,42,42,34,44,32,108,105,98,46,114,
101,97,108,108,111,99,40,114,101,115,117,108,116,97,114,114,97,121,115,91,105,
93,46,97,114,114,97,121,44,114,101,116,108,101,110,42,102,102,105,46,115,105,
122,101,111,102,40,34,99,104,97,114,32,42,34,41,41,41,10,
// '                      outputd[i] = ffi.cast("char **", resultarrays[i].array )\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,111,117,116,
112,117,116,100,91,105,93,32,61,32,102,102,105,46,99,97,115,116,40,34,99,104,
97,114,32,42,42,34,44,32,114,101,115,117,108,116,97,114,114,97,121,115,91,105,
93,46,97,114,114,97,121,32,41,10,
// '                  elif resultarrays[i].type == 1:\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,101,108,105,102,32,114,
101,115,117,108,116,97,114,114,97,121,115,91,105,93,46,116,121,112,101,32,61,
61,32,49,58,10,
// '                      resultarrays[i].array = ffi.cast("int*", lib.realloc(resultarrays[i].array, retlen*ffi.sizeof("int")))\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,114,101,115,
117,108,116,97,114,114,97,121,115,91,105,93,46,97,114,114,97,121,32,61,32,102,
102,105,46,99,97,115,116,40,34,105,110,116,42,34,44,32,108,105,98,46,114,101,
97,108,108,111,99,40,114,101,115,117,108,116,97,114,114,97,121,115,91,105,93,
46,97,114,114,97,121,44,32,114,101,116,108,101,110,42,102,102,105,46,115,105,
122,101,111,102,40,34,105,110,116,34,41,41,41,10,
// '                      outputd[i] = ffi.cast("int*", resultarrays[i].array )\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,111,117,116,
112,117,116,100,91,105,93,32,61,32,102,102,105,46,99,97,115,116,40,34,105,110,
116,42,34,44,32,114,101,115,117,108,116,97,114,114,97,121,115,91,105,93,46,97,
114,114,97,121,32,41,10,
// '                  elif resultarrays[i].type == 2:\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,101,108,105,102,32,114,
101,115,117,108,116,97,114,114,97,121,115,91,105,93,46,116,121,112,101,32,61,
61,32,50,58,10,
// '                      resultarrays[i].array = ffi.cast("double*", lib.realloc(resultarrays[i].array, retlen*ffi.sizeof("double")))\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,114,101,115,
117,108,116,97,114,114,97,121,115,91,105,93,46,97,114,114,97,121,32,61,32,102,
102,105,46,99,97,115,116,40,34,100,111,117,98,108,101,42,34,44,32,108,105,98,
46,114,101,97,108,108,111,99,40,114,101,115,117,108,116,97,114,114,97,121,115,
91,105,93,46,97,114,114,97,121,44,32,114,101,116,108,101,110,42,102,102,105,
46,115,105,122,101,111,102,40,34,100,111,117,98,108,101,34,41,41,41,10,
// '                      outputd[i] = ffi.cast("double*", resultarrays[i].array )\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,111,117,116,
112,117,116,100,91,105,93,32,61,32,102,102,105,46,99,97,115,116,40,34,100,111,
117,98,108,101,42,34,44,32,114,101,115,117,108,116,97,114,114,97,121,115,91,
105,93,46,97,114,114,97,121,32,41,10,
// "              '''+code_loop_iterator+'''\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,39,39,39,43,99,111,100,101,95,108,
111,111,112,95,105,116,101,114,97,116,111,114,43,39,39,39,10,
// "              '''+code_loop_rest_prev+'''\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,39,39,39,43,99,111,100,101,95,108,
111,111,112,95,114,101,115,116,95,112,114,101,118,43,39,39,39,10,
// "              '''+code_loop_rest_next+'''\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,39,39,39,43,99,111,100,101,95,108,
111,111,112,95,114,101,115,116,95,110,101,120,116,43,39,39,39,10,
// "           del iters[inputd['''+str(genindices[0])+'''][n]]\n
32,32,32,32,32,32,32,32,32,32,32,100,101,108,32,105,116,101,114,115,91,105,110,
112,117,116,100,91,39,39,39,43,115,116,114,40,103,101,110,105,110,100,105,99,
101,115,91,48,93,41,43,39,39,39,93,91,110,93,93,10,
// '              #outputd[0][cc] = lib.strdup(ffi.from_buffer(memoryview(prev)))\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,35,111,117,116,112,117,116,100,91,
48,93,91,99,99,93,32,61,32,108,105,98,46,115,116,114,100,117,112,40,102,102,
105,46,102,114,111,109,95,98,117,102,102,101,114,40,109,101,109,111,114,121,
118,105,101,119,40,112,114,101,118,41,41,41,10,
// '              #outputd[1][cc] = lib.strdup(ffi.from_buffer(memoryview(middle.encode())))\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,35,111,117,116,112,117,116,100,91,
49,93,91,99,99,93,32,61,32,108,105,98,46,115,116,114,100,117,112,40,102,102,
105,46,102,114,111,109,95,98,117,102,102,101,114,40,109,101,109,111,114,121,
118,105,101,119,40,109,105,100,100,108,101,46,101,110,99,111,100,101,40,41,41,
41,41,10,
// '              #outputd[2][cc] = lib.strdup(ffi.from_buffer(memoryview(next.encode())))\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,35,111,117,116,112,117,116,100,91,
50,93,91,99,99,93,32,61,32,108,105,98,46,115,116,114,100,117,112,40,102,102,
105,46,102,114,111,109,95,98,117,102,102,101,114,40,109,101,109,111,114,121,
118,105,101,119,40,110,101,120,116,46,101,110,99,111,100,101,40,41,41,41,41,
10,
// '              ##outputd[0][cc] = inputd[0][n]\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,35,35,111,117,116,112,117,116,100,
91,48,93,91,99,99,93,32,61,32,105,110,112,117,116,100,91,48,93,91,110,93,10,
// '              ##outputd[1][cc] = inputd[1][n]\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,35,35,111,117,116,112,117,116,100,
91,49,93,91,99,99,93,32,61,32,105,110,112,117,116,100,91,49,93,91,110,93,10,
// 'except Exception as e:\n
101,120,99,101,112,116,32,69,120,99,101,112,116,105,111,110,32,97,115,32,101,
58,10,
// "      errormessage[0] = lib.strdup(ffi.from_buffer(memoryview(b'UDFError '+ funcname[0].encode()+b'.'+funcname[1].encode()+b'.'+funcname[2].upper().encode() + b': ' + traceback.format_exc().encode())))\n
32,32,32,32,32,32,101,114,114,111,114,109,101,115,115,97,103,101,91,48,93,32,
61,32,108,105,98,46,115,116,114,100,117,112,40,102,102,105,46,102,114,111,109,
95,98,117,102,102,101,114,40,109,101,109,111,114,121,118,105,101,119,40,98,39,
85,68,70,69,114,114,111,114,32,39,43,32,102,117,110,99,110,97,109,101,91,48,
93,46,101,110,99,111,100,101,40,41,43,98,39,46,39,43,102,117,110,99,110,97,109,
101,91,49,93,46,101,110,99,111,100,101,40,41,43,98,39,46,39,43,102,117,110,99,
110,97,109,101,91,50,93,46,117,112,112,101,114,40,41,46,101,110,99,111,100,101,
40,41,32,43,32,98,39,58,32,39,32,43,32,116,114,97,99,101,98,97,99,107,46,102,
111,114,109,97,116,95,101,120,99,40,41,46,101,110,99,111,100,101,40,41,41,41,
41,10,
// "      '''\n
32,32,32,32,32,32,39,39,39,10,
// '      print(code_string)\n
32,32,32,32,32,32,112,114,105,110,116,40,99,111,100,101,95,115,116,114,105,110,
103,41,10,
// '      exec(code_string)\n
32,32,32,32,32,32,101,120,101,99,40,99,111,100,101,95,115,116,114,105,110,103,
41,10,
// '      return 1\n
32,32,32,32,32,32,114,101,116,117,114,110,32,49,10,
// '  if lengenindices > 2:\n
32,32,105,102,32,108,101,110,103,101,110,105,110,100,105,99,101,115,32,62,32,
50,58,10,
// "      errormessage[0] = lib.strdup(ffi.from_buffer(memoryview(b'UDFError '+ funcname[0].encode()+b'.'+funcname[1].encode()+b'.'+funcname[2].upper().encode() + b': Multiple multiset UDFs in the same projection is not supported yet')))\n
32,32,32,32,32,32,101,114,114,111,114,109,101,115,115,97,103,101,91,48,93,32,
61,32,108,105,98,46,115,116,114,100,117,112,40,102,102,105,46,102,114,111,109,
95,98,117,102,102,101,114,40,109,101,109,111,114,121,118,105,101,119,40,98,39,
85,68,70,69,114,114,111,114,32,39,43,32,102,117,110,99,110,97,109,101,91,48,
93,46,101,110,99,111,100,101,40,41,43,98,39,46,39,43,102,117,110,99,110,97,109,
101,91,49,93,46,101,110,99,111,100,101,40,41,43,98,39,46,39,43,102,117,110,99,
110,97,109,101,91,50,93,46,117,112,112,101,114,40,41,46,101,110,99,111,100,101,
40,41,32,43,32,98,39,58,32,77,117,108,116,105,112,108,101,32,109,117,108,116,
105,115,101,116,32,85,68,70,115,32,105,110,32,116,104,101,32,115,97,109,101,
32,112,114,111,106,101,99,116,105,111,110,32,105,115,32,110,111,116,32,115,117,
112,112,111,114,116,101,100,32,121,101,116,39,41,41,41,10,
// '      pass     ## TODO cross join - 2 OR MORE MULTISET UDFs  NOT SUPPORTED YET in a single projection\n
32,32,32,32,32,32,112,97,115,115,32,32,32,32,32,35,35,32,84,79,68,79,32,99,114,
111,115,115,32,106,111,105,110,32,45,32,50,32,79,82,32,77,79,82,69,32,77,85,
76,84,73,83,69,84,32,85,68,70,115,32,32,78,79,84,32,83,85,80,80,79,82,84,69,
68,32,89,69,84,32,105,110,32,97,32,115,105,110,103,108,101,32,112,114,111,106,
101,99,116,105,111,110,10,
// '  return 1\n
32,32,114,101,116,117,114,110,32,49,10,
// '\n
10,
// '\n
10,
// '@ffi.def_extern()\n
64,102,102,105,46,100,101,102,95,101,120,116,101,114,110,40,41,10,
// 'def aggregatewrapper(funcname, inputcount, paramsnum, arrays, resultdouble, resultint, resultstring, groups, count_per_group, errormessage):\n
100,101,102,32,97,103,103,114,101,103,97,116,101,119,114,97,112,112,101,114,
40,102,117,110,99,110,97,109,101,44,32,105,110,112,117,116,99,111,117,110,116,
44,32,112,97,114,97,109,115,110,117,109,44,32,97,114,114,97,121,115,44,32,114,
101,115,117,108,116,100,111,117,98,108,101,44,32,114,101,115,117,108,116,105,
110,116,44,32,114,101,115,117,108,116,115,116,114,105,110,103,44,32,103,114,
111,117,112,115,44,32,99,111,117,110,116,95,112,101,114,95,103,114,111,117,112,
44,32,101,114,114,111,114,109,101,115,115,97,103,101,41,58,10,
// '    global iters\n
32,32,32,32,103,108,111,98,97,108,32,105,116,101,114,115,10,
// '    errorm = 0\n
32,32,32,32,101,114,114,111,114,109,32,61,32,48,10,
// "    #print('fofo: ',inputcount, groups)\n
32,32,32,32,35,112,114,105,110,116,40,39,102,111,102,111,58,32,39,44,105,110,
112,117,116,99,111,117,110,116,44,32,103,114,111,117,112,115,41,10,
// '    funcname = ffi.string(funcname).decode()\n
32,32,32,32,102,117,110,99,110,97,109,101,32,61,32,102,102,105,46,115,116,114,
105,110,103,40,102,117,110,99,110,97,109,101,41,46,100,101,99,111,100,101,40,
41,10,
// "    funcname = funcname.split('.')\n
32,32,32,32,102,117,110,99,110,97,109,101,32,61,32,102,117,110,99,110,97,109,
101,46,115,112,108,105,116,40,39,46,39,41,10,
// '    li = [None]*paramsnum\n
32,32,32,32,108,105,32,61,32,91,78,111,110,101,93,42,112,97,114,97,109,115,110,
117,109,10,
// '    types = [None]*paramsnum\n
32,32,32,32,116,121,112,101,115,32,61,32,91,78,111,110,101,93,42,112,97,114,
97,109,115,110,117,109,10,
// '    #for c in range(groups):\n
32,32,32,32,35,102,111,114,32,99,32,105,110,32,114,97,110,103,101,40,103,114,
111,117,112,115,41,58,10,
// '    #    print(count_per_group[c], inputcount)\n
32,32,32,32,35,32,32,32,32,112,114,105,110,116,40,99,111,117,110,116,95,112,
101,114,95,103,114,111,117,112,91,99,93,44,32,105,110,112,117,116,99,111,117,
110,116,41,10,
// '    for i in range(paramsnum):\n
32,32,32,32,102,111,114,32,105,32,105,110,32,114,97,110,103,101,40,112,97,114,
97,109,115,110,117,109,41,58,10,
// '        if arrays[i].type == 0:\n
32,32,32,32,32,32,32,32,105,102,32,97,114,114,97,121,115,91,105,93,46,116,121,
112,101,32,61,61,32,48,58,10,
// '            li[i] = ffi.cast("char ***", arrays[i].array )\n
32,32,32,32,32,32,32,32,32,32,32,32,108,105,91,105,93,32,61,32,102,102,105,46,
99,97,115,116,40,34,99,104,97,114,32,42,42,42,34,44,32,97,114,114,97,121,115,
91,105,93,46,97,114,114,97,121,32,41,10,
// '        elif arrays[i].type == 1:\n
32,32,32,32,32,32,32,32,101,108,105,102,32,97,114,114,97,121,115,91,105,93,46,
116,121,112,101,32,61,61,32,49,58,10,
// '            li[i] = ffi.cast("int **", arrays[i].array )\n
32,32,32,32,32,32,32,32,32,32,32,32,108,105,91,105,93,32,61,32,102,102,105,46,
99,97,115,116,40,34,105,110,116,32,42,42,34,44,32,97,114,114,97,121,115,91,105,
93,46,97,114,114,97,121,32,41,10,
// '        elif arrays[i].type == 2:\n
32,32,32,32,32,32,32,32,101,108,105,102,32,97,114,114,97,121,115,91,105,93,46,
116,121,112,101,32,61,61,32,50,58,10,
// '            li[i] = ffi.cast("double **", arrays[i].array)\n
32,32,32,32,32,32,32,32,32,32,32,32,108,105,91,105,93,32,61,32,102,102,105,46,
99,97,115,116,40,34,100,111,117,98,108,101,32,42,42,34,44,32,97,114,114,97,121,
115,91,105,93,46,97,114,114,97,121,41,10,
// '        elif arrays[i].type == 4:\n
32,32,32,32,32,32,32,32,101,108,105,102,32,97,114,114,97,121,115,91,105,93,46,
116,121,112,101,32,61,61,32,52,58,10,
// '            li[i] = ffi.cast("int8_t **", arrays[i].array)\n
32,32,32,32,32,32,32,32,32,32,32,32,108,105,91,105,93,32,61,32,102,102,105,46,
99,97,115,116,40,34,105,110,116,56,95,116,32,42,42,34,44,32,97,114,114,97,121,
115,91,105,93,46,97,114,114,97,121,41,10,
// '        elif arrays[i].type == 5:\n
32,32,32,32,32,32,32,32,101,108,105,102,32,97,114,114,97,121,115,91,105,93,46,
116,121,112,101,32,61,61,32,53,58,10,
// '            li[i] = ffi.cast("int16_t **", arrays[i].array)\n
32,32,32,32,32,32,32,32,32,32,32,32,108,105,91,105,93,32,61,32,102,102,105,46,
99,97,115,116,40,34,105,110,116,49,54,95,116,32,42,42,34,44,32,97,114,114,97,
121,115,91,105,93,46,97,114,114,97,121,41,10,
// "    #print('lala: ', sum([li[1][0][x] for x in range(inputcount)]) )\n
32,32,32,32,35,112,114,105,110,116,40,39,108,97,108,97,58,32,39,44,32,115,117,
109,40,91,108,105,91,49,93,91,48,93,91,120,93,32,102,111,114,32,120,32,105,110,
32,114,97,110,103,101,40,105,110,112,117,116,99,111,117,110,116,41,93,41,32,
41,10,
// '    if resultstring != ffi.NULL:\n
32,32,32,32,105,102,32,114,101,115,117,108,116,115,116,114,105,110,103,32,33,
61,32,102,102,105,46,78,85,76,76,58,10,
// "        resultparam = 'resultstring'\n
32,32,32,32,32,32,32,32,114,101,115,117,108,116,112,97,114,97,109,32,61,32,39,
114,101,115,117,108,116,115,116,114,105,110,103,39,10,
// '    elif resultint != ffi.NULL:\n
32,32,32,32,101,108,105,102,32,114,101,115,117,108,116,105,110,116,32,33,61,
32,102,102,105,46,78,85,76,76,58,10,
// "        resultparam = 'resultint'\n
32,32,32,32,32,32,32,32,114,101,115,117,108,116,112,97,114,97,109,32,61,32,39,
114,101,115,117,108,116,105,110,116,39,10,
// '    elif resultdouble != ffi.NULL:\n
32,32,32,32,101,108,105,102,32,114,101,115,117,108,116,100,111,117,98,108,101,
32,33,61,32,102,102,105,46,78,85,76,76,58,10,
// "        resultparam = 'resultdouble'\n
32,32,32,32,32,32,32,32,114,101,115,117,108,116,112,97,114,97,109,32,61,32,39,
114,101,115,117,108,116,100,111,117,98,108,101,39,10,
// "    code_params = ', '.join(['ffi.string(li['+str(j)+'][grp][col])' if arrays[j].type == 0 else 'li['+str(j)+'][grp][col]' for j in range(paramsnum)])\n
32,32,32,32,99,111,100,101,95,112,97,114,97,109,115,32,61,32,39,44,32,39,46,
106,111,105,110,40,91,39,102,102,105,46,115,116,114,105,110,103,40,108,105,91,
39,43,115,116,114,40,106,41,43,39,93,91,103,114,112,93,91,99,111,108,93,41,39,
32,105,102,32,97,114,114,97,121,115,91,106,93,46,116,121,112,101,32,61,61,32,
48,32,101,108,115,101,32,39,108,105,91,39,43,115,116,114,40,106,41,43,39,93,
91,103,114,112,93,91,99,111,108,93,39,32,102,111,114,32,106,32,105,110,32,114,
97,110,103,101,40,112,97,114,97,109,115,110,117,109,41,93,41,10,
// "    if resultparam != 'resultstring':\n
32,32,32,32,105,102,32,114,101,115,117,108,116,112,97,114,97,109,32,33,61,32,
39,114,101,115,117,108,116,115,116,114,105,110,103,39,58,10,
// "        code_string = '''\n
32,32,32,32,32,32,32,32,99,111,100,101,95,115,116,114,105,110,103,32,61,32,39,
39,39,10,
// 'try:\n
116,114,121,58,10,
// " from '''+funcname[0]+''' import '''+funcname[1]+'''\n
32,102,114,111,109,32,39,39,39,43,102,117,110,99,110,97,109,101,91,48,93,43,
39,39,39,32,105,109,112,111,114,116,32,39,39,39,43,102,117,110,99,110,97,109,
101,91,49,93,43,39,39,39,10,
// ' if functions.DEBUG:\n
32,105,102,32,102,117,110,99,116,105,111,110,115,46,68,69,66,85,71,58,10,
// "      mypath = get_module_path(funcname[0]+'.'+funcname[1])\n
32,32,32,32,32,32,109,121,112,97,116,104,32,61,32,103,101,116,95,109,111,100,
117,108,101,95,112,97,116,104,40,102,117,110,99,110,97,109,101,91,48,93,43,39,
46,39,43,102,117,110,99,110,97,109,101,91,49,93,41,10,
// '      #print(mypath)\n
32,32,32,32,32,32,35,112,114,105,110,116,40,109,121,112,97,116,104,41,10,
// '      if mypath not in checksums:\n
32,32,32,32,32,32,105,102,32,109,121,112,97,116,104,32,110,111,116,32,105,110,
32,99,104,101,99,107,115,117,109,115,58,10,
// '        checksums[mypath] = calculate_checksum(mypath)\n
32,32,32,32,32,32,32,32,99,104,101,99,107,115,117,109,115,91,109,121,112,97,
116,104,93,32,61,32,99,97,108,99,117,108,97,116,101,95,99,104,101,99,107,115,
117,109,40,109,121,112,97,116,104,41,10,
// '      elif mypath in checksums:\n
32,32,32,32,32,32,101,108,105,102,32,109,121,112,97,116,104,32,105,110,32,99,
104,101,99,107,115,117,109,115,58,10,
// '        csum = calculate_checksum(mypath)\n
32,32,32,32,32,32,32,32,99,115,117,109,32,61,32,99,97,108,99,117,108,97,116,
101,95,99,104,101,99,107,115,117,109,40,109,121,112,97,116,104,41,10,
// '        if checksums[mypath] != csum:\n
32,32,32,32,32,32,32,32,105,102,32,99,104,101,99,107,115,117,109,115,91,109,
121,112,97,116,104,93,32,33,61,32,99,115,117,109,58,10,
// "          importlib.reload('''+funcname[1]+''')\n
32,32,32,32,32,32,32,32,32,32,105,109,112,111,114,116,108,105,98,46,114,101,
108,111,97,100,40,39,39,39,43,102,117,110,99,110,97,109,101,91,49,93,43,39,39,
39,41,10,
// '          checksums[mypath] = csum\n
32,32,32,32,32,32,32,32,32,32,99,104,101,99,107,115,117,109,115,91,109,121,112,
97,116,104,93,32,61,32,99,115,117,109,10,
// " if inspect.isgeneratorfunction('''+funcname[1]+'''.'''+funcname[2]+'''.final):\n
32,105,102,32,105,110,115,112,101,99,116,46,105,115,103,101,110,101,114,97,116,
111,114,102,117,110,99,116,105,111,110,40,39,39,39,43,102,117,110,99,110,97,
109,101,91,49,93,43,39,39,39,46,39,39,39,43,102,117,110,99,110,97,109,101,91,
50,93,43,39,39,39,46,102,105,110,97,108,41,58,10,
// "  #print('is a generator')\n
32,32,35,112,114,105,110,116,40,39,105,115,32,97,32,103,101,110,101,114,97,116,
111,114,39,41,10,
// '  for grp in range(groups):\n
32,32,102,111,114,32,103,114,112,32,105,110,32,114,97,110,103,101,40,103,114,
111,117,112,115,41,58,10,
// "    aggr='''+funcname[1]+'''.'''+funcname[2]+'''()\n
32,32,32,32,97,103,103,114,61,39,39,39,43,102,117,110,99,110,97,109,101,91,49,
93,43,39,39,39,46,39,39,39,43,102,117,110,99,110,97,109,101,91,50,93,43,39,39,
39,40,41,10,
// '    for col in range(count_per_group[grp]):\n
32,32,32,32,102,111,114,32,99,111,108,32,105,110,32,114,97,110,103,101,40,99,
111,117,110,116,95,112,101,114,95,103,114,111,117,112,91,103,114,112,93,41,58,
10,
// "        aggr.step('''+code_params+''')\n
32,32,32,32,32,32,32,32,97,103,103,114,46,115,116,101,112,40,39,39,39,43,99,
111,100,101,95,112,97,114,97,109,115,43,39,39,39,41,10,
// '    func = aggr.final()\n
32,32,32,32,102,117,110,99,32,61,32,97,103,103,114,46,102,105,110,97,108,40,
41,10,
// '    myhash = (hash(str(func)) % (10**9))/(10**9)\n
32,32,32,32,109,121,104,97,115,104,32,61,32,40,104,97,115,104,40,115,116,114,
40,102,117,110,99,41,41,32,37,32,40,49,48,42,42,57,41,41,47,40,49,48,42,42,57,
41,10,
// '    iters[myhash] = func\n
32,32,32,32,105,116,101,114,115,91,109,121,104,97,115,104,93,32,61,32,102,117,
110,99,10,
// "    '''+resultparam+'''[grp] = myhash\n
32,32,32,32,39,39,39,43,114,101,115,117,108,116,112,97,114,97,109,43,39,39,39,
91,103,114,112,93,32,61,32,109,121,104,97,115,104,10,
// '\n
10,
// ' else:\n
32,101,108,115,101,58,10,
// '  for grp in range(groups):\n
32,32,102,111,114,32,103,114,112,32,105,110,32,114,97,110,103,101,40,103,114,
111,117,112,115,41,58,10,
// "    aggr='''+funcname[1]+'''.'''+funcname[2]+'''()\n
32,32,32,32,97,103,103,114,61,39,39,39,43,102,117,110,99,110,97,109,101,91,49,
93,43,39,39,39,46,39,39,39,43,102,117,110,99,110,97,109,101,91,50,93,43,39,39,
39,40,41,10,
// '    for col in range(count_per_group[grp]):\n
32,32,32,32,102,111,114,32,99,111,108,32,105,110,32,114,97,110,103,101,40,99,
111,117,110,116,95,112,101,114,95,103,114,111,117,112,91,103,114,112,93,41,58,
10,
// "        aggr.step('''+code_params+''')\n
32,32,32,32,32,32,32,32,97,103,103,114,46,115,116,101,112,40,39,39,39,43,99,
111,100,101,95,112,97,114,97,109,115,43,39,39,39,41,10,
// "    '''+resultparam+'''[grp] = aggr.final()\n
32,32,32,32,39,39,39,43,114,101,115,117,108,116,112,97,114,97,109,43,39,39,39,
91,103,114,112,93,32,61,32,97,103,103,114,46,102,105,110,97,108,40,41,10,
// '    print(aggr.final())\n
32,32,32,32,112,114,105,110,116,40,97,103,103,114,46,102,105,110,97,108,40,41,
41,10,
// 'except Exception as e:\n
101,120,99,101,112,116,32,69,120,99,101,112,116,105,111,110,32,97,115,32,101,
58,10,
// "    errormessage[0] = lib.strdup(ffi.from_buffer(memoryview(b'UDFError '+ funcname[0].encode()+b'.'+funcname[1].encode()+b'.'+funcname[2].upper().encode() + b': ' + traceback.format_exc().encode())))\n
32,32,32,32,101,114,114,111,114,109,101,115,115,97,103,101,91,48,93,32,61,32,
108,105,98,46,115,116,114,100,117,112,40,102,102,105,46,102,114,111,109,95,98,
117,102,102,101,114,40,109,101,109,111,114,121,118,105,101,119,40,98,39,85,68,
70,69,114,114,111,114,32,39,43,32,102,117,110,99,110,97,109,101,91,48,93,46,
101,110,99,111,100,101,40,41,43,98,39,46,39,43,102,117,110,99,110,97,109,101,
91,49,93,46,101,110,99,111,100,101,40,41,43,98,39,46,39,43,102,117,110,99,110,
97,109,101,91,50,93,46,117,112,112,101,114,40,41,46,101,110,99,111,100,101,40,
41,32,43,32,98,39,58,32,39,32,43,32,116,114,97,99,101,98,97,99,107,46,102,111,
114,109,97,116,95,101,120,99,40,41,46,101,110,99,111,100,101,40,41,41,41,41,
10,
// '    errorm = 1\n
32,32,32,32,101,114,114,111,114,109,32,61,32,49,10,
// "    '''\n
32,32,32,32,39,39,39,10,
// '    else:\n
32,32,32,32,101,108,115,101,58,10,
// "        code_string = '''\n
32,32,32,32,32,32,32,32,99,111,100,101,95,115,116,114,105,110,103,32,61,32,39,
39,39,10,
// 'try:\n
116,114,121,58,10,
// " from '''+funcname[0]+''' import '''+funcname[1]+'''\n
32,102,114,111,109,32,39,39,39,43,102,117,110,99,110,97,109,101,91,48,93,43,
39,39,39,32,105,109,112,111,114,116,32,39,39,39,43,102,117,110,99,110,97,109,
101,91,49,93,43,39,39,39,10,
// ' if functions.DEBUG:\n
32,105,102,32,102,117,110,99,116,105,111,110,115,46,68,69,66,85,71,58,10,
// "      mypath = get_module_path(funcname[0]+'.'+funcname[1])\n
32,32,32,32,32,32,109,121,112,97,116,104,32,61,32,103,101,116,95,109,111,100,
117,108,101,95,112,97,116,104,40,102,117,110,99,110,97,109,101,91,48,93,43,39,
46,39,43,102,117,110,99,110,97,109,101,91,49,93,41,10,
// '      #print(mypath)\n
32,32,32,32,32,32,35,112,114,105,110,116,40,109,121,112,97,116,104,41,10,
// '      if mypath not in checksums:\n
32,32,32,32,32,32,105,102,32,109,121,112,97,116,104,32,110,111,116,32,105,110,
32,99,104,101,99,107,115,117,109,115,58,10,
// '        checksums[mypath] = calculate_checksum(mypath)\n
32,32,32,32,32,32,32,32,99,104,101,99,107,115,117,109,115,91,109,121,112,97,
116,104,93,32,61,32,99,97,108,99,117,108,97,116,101,95,99,104,101,99,107,115,
117,109,40,109,121,112,97,116,104,41,10,
// '      elif mypath in checksums:\n
32,32,32,32,32,32,101,108,105,102,32,109,121,112,97,116,104,32,105,110,32,99,
104,101,99,107,115,117,109,115,58,10,
// '        csum = calculate_checksum(mypath)\n
32,32,32,32,32,32,32,32,99,115,117,109,32,61,32,99,97,108,99,117,108,97,116,
101,95,99,104,101,99,107,115,117,109,40,109,121,112,97,116,104,41,10,
// '        if checksums[mypath] != csum:\n
32,32,32,32,32,32,32,32,105,102,32,99,104,101,99,107,115,117,109,115,91,109,
121,112,97,116,104,93,32,33,61,32,99,115,117,109,58,10,
// "          importlib.reload('''+funcname[1]+''')\n
32,32,32,32,32,32,32,32,32,32,105,109,112,111,114,116,108,105,98,46,114,101,
108,111,97,100,40,39,39,39,43,102,117,110,99,110,97,109,101,91,49,93,43,39,39,
39,41,10,
// '          checksums[mypath] = csum\n
32,32,32,32,32,32,32,32,32,32,99,104,101,99,107,115,117,109,115,91,109,121,112,
97,116,104,93,32,61,32,99,115,117,109,10,
// ' for grp in range(groups):\n
32,102,111,114,32,103,114,112,32,105,110,32,114,97,110,103,101,40,103,114,111,
117,112,115,41,58,10,
// "    aggr = '''+funcname[1]+'''.'''+funcname[2]+'''()\n
32,32,32,32,97,103,103,114,32,61,32,39,39,39,43,102,117,110,99,110,97,109,101,
91,49,93,43,39,39,39,46,39,39,39,43,102,117,110,99,110,97,109,101,91,50,93,43,
39,39,39,40,41,10,
// '    for col in range(count_per_group[grp]):\n
32,32,32,32,102,111,114,32,99,111,108,32,105,110,32,114,97,110,103,101,40,99,
111,117,110,116,95,112,101,114,95,103,114,111,117,112,91,103,114,112,93,41,58,
10,
// "        aggr.step('''+code_params+''')\n
32,32,32,32,32,32,32,32,97,103,103,114,46,115,116,101,112,40,39,39,39,43,99,
111,100,101,95,112,97,114,97,109,115,43,39,39,39,41,10,
// '    resultstring[grp] = ffi.from_buffer(memoryview(aggr.final()))\n
32,32,32,32,114,101,115,117,108,116,115,116,114,105,110,103,91,103,114,112,93,
32,61,32,102,102,105,46,102,114,111,109,95,98,117,102,102,101,114,40,109,101,
109,111,114,121,118,105,101,119,40,97,103,103,114,46,102,105,110,97,108,40,41,
41,41,10,
// 'except Exception as e:\n
101,120,99,101,112,116,32,69,120,99,101,112,116,105,111,110,32,97,115,32,101,
58,10,
// "    errormessage[0] = lib.strdup(ffi.from_buffer(memoryview(b'UDFError '+ funcname[0].encode()+b'.'+funcname[1].encode()+b'.'+funcname[2].upper().encode() + b': ' + traceback.format_exc().encode())))\n
32,32,32,32,101,114,114,111,114,109,101,115,115,97,103,101,91,48,93,32,61,32,
108,105,98,46,115,116,114,100,117,112,40,102,102,105,46,102,114,111,109,95,98,
117,102,102,101,114,40,109,101,109,111,114,121,118,105,101,119,40,98,39,85,68,
70,69,114,114,111,114,32,39,43,32,102,117,110,99,110,97,109,101,91,48,93,46,
101,110,99,111,100,101,40,41,43,98,39,46,39,43,102,117,110,99,110,97,109,101,
91,49,93,46,101,110,99,111,100,101,40,41,43,98,39,46,39,43,102,117,110,99,110,
97,109,101,91,50,93,46,117,112,112,101,114,40,41,46,101,110,99,111,100,101,40,
41,32,43,32,98,39,58,32,39,32,43,32,116,114,97,99,101,98,97,99,107,46,102,111,
114,109,97,116,95,101,120,99,40,41,46,101,110,99,111,100,101,40,41,41,41,41,
10,
// '    errorm = 1\n
32,32,32,32,101,114,114,111,114,109,32,61,32,49,10,
// "    '''\n
32,32,32,32,39,39,39,10,
// '    print (code_string)\n
32,32,32,32,112,114,105,110,116,32,40,99,111,100,101,95,115,116,114,105,110,
103,41,10,
// '    exec(code_string)\n
32,32,32,32,101,120,101,99,40,99,111,100,101,95,115,116,114,105,110,103,41,10,
// '    if errorm == 1:\n
32,32,32,32,105,102,32,101,114,114,111,114,109,32,61,61,32,49,58,10,
// '        return 0\n
32,32,32,32,32,32,32,32,114,101,116,117,114,110,32,48,10,
// '    else:\n
32,32,32,32,101,108,115,101,58,10,
// '        return 1\n
32,32,32,32,32,32,32,32,114,101,116,117,114,110,32,49,10,
// '\n
10,
// '\n
10,
// '@ffi.def_extern()\n
64,102,102,105,46,100,101,102,95,101,120,116,101,114,110,40,41,10,
// 'def numpyudfwrapper(funcname, paramsnum, arrays, resultnum, resultarrays, insize, extraparams, errormessage):\n
100,101,102,32,110,117,109,112,121,117,100,102,119,114,97,112,112,101,114,40,
102,117,110,99,110,97,109,101,44,32,112,97,114,97,109,115,110,117,109,44,32,
97,114,114,97,121,115,44,32,114,101,115,117,108,116,110,117,109,44,32,114,101,
115,117,108,116,97,114,114,97,121,115,44,32,105,110,115,105,122,101,44,32,101,
120,116,114,97,112,97,114,97,109,115,44,32,101,114,114,111,114,109,101,115,115,
97,103,101,41,58,10,
// '    inputd = [None]*paramsnum\n
32,32,32,32,105,110,112,117,116,100,32,61,32,91,78,111,110,101,93,42,112,97,
114,97,109,115,110,117,109,10,
// '    errorm = 0\n
32,32,32,32,101,114,114,111,114,109,32,61,32,48,10,
// '    outputd = [None]*resultnum\n
32,32,32,32,111,117,116,112,117,116,100,32,61,32,91,78,111,110,101,93,42,114,
101,115,117,108,116,110,117,109,10,
// '    funcname = ffi.string(funcname).decode()\n
32,32,32,32,102,117,110,99,110,97,109,101,32,61,32,102,102,105,46,115,116,114,
105,110,103,40,102,117,110,99,110,97,109,101,41,46,100,101,99,111,100,101,40,
41,10,
// "    funcname = funcname.split('.')\n
32,32,32,32,102,117,110,99,110,97,109,101,32,61,32,102,117,110,99,110,97,109,
101,46,115,112,108,105,116,40,39,46,39,41,10,
// '    inputtype = ""\n
32,32,32,32,105,110,112,117,116,116,121,112,101,32,61,32,34,34,10,
// '    nptype = ""\n
32,32,32,32,110,112,116,121,112,101,32,61,32,34,34,10,
// '    for i in range(paramsnum):\n
32,32,32,32,102,111,114,32,105,32,105,110,32,114,97,110,103,101,40,112,97,114,
97,109,115,110,117,109,41,58,10,
// '       if arrays[i].type == 0:\n
32,32,32,32,32,32,32,105,102,32,97,114,114,97,121,115,91,105,93,46,116,121,112,
101,32,61,61,32,48,58,10,
// '           inputd[i] = ffi.cast("char **", arrays[i].array )\n
32,32,32,32,32,32,32,32,32,32,32,105,110,112,117,116,100,91,105,93,32,61,32,
102,102,105,46,99,97,115,116,40,34,99,104,97,114,32,42,42,34,44,32,97,114,114,
97,121,115,91,105,93,46,97,114,114,97,121,32,41,10,
// '           inputtype = "char *"\n
32,32,32,32,32,32,32,32,32,32,32,105,110,112,117,116,116,121,112,101,32,61,32,
34,99,104,97,114,32,42,34,10,
// '           nptype = "str"\n
32,32,32,32,32,32,32,32,32,32,32,110,112,116,121,112,101,32,61,32,34,115,116,
114,34,10,
// '       elif arrays[i].type == 1:\n
32,32,32,32,32,32,32,101,108,105,102,32,97,114,114,97,121,115,91,105,93,46,116,
121,112,101,32,61,61,32,49,58,10,
// '           inputd[i] = ffi.cast("int *", arrays[i].array )\n
32,32,32,32,32,32,32,32,32,32,32,105,110,112,117,116,100,91,105,93,32,61,32,
102,102,105,46,99,97,115,116,40,34,105,110,116,32,42,34,44,32,97,114,114,97,
121,115,91,105,93,46,97,114,114,97,121,32,41,10,
// '           inputtype = "int"\n
32,32,32,32,32,32,32,32,32,32,32,105,110,112,117,116,116,121,112,101,32,61,32,
34,105,110,116,34,10,
// '           nptype = np.int32\n
32,32,32,32,32,32,32,32,32,32,32,110,112,116,121,112,101,32,61,32,110,112,46,
105,110,116,51,50,10,
// '       elif arrays[i].type == 2:\n
32,32,32,32,32,32,32,101,108,105,102,32,97,114,114,97,121,115,91,105,93,46,116,
121,112,101,32,61,61,32,50,58,10,
// '           inputd[i] = ffi.cast("double *", arrays[i].array)\n
32,32,32,32,32,32,32,32,32,32,32,105,110,112,117,116,100,91,105,93,32,61,32,
102,102,105,46,99,97,115,116,40,34,100,111,117,98,108,101,32,42,34,44,32,97,
114,114,97,121,115,91,105,93,46,97,114,114,97,121,41,10,
// '           inputtype = "double"\n
32,32,32,32,32,32,32,32,32,32,32,105,110,112,117,116,116,121,112,101,32,61,32,
34,100,111,117,98,108,101,34,10,
// '           nptype = np.float64\n
32,32,32,32,32,32,32,32,32,32,32,110,112,116,121,112,101,32,61,32,110,112,46,
102,108,111,97,116,54,52,10,
// '    if paramsnum>1:\n
32,32,32,32,105,102,32,112,97,114,97,109,115,110,117,109,62,49,58,10,
// '        #combined_array = ffi.cast(inputtype+" *", lib.malloc(insize*paramsnum * ffi.sizeof(inputtype)))\n
32,32,32,32,32,32,32,32,35,99,111,109,98,105,110,101,100,95,97,114,114,97,121,
32,61,32,102,102,105,46,99,97,115,116,40,105,110,112,117,116,116,121,112,101,
43,34,32,42,34,44,32,108,105,98,46,109,97,108,108,111,99,40,105,110,115,105,
122,101,42,112,97,114,97,109,115,110,117,109,32,42,32,102,102,105,46,115,105,
122,101,111,102,40,105,110,112,117,116,116,121,112,101,41,41,41,10,
// '        combined_array = ffi.new(inputtype+" []", insize*paramsnum)\n
32,32,32,32,32,32,32,32,99,111,109,98,105,110,101,100,95,97,114,114,97,121,32,
61,32,102,102,105,46,110,101,119,40,105,110,112,117,116,116,121,112,101,43,34,
32,91,93,34,44,32,105,110,115,105,122,101,42,112,97,114,97,109,115,110,117,109,
41,10,
// '        # Use memmove to copy data from float_pointer1 to the new array\n
32,32,32,32,32,32,32,32,35,32,85,115,101,32,109,101,109,109,111,118,101,32,116,
111,32,99,111,112,121,32,100,97,116,97,32,102,114,111,109,32,102,108,111,97,
116,95,112,111,105,110,116,101,114,49,32,116,111,32,116,104,101,32,110,101,119,
32,97,114,114,97,121,10,
// '        for i in range(paramsnum):\n
32,32,32,32,32,32,32,32,102,111,114,32,105,32,105,110,32,114,97,110,103,101,
40,112,97,114,97,109,115,110,117,109,41,58,10,
// '            ffi.memmove(combined_array+i*insize, arrays[i].array, insize * ffi.sizeof(inputtype))\n
32,32,32,32,32,32,32,32,32,32,32,32,102,102,105,46,109,101,109,109,111,118,101,
40,99,111,109,98,105,110,101,100,95,97,114,114,97,121,43,105,42,105,110,115,
105,122,101,44,32,97,114,114,97,121,115,91,105,93,46,97,114,114,97,121,44,32,
105,110,115,105,122,101,32,42,32,102,102,105,46,115,105,122,101,111,102,40,105,
110,112,117,116,116,121,112,101,41,41,10,
// '\n
10,
// '        numpy_array = np.frombuffer(ffi.buffer(combined_array, ffi.sizeof(inputtype)*insize*paramsnum), dtype=nptype)\n
32,32,32,32,32,32,32,32,110,117,109,112,121,95,97,114,114,97,121,32,61,32,110,
112,46,102,114,111,109,98,117,102,102,101,114,40,102,102,105,46,98,117,102,102,
101,114,40,99,111,109,98,105,110,101,100,95,97,114,114,97,121,44,32,102,102,
105,46,115,105,122,101,111,102,40,105,110,112,117,116,116,121,112,101,41,42,
105,110,115,105,122,101,42,112,97,114,97,109,115,110,117,109,41,44,32,100,116,
121,112,101,61,110,112,116,121,112,101,41,10,
// '        data = numpy_array.reshape(paramsnum, -1)\n
32,32,32,32,32,32,32,32,100,97,116,97,32,61,32,110,117,109,112,121,95,97,114,
114,97,121,46,114,101,115,104,97,112,101,40,112,97,114,97,109,115,110,117,109,
44,32,45,49,41,10,
// '    else:\n
32,32,32,32,101,108,115,101,58,10,
// '        data = np.frombuffer(ffi.buffer(inputd[0], ffi.sizeof(inputtype)*insize*paramsnum), dtype=nptype)\n
32,32,32,32,32,32,32,32,100,97,116,97,32,61,32,110,112,46,102,114,111,109,98,
117,102,102,101,114,40,102,102,105,46,98,117,102,102,101,114,40,105,110,112,
117,116,100,91,48,93,44,32,102,102,105,46,115,105,122,101,111,102,40,105,110,
112,117,116,116,121,112,101,41,42,105,110,115,105,122,101,42,112,97,114,97,109,
115,110,117,109,41,44,32,100,116,121,112,101,61,110,112,116,121,112,101,41,10,
// "    code_string = '''\n
32,32,32,32,99,111,100,101,95,115,116,114,105,110,103,32,61,32,39,39,39,10,
// 'try:\n
116,114,121,58,10,
// "    from '''+funcname[0]+''' import '''+funcname[1]+'''\n
32,32,32,32,102,114,111,109,32,39,39,39,43,102,117,110,99,110,97,109,101,91,
48,93,43,39,39,39,32,105,109,112,111,114,116,32,39,39,39,43,102,117,110,99,110,
97,109,101,91,49,93,43,39,39,39,10,
// '    if functions.DEBUG:\n
32,32,32,32,105,102,32,102,117,110,99,116,105,111,110,115,46,68,69,66,85,71,
58,10,
// "      mypath = get_module_path(funcname[0]+'.'+funcname[1])\n
32,32,32,32,32,32,109,121,112,97,116,104,32,61,32,103,101,116,95,109,111,100,
117,108,101,95,112,97,116,104,40,102,117,110,99,110,97,109,101,91,48,93,43,39,
46,39,43,102,117,110,99,110,97,109,101,91,49,93,41,10,
// '      #print(mypath)\n
32,32,32,32,32,32,35,112,114,105,110,116,40,109,121,112,97,116,104,41,10,
// '      if mypath not in checksums:\n
32,32,32,32,32,32,105,102,32,109,121,112,97,116,104,32,110,111,116,32,105,110,
32,99,104,101,99,107,115,117,109,115,58,10,
// '        checksums[mypath] = calculate_checksum(mypath)\n
32,32,32,32,32,32,32,32,99,104,101,99,107,115,117,109,115,91,109,121,112,97,
116,104,93,32,61,32,99,97,108,99,117,108,97,116,101,95,99,104,101,99,107,115,
117,109,40,109,121,112,97,116,104,41,10,
// '      elif mypath in checksums:\n
32,32,32,32,32,32,101,108,105,102,32,109,121,112,97,116,104,32,105,110,32,99,
104,101,99,107,115,117,109,115,58,10,
// '        csum = calculate_checksum(mypath)\n
32,32,32,32,32,32,32,32,99,115,117,109,32,61,32,99,97,108,99,117,108,97,116,
101,95,99,104,101,99,107,115,117,109,40,109,121,112,97,116,104,41,10,
// '        if checksums[mypath] != csum:\n
32,32,32,32,32,32,32,32,105,102,32,99,104,101,99,107,115,117,109,115,91,109,
121,112,97,116,104,93,32,33,61,32,99,115,117,109,58,10,
// "          importlib.reload('''+funcname[1]+''')\n
32,32,32,32,32,32,32,32,32,32,105,109,112,111,114,116,108,105,98,46,114,101,
108,111,97,100,40,39,39,39,43,102,117,110,99,110,97,109,101,91,49,93,43,39,39,
39,41,10,
// '          checksums[mypath] = csum\n
32,32,32,32,32,32,32,32,32,32,99,104,101,99,107,115,117,109,115,91,109,121,112,
97,116,104,93,32,61,32,99,115,117,109,10,
// "    result = '''+funcname[1]+'''.'''+funcname[2]+'''(data)\n
32,32,32,32,114,101,115,117,108,116,32,61,32,39,39,39,43,102,117,110,99,110,
97,109,101,91,49,93,43,39,39,39,46,39,39,39,43,102,117,110,99,110,97,109,101,
91,50,93,43,39,39,39,40,100,97,116,97,41,10,
// '    result = next(result)\n
32,32,32,32,114,101,115,117,108,116,32,61,32,110,101,120,116,40,114,101,115,
117,108,116,41,10,
// '    if resultnum==1:\n
32,32,32,32,105,102,32,114,101,115,117,108,116,110,117,109,61,61,49,58,10,
// '        retlen = result.size\n
32,32,32,32,32,32,32,32,114,101,116,108,101,110,32,61,32,114,101,115,117,108,
116,46,115,105,122,101,10,
// '    else:\n
32,32,32,32,101,108,115,101,58,10,
// '        retlen = result[0].size\n
32,32,32,32,32,32,32,32,114,101,116,108,101,110,32,61,32,114,101,115,117,108,
116,91,48,93,46,115,105,122,101,10,
// '    resultarrays[0].size = retlen\n
32,32,32,32,114,101,115,117,108,116,97,114,114,97,121,115,91,48,93,46,115,105,
122,101,32,61,32,114,101,116,108,101,110,10,
// '    if resultnum == 1 and retlen == 1:\n
32,32,32,32,105,102,32,114,101,115,117,108,116,110,117,109,32,61,61,32,49,32,
97,110,100,32,114,101,116,108,101,110,32,61,61,32,49,58,10,
// '      for i in range(resultnum):\n
32,32,32,32,32,32,102,111,114,32,105,32,105,110,32,114,97,110,103,101,40,114,
101,115,117,108,116,110,117,109,41,58,10,
// '         if resultarrays[i].type == 0:\n
32,32,32,32,32,32,32,32,32,105,102,32,114,101,115,117,108,116,97,114,114,97,
121,115,91,105,93,46,116,121,112,101,32,61,61,32,48,58,10,
// '             resultarrays[i].array = ffi.cast("char**", lib.malloc(retlen*ffi.sizeof("char *")))\n
32,32,32,32,32,32,32,32,32,32,32,32,32,114,101,115,117,108,116,97,114,114,97,
121,115,91,105,93,46,97,114,114,97,121,32,61,32,102,102,105,46,99,97,115,116,
40,34,99,104,97,114,42,42,34,44,32,108,105,98,46,109,97,108,108,111,99,40,114,
101,116,108,101,110,42,102,102,105,46,115,105,122,101,111,102,40,34,99,104,97,
114,32,42,34,41,41,41,10,
// '             outputd[i] = ffi.cast("char **", resultarrays[i].array )\n
32,32,32,32,32,32,32,32,32,32,32,32,32,111,117,116,112,117,116,100,91,105,93,
32,61,32,102,102,105,46,99,97,115,116,40,34,99,104,97,114,32,42,42,34,44,32,
114,101,115,117,108,116,97,114,114,97,121,115,91,105,93,46,97,114,114,97,121,
32,41,10,
// '         elif resultarrays[i].type == 1:\n
32,32,32,32,32,32,32,32,32,101,108,105,102,32,114,101,115,117,108,116,97,114,
114,97,121,115,91,105,93,46,116,121,112,101,32,61,61,32,49,58,10,
// '             resultarrays[i].array = ffi.cast("int*", lib.malloc(retlen*ffi.sizeof("int")))\n
32,32,32,32,32,32,32,32,32,32,32,32,32,114,101,115,117,108,116,97,114,114,97,
121,115,91,105,93,46,97,114,114,97,121,32,61,32,102,102,105,46,99,97,115,116,
40,34,105,110,116,42,34,44,32,108,105,98,46,109,97,108,108,111,99,40,114,101,
116,108,101,110,42,102,102,105,46,115,105,122,101,111,102,40,34,105,110,116,
34,41,41,41,10,
// '             outputd[i] = ffi.cast("int *", resultarrays[i].array )\n
32,32,32,32,32,32,32,32,32,32,32,32,32,111,117,116,112,117,116,100,91,105,93,
32,61,32,102,102,105,46,99,97,115,116,40,34,105,110,116,32,42,34,44,32,114,101,
115,117,108,116,97,114,114,97,121,115,91,105,93,46,97,114,114,97,121,32,41,10,
// '         elif resultarrays[i].type == 2:\n
32,32,32,32,32,32,32,32,32,101,108,105,102,32,114,101,115,117,108,116,97,114,
114,97,121,115,91,105,93,46,116,121,112,101,32,61,61,32,50,58,10,
// '             resultarrays[i].array = ffi.cast("double*", lib.malloc(retlen*ffi.sizeof("double")))\n
32,32,32,32,32,32,32,32,32,32,32,32,32,114,101,115,117,108,116,97,114,114,97,
121,115,91,105,93,46,97,114,114,97,121,32,61,32,102,102,105,46,99,97,115,116,
40,34,100,111,117,98,108,101,42,34,44,32,108,105,98,46,109,97,108,108,111,99,
40,114,101,116,108,101,110,42,102,102,105,46,115,105,122,101,111,102,40,34,100,
111,117,98,108,101,34,41,41,41,10,
// '             outputd[i] = ffi.cast("double *", resultarrays[i].array)\n
32,32,32,32,32,32,32,32,32,32,32,32,32,111,117,116,112,117,116,100,91,105,93,
32,61,32,102,102,105,46,99,97,115,116,40,34,100,111,117,98,108,101,32,42,34,
44,32,114,101,115,117,108,116,97,114,114,97,121,115,91,105,93,46,97,114,114,
97,121,41,10,
// '    if resultnum == 1 and retlen == 1:\n
32,32,32,32,105,102,32,114,101,115,117,108,116,110,117,109,32,61,61,32,49,32,
97,110,100,32,114,101,116,108,101,110,32,61,61,32,49,58,10,
// '       outputd[0][0] = ffi.from_buffer(result[0])\n
32,32,32,32,32,32,32,111,117,116,112,117,116,100,91,48,93,91,48,93,32,61,32,
102,102,105,46,102,114,111,109,95,98,117,102,102,101,114,40,114,101,115,117,
108,116,91,48,93,41,10,
// '       #resultarrays[0].array[0] = ffi.from_buffer(result)\n
32,32,32,32,32,32,32,35,114,101,115,117,108,116,97,114,114,97,121,115,91,48,
93,46,97,114,114,97,121,91,48,93,32,61,32,102,102,105,46,102,114,111,109,95,
98,117,102,102,101,114,40,114,101,115,117,108,116,41,10,
// '    elif resultnum == 1:\n
32,32,32,32,101,108,105,102,32,114,101,115,117,108,116,110,117,109,32,61,61,
32,49,58,10,
// '        resultarrays[0].array = ffi.from_buffer(result)\n
32,32,32,32,32,32,32,32,114,101,115,117,108,116,97,114,114,97,121,115,91,48,
93,46,97,114,114,97,121,32,61,32,102,102,105,46,102,114,111,109,95,98,117,102,
102,101,114,40,114,101,115,117,108,116,41,10,
// '    else:\n
32,32,32,32,101,108,115,101,58,10,
// '      for r in range(resultnum):\n
32,32,32,32,32,32,102,111,114,32,114,32,105,110,32,114,97,110,103,101,40,114,
101,115,117,108,116,110,117,109,41,58,10,
// '        resultarrays[r].array = ffi.from_buffer(result[r])\n
32,32,32,32,32,32,32,32,114,101,115,117,108,116,97,114,114,97,121,115,91,114,
93,46,97,114,114,97,121,32,61,32,102,102,105,46,102,114,111,109,95,98,117,102,
102,101,114,40,114,101,115,117,108,116,91,114,93,41,10,
// 'except Exception as e:\n
101,120,99,101,112,116,32,69,120,99,101,112,116,105,111,110,32,97,115,32,101,
58,10,
// "    errormessage[0] = lib.strdup(ffi.from_buffer(memoryview(b'UDFError '+ funcname[0].encode()+b'.'+funcname[1].encode()+b'.'+funcname[2].upper().encode() + b': ' + traceback.format_exc().encode())))\n
32,32,32,32,101,114,114,111,114,109,101,115,115,97,103,101,91,48,93,32,61,32,
108,105,98,46,115,116,114,100,117,112,40,102,102,105,46,102,114,111,109,95,98,
117,102,102,101,114,40,109,101,109,111,114,121,118,105,101,119,40,98,39,85,68,
70,69,114,114,111,114,32,39,43,32,102,117,110,99,110,97,109,101,91,48,93,46,
101,110,99,111,100,101,40,41,43,98,39,46,39,43,102,117,110,99,110,97,109,101,
91,49,93,46,101,110,99,111,100,101,40,41,43,98,39,46,39,43,102,117,110,99,110,
97,109,101,91,50,93,46,117,112,112,101,114,40,41,46,101,110,99,111,100,101,40,
41,32,43,32,98,39,58,32,39,32,43,32,116,114,97,99,101,98,97,99,107,46,102,111,
114,109,97,116,95,101,120,99,40,41,46,101,110,99,111,100,101,40,41,41,41,41,
10,
// '    errorm = 1\n
32,32,32,32,101,114,114,111,114,109,32,61,32,49,10,
// "    '''\n
32,32,32,32,39,39,39,10,
// '    print (code_string)\n
32,32,32,32,112,114,105,110,116,32,40,99,111,100,101,95,115,116,114,105,110,
103,41,10,
// '    exec(code_string)\n
32,32,32,32,101,120,101,99,40,99,111,100,101,95,115,116,114,105,110,103,41,10,
// '    \n
32,32,32,32,10,
// '    #lib.free(combined_array)\n
32,32,32,32,35,108,105,98,46,102,114,101,101,40,99,111,109,98,105,110,101,100,
95,97,114,114,97,121,41,10,
// '    #del combined_array\n
32,32,32,32,35,100,101,108,32,99,111,109,98,105,110,101,100,95,97,114,114,97,
121,10,
// '    #del data\n
32,32,32,32,35,100,101,108,32,100,97,116,97,10,
// '    #del numpy_array\n
32,32,32,32,35,100,101,108,32,110,117,109,112,121,95,97,114,114,97,121,10,
// '    if errorm == 1:\n
32,32,32,32,105,102,32,101,114,114,111,114,109,32,61,61,32,49,58,10,
// '        return 0\n
32,32,32,32,32,32,32,32,114,101,116,117,114,110,32,48,10,
// '    else:\n
32,32,32,32,101,108,115,101,58,10,
// '        return 1\n
32,32,32,32,32,32,32,32,114,101,116,117,114,110,32,49,10,
// '\n
10,
// '\n
10,
// '\n
10,
// '\n
10,
// '\n
10,
// '@ffi.def_extern()\n
64,102,102,105,46,100,101,102,95,101,120,116,101,114,110,40,41,10,
// 'def numpyudfwrapperwithtests(funcname, paramsnum, arrays, resultnum, resultarrays, insize, extraparams):\n
100,101,102,32,110,117,109,112,121,117,100,102,119,114,97,112,112,101,114,119,
105,116,104,116,101,115,116,115,40,102,117,110,99,110,97,109,101,44,32,112,97,
114,97,109,115,110,117,109,44,32,97,114,114,97,121,115,44,32,114,101,115,117,
108,116,110,117,109,44,32,114,101,115,117,108,116,97,114,114,97,121,115,44,32,
105,110,115,105,122,101,44,32,101,120,116,114,97,112,97,114,97,109,115,41,58,
10,
// '    inputd = [None]*paramsnum\n
32,32,32,32,105,110,112,117,116,100,32,61,32,91,78,111,110,101,93,42,112,97,
114,97,109,115,110,117,109,10,
// '    outputd = [None]*resultnum\n
32,32,32,32,111,117,116,112,117,116,100,32,61,32,91,78,111,110,101,93,42,114,
101,115,117,108,116,110,117,109,10,
// '    funcname = ffi.string(funcname).decode()\n
32,32,32,32,102,117,110,99,110,97,109,101,32,61,32,102,102,105,46,115,116,114,
105,110,103,40,102,117,110,99,110,97,109,101,41,46,100,101,99,111,100,101,40,
41,10,
// "    funcname = funcname.split('.')\n
32,32,32,32,102,117,110,99,110,97,109,101,32,61,32,102,117,110,99,110,97,109,
101,46,115,112,108,105,116,40,39,46,39,41,10,
// '    for i in range(paramsnum):\n
32,32,32,32,102,111,114,32,105,32,105,110,32,114,97,110,103,101,40,112,97,114,
97,109,115,110,117,109,41,58,10,
// '       if arrays[i].type == 0:\n
32,32,32,32,32,32,32,105,102,32,97,114,114,97,121,115,91,105,93,46,116,121,112,
101,32,61,61,32,48,58,10,
// '           inputd[i] = ffi.cast("char **", arrays[i].array )\n
32,32,32,32,32,32,32,32,32,32,32,105,110,112,117,116,100,91,105,93,32,61,32,
102,102,105,46,99,97,115,116,40,34,99,104,97,114,32,42,42,34,44,32,97,114,114,
97,121,115,91,105,93,46,97,114,114,97,121,32,41,10,
// '       elif arrays[i].type == 1:\n
32,32,32,32,32,32,32,101,108,105,102,32,97,114,114,97,121,115,91,105,93,46,116,
121,112,101,32,61,61,32,49,58,10,
// '           inputd[i] = ffi.cast("int *", arrays[i].array )\n
32,32,32,32,32,32,32,32,32,32,32,105,110,112,117,116,100,91,105,93,32,61,32,
102,102,105,46,99,97,115,116,40,34,105,110,116,32,42,34,44,32,97,114,114,97,
121,115,91,105,93,46,97,114,114,97,121,32,41,10,
// '       elif arrays[i].type == 2:\n
32,32,32,32,32,32,32,101,108,105,102,32,97,114,114,97,121,115,91,105,93,46,116,
121,112,101,32,61,61,32,50,58,10,
// '           inputd[i] = ffi.cast("double *", arrays[i].array)\n
32,32,32,32,32,32,32,32,32,32,32,105,110,112,117,116,100,91,105,93,32,61,32,
102,102,105,46,99,97,115,116,40,34,100,111,117,98,108,101,32,42,34,44,32,97,
114,114,97,121,115,91,105,93,46,97,114,114,97,121,41,10,
// '    retlen = 1\n
32,32,32,32,114,101,116,108,101,110,32,61,32,49,10,
// '    resultarrays[0].size = 1\n
32,32,32,32,114,101,115,117,108,116,97,114,114,97,121,115,91,48,93,46,115,105,
122,101,32,61,32,49,10,
// '    for i in range(resultnum):\n
32,32,32,32,102,111,114,32,105,32,105,110,32,114,97,110,103,101,40,114,101,115,
117,108,116,110,117,109,41,58,10,
// '         if resultarrays[i].type == 0:\n
32,32,32,32,32,32,32,32,32,105,102,32,114,101,115,117,108,116,97,114,114,97,
121,115,91,105,93,46,116,121,112,101,32,61,61,32,48,58,10,
// '             resultarrays[i].array = ffi.cast("char**", lib.malloc(retlen*ffi.sizeof("char *")))\n
32,32,32,32,32,32,32,32,32,32,32,32,32,114,101,115,117,108,116,97,114,114,97,
121,115,91,105,93,46,97,114,114,97,121,32,61,32,102,102,105,46,99,97,115,116,
40,34,99,104,97,114,42,42,34,44,32,108,105,98,46,109,97,108,108,111,99,40,114,
101,116,108,101,110,42,102,102,105,46,115,105,122,101,111,102,40,34,99,104,97,
114,32,42,34,41,41,41,10,
// '             outputd[i] = ffi.cast("char **", resultarrays[i].array )\n
32,32,32,32,32,32,32,32,32,32,32,32,32,111,117,116,112,117,116,100,91,105,93,
32,61,32,102,102,105,46,99,97,115,116,40,34,99,104,97,114,32,42,42,34,44,32,
114,101,115,117,108,116,97,114,114,97,121,115,91,105,93,46,97,114,114,97,121,
32,41,10,
// '         elif resultarrays[i].type == 1:\n
32,32,32,32,32,32,32,32,32,101,108,105,102,32,114,101,115,117,108,116,97,114,
114,97,121,115,91,105,93,46,116,121,112,101,32,61,61,32,49,58,10,
// '             resultarrays[i].array = ffi.cast("int*", lib.malloc(retlen*ffi.sizeof("int")))\n
32,32,32,32,32,32,32,32,32,32,32,32,32,114,101,115,117,108,116,97,114,114,97,
121,115,91,105,93,46,97,114,114,97,121,32,61,32,102,102,105,46,99,97,115,116,
40,34,105,110,116,42,34,44,32,108,105,98,46,109,97,108,108,111,99,40,114,101,
116,108,101,110,42,102,102,105,46,115,105,122,101,111,102,40,34,105,110,116,
34,41,41,41,10,
// '             outputd[i] = ffi.cast("int *", resultarrays[i].array )\n
32,32,32,32,32,32,32,32,32,32,32,32,32,111,117,116,112,117,116,100,91,105,93,
32,61,32,102,102,105,46,99,97,115,116,40,34,105,110,116,32,42,34,44,32,114,101,
115,117,108,116,97,114,114,97,121,115,91,105,93,46,97,114,114,97,121,32,41,10,
// '         elif resultarrays[i].type == 2:\n
32,32,32,32,32,32,32,32,32,101,108,105,102,32,114,101,115,117,108,116,97,114,
114,97,121,115,91,105,93,46,116,121,112,101,32,61,61,32,50,58,10,
// '             resultarrays[i].array = ffi.cast("double*", lib.malloc(retlen*ffi.sizeof("double")))\n
32,32,32,32,32,32,32,32,32,32,32,32,32,114,101,115,117,108,116,97,114,114,97,
121,115,91,105,93,46,97,114,114,97,121,32,61,32,102,102,105,46,99,97,115,116,
40,34,100,111,117,98,108,101,42,34,44,32,108,105,98,46,109,97,108,108,111,99,
40,114,101,116,108,101,110,42,102,102,105,46,115,105,122,101,111,102,40,34,100,
111,117,98,108,101,34,41,41,41,10,
// '             outputd[i] = ffi.cast("double *", resultarrays[i].array)\n
32,32,32,32,32,32,32,32,32,32,32,32,32,111,117,116,112,117,116,100,91,105,93,
32,61,32,102,102,105,46,99,97,115,116,40,34,100,111,117,98,108,101,32,42,34,
44,32,114,101,115,117,108,116,97,114,114,97,121,115,91,105,93,46,97,114,114,
97,121,41,10,
// '\n
10,
// '    outputd[0][0] = pearson_correlation(inputd[0],inputd[1],insize)\n
32,32,32,32,111,117,116,112,117,116,100,91,48,93,91,48,93,32,61,32,112,101,97,
114,115,111,110,95,99,111,114,114,101,108,97,116,105,111,110,40,105,110,112,
117,116,100,91,48,93,44,105,110,112,117,116,100,91,49,93,44,105,110,115,105,
122,101,41,10,
// '    return 1\n
32,32,32,32,114,101,116,117,114,110,32,49,10,
// '    #arrays[i].array = ffi.cast("double*", lib.realloc(arrays[i].array, insize*paramsnum*ffi.sizeof("double")))\n
32,32,32,32,35,97,114,114,97,121,115,91,105,93,46,97,114,114,97,121,32,61,32,
102,102,105,46,99,97,115,116,40,34,100,111,117,98,108,101,42,34,44,32,108,105,
98,46,114,101,97,108,108,111,99,40,97,114,114,97,121,115,91,105,93,46,97,114,
114,97,121,44,32,105,110,115,105,122,101,42,112,97,114,97,109,115,110,117,109,
42,102,102,105,46,115,105,122,101,111,102,40,34,100,111,117,98,108,101,34,41,
41,41,10,
// '    #inputd[i] = ffi.cast("double", arrays[i].array )\n
32,32,32,32,35,105,110,112,117,116,100,91,105,93,32,61,32,102,102,105,46,99,
97,115,116,40,34,100,111,117,98,108,101,34,44,32,97,114,114,97,121,115,91,105,
93,46,97,114,114,97,121,32,41,10,
// '    #inputd[0] = lib.realloc(inputd[0],insize*paramsnum*ffi.sizeof("float"))\n
32,32,32,32,35,105,110,112,117,116,100,91,48,93,32,61,32,108,105,98,46,114,101,
97,108,108,111,99,40,105,110,112,117,116,100,91,48,93,44,105,110,115,105,122,
101,42,112,97,114,97,109,115,110,117,109,42,102,102,105,46,115,105,122,101,111,
102,40,34,102,108,111,97,116,34,41,41,10,
// '    #combined_array = ffi.new("float[]", insize*2)\n
32,32,32,32,35,99,111,109,98,105,110,101,100,95,97,114,114,97,121,32,61,32,102,
102,105,46,110,101,119,40,34,102,108,111,97,116,91,93,34,44,32,105,110,115,105,
122,101,42,50,41,10,
// '    float_size = insize\n
32,32,32,32,102,108,111,97,116,95,115,105,122,101,32,61,32,105,110,115,105,122,
101,10,
// '    #combined_array = ffi.new("float[]",1)\n
32,32,32,32,35,99,111,109,98,105,110,101,100,95,97,114,114,97,121,32,61,32,102,
102,105,46,110,101,119,40,34,102,108,111,97,116,91,93,34,44,49,41,10,
// '    #combined_array = ffi.cast("float*", lib.malloc(insize*2 * ffi.sizeof("float")))\n
32,32,32,32,35,99,111,109,98,105,110,101,100,95,97,114,114,97,121,32,61,32,102,
102,105,46,99,97,115,116,40,34,102,108,111,97,116,42,34,44,32,108,105,98,46,
109,97,108,108,111,99,40,105,110,115,105,122,101,42,50,32,42,32,102,102,105,
46,115,105,122,101,111,102,40,34,102,108,111,97,116,34,41,41,41,10,
// '    #combined_array = ffi.new("float[]", float_size * 2)\n
32,32,32,32,35,99,111,109,98,105,110,101,100,95,97,114,114,97,121,32,61,32,102,
102,105,46,110,101,119,40,34,102,108,111,97,116,91,93,34,44,32,102,108,111,97,
116,95,115,105,122,101,32,42,32,50,41,10,
// '\n
10,
// '    # Use memmove to copy data from float_pointer1 to the new array\n
32,32,32,32,35,32,85,115,101,32,109,101,109,109,111,118,101,32,116,111,32,99,
111,112,121,32,100,97,116,97,32,102,114,111,109,32,102,108,111,97,116,95,112,
111,105,110,116,101,114,49,32,116,111,32,116,104,101,32,110,101,119,32,97,114,
114,97,121,10,
// '    #ffi.memmove(combined_array, arrays[0].array, float_size * ffi.sizeof("float"))\n
32,32,32,32,35,102,102,105,46,109,101,109,109,111,118,101,40,99,111,109,98,105,
110,101,100,95,97,114,114,97,121,44,32,97,114,114,97,121,115,91,48,93,46,97,
114,114,97,121,44,32,102,108,111,97,116,95,115,105,122,101,32,42,32,102,102,
105,46,115,105,122,101,111,102,40,34,102,108,111,97,116,34,41,41,10,
// '\n
10,
// '    # Use memmove to copy data from float_pointer2 to the new array\n
32,32,32,32,35,32,85,115,101,32,109,101,109,109,111,118,101,32,116,111,32,99,
111,112,121,32,100,97,116,97,32,102,114,111,109,32,102,108,111,97,116,95,112,
111,105,110,116,101,114,50,32,116,111,32,116,104,101,32,110,101,119,32,97,114,
114,97,121,10,
// '    #ffi.memmove(ffi.cast("char*", combined_array) + float_size * ffi.sizeof("float"), arrays[1].array, float_size * ffi.sizeof("float"))\n
32,32,32,32,35,102,102,105,46,109,101,109,109,111,118,101,40,102,102,105,46,
99,97,115,116,40,34,99,104,97,114,42,34,44,32,99,111,109,98,105,110,101,100,
95,97,114,114,97,121,41,32,43,32,102,108,111,97,116,95,115,105,122,101,32,42,
32,102,102,105,46,115,105,122,101,111,102,40,34,102,108,111,97,116,34,41,44,
32,97,114,114,97,121,115,91,49,93,46,97,114,114,97,121,44,32,102,108,111,97,
116,95,115,105,122,101,32,42,32,102,102,105,46,115,105,122,101,111,102,40,34,
102,108,111,97,116,34,41,41,10,
// '\n
10,
// '    #for i in range(insize*2):\n
32,32,32,32,35,102,111,114,32,105,32,105,110,32,114,97,110,103,101,40,105,110,
115,105,122,101,42,50,41,58,10,
// '    #    if i<insize:\n
32,32,32,32,35,32,32,32,32,105,102,32,105,60,105,110,115,105,122,101,58,10,
// '    #        combined_array[i] = inputd[0][i]\n
32,32,32,32,35,32,32,32,32,32,32,32,32,99,111,109,98,105,110,101,100,95,97,114,
114,97,121,91,105,93,32,61,32,105,110,112,117,116,100,91,48,93,91,105,93,10,
// '    #    else:\n
32,32,32,32,35,32,32,32,32,101,108,115,101,58,10,
// '    #        combined_array[i] = inputd[1][i-insize]\n
32,32,32,32,35,32,32,32,32,32,32,32,32,99,111,109,98,105,110,101,100,95,97,114,
114,97,121,91,105,93,32,61,32,105,110,112,117,116,100,91,49,93,91,105,45,105,
110,115,105,122,101,93,10,
// '\n
10,
// '    #combined_array[0:insize] = [inputd[0][x] for x in range(insize)]\n
32,32,32,32,35,99,111,109,98,105,110,101,100,95,97,114,114,97,121,91,48,58,105,
110,115,105,122,101,93,32,61,32,91,105,110,112,117,116,100,91,48,93,91,120,93,
32,102,111,114,32,120,32,105,110,32,114,97,110,103,101,40,105,110,115,105,122,
101,41,93,10,
// '    #combined_array[insize:insize*2] = [inputd[1][x] for x in range(insize)]\n
32,32,32,32,35,99,111,109,98,105,110,101,100,95,97,114,114,97,121,91,105,110,
115,105,122,101,58,105,110,115,105,122,101,42,50,93,32,61,32,91,105,110,112,
117,116,100,91,49,93,91,120,93,32,102,111,114,32,120,32,105,110,32,114,97,110,
103,101,40,105,110,115,105,122,101,41,93,10,
// '    #inputd[0][insize:insize*2] = inputd[1]\n
32,32,32,32,35,105,110,112,117,116,100,91,48,93,91,105,110,115,105,122,101,58,
105,110,115,105,122,101,42,50,93,32,61,32,105,110,112,117,116,100,91,49,93,10,
// "    #print('kiki')\n
32,32,32,32,35,112,114,105,110,116,40,39,107,105,107,105,39,41,10,
// '    #numpy_array = np.frombuffer(ffi.buffer(combined_array), dtype=np.float32)\n
32,32,32,32,35,110,117,109,112,121,95,97,114,114,97,121,32,61,32,110,112,46,
102,114,111,109,98,117,102,102,101,114,40,102,102,105,46,98,117,102,102,101,
114,40,99,111,109,98,105,110,101,100,95,97,114,114,97,121,41,44,32,100,116,121,
112,101,61,110,112,46,102,108,111,97,116,51,50,41,10,
// '    #outputd[0][0] = -1\n
32,32,32,32,35,111,117,116,112,117,116,100,91,48,93,91,48,93,32,61,32,45,49,
10,
// '    #return 1\n
32,32,32,32,35,114,101,116,117,114,110,32,49,10,
// '    numpy_array1 = np.frombuffer(ffi.buffer(arrays[0].array, insize*8), dtype=np.float64)\n
32,32,32,32,110,117,109,112,121,95,97,114,114,97,121,49,32,61,32,110,112,46,
102,114,111,109,98,117,102,102,101,114,40,102,102,105,46,98,117,102,102,101,
114,40,97,114,114,97,121,115,91,48,93,46,97,114,114,97,121,44,32,105,110,115,
105,122,101,42,56,41,44,32,100,116,121,112,101,61,110,112,46,102,108,111,97,
116,54,52,41,10,
// '    numpy_array2 = np.frombuffer(ffi.buffer(arrays[1].array, insize*8), dtype=np.float64)\n
32,32,32,32,110,117,109,112,121,95,97,114,114,97,121,50,32,61,32,110,112,46,
102,114,111,109,98,117,102,102,101,114,40,102,102,105,46,98,117,102,102,101,
114,40,97,114,114,97,121,115,91,49,93,46,97,114,114,97,121,44,32,105,110,115,
105,122,101,42,56,41,44,32,100,116,121,112,101,61,110,112,46,102,108,111,97,
116,54,52,41,10,
// '    numpy_array3 = numpy_array1*2\n
32,32,32,32,110,117,109,112,121,95,97,114,114,97,121,51,32,61,32,110,117,109,
112,121,95,97,114,114,97,121,49,42,50,10,
// '    numpy_array4 = numpy_array2*2\n
32,32,32,32,110,117,109,112,121,95,97,114,114,97,121,52,32,61,32,110,117,109,
112,121,95,97,114,114,97,121,50,42,50,10,
// '    #data = numpy_array.reshape(2, -1)\n
32,32,32,32,35,100,97,116,97,32,61,32,110,117,109,112,121,95,97,114,114,97,121,
46,114,101,115,104,97,112,101,40,50,44,32,45,49,41,10,
// '    #print(np.corrcoef(data[0], data[1])[0, 1])\n
32,32,32,32,35,112,114,105,110,116,40,110,112,46,99,111,114,114,99,111,101,102,
40,100,97,116,97,91,48,93,44,32,100,97,116,97,91,49,93,41,91,48,44,32,49,93,
41,10,
// '    #outputd[0][0] = np.corrcoef(data[0], data[1])[0, 1]\n
32,32,32,32,35,111,117,116,112,117,116,100,91,48,93,91,48,93,32,61,32,110,112,
46,99,111,114,114,99,111,101,102,40,100,97,116,97,91,48,93,44,32,100,97,116,
97,91,49,93,41,91,48,44,32,49,93,10,
// '    outputd[0][0] = np.corrcoef(numpy_array3, numpy_array4)[0, 1]\n
32,32,32,32,111,117,116,112,117,116,100,91,48,93,91,48,93,32,61,32,110,112,46,
99,111,114,114,99,111,101,102,40,110,117,109,112,121,95,97,114,114,97,121,51,
44,32,110,117,109,112,121,95,97,114,114,97,121,52,41,91,48,44,32,49,93,10,
// '    #ffi.free(combined_array)\n
32,32,32,32,35,102,102,105,46,102,114,101,101,40,99,111,109,98,105,110,101,100,
95,97,114,114,97,121,41,10,
// '    #lib.free(combined_array)\n
32,32,32,32,35,108,105,98,46,102,114,101,101,40,99,111,109,98,105,110,101,100,
95,97,114,114,97,121,41,10,
// '    #del combined_array\n
32,32,32,32,35,100,101,108,32,99,111,109,98,105,110,101,100,95,97,114,114,97,
121,10,
// '    #del data\n
32,32,32,32,35,100,101,108,32,100,97,116,97,10,
// '    del numpy_array\n
32,32,32,32,100,101,108,32,110,117,109,112,121,95,97,114,114,97,121,10,
// '    return 1\n
32,32,32,32,114,101,116,117,114,110,32,49,10,
// '\n
10,
// '\n
10,
// '@ffi.def_extern()\n
64,102,102,105,46,100,101,102,95,101,120,116,101,114,110,40,41,10,
// 'def fusionwrapper(fusiblecomponent, nops, paramsnum, arrays, resultdouble, resultint, resultstring, resultnum, resultarrays, insize, extraparams, fusedudftype, isliteral):\n
100,101,102,32,102,117,115,105,111,110,119,114,97,112,112,101,114,40,102,117,
115,105,98,108,101,99,111,109,112,111,110,101,110,116,44,32,110,111,112,115,
44,32,112,97,114,97,109,115,110,117,109,44,32,97,114,114,97,121,115,44,32,114,
101,115,117,108,116,100,111,117,98,108,101,44,32,114,101,115,117,108,116,105,
110,116,44,32,114,101,115,117,108,116,115,116,114,105,110,103,44,32,114,101,
115,117,108,116,110,117,109,44,32,114,101,115,117,108,116,97,114,114,97,121,
115,44,32,105,110,115,105,122,101,44,32,101,120,116,114,97,112,97,114,97,109,
115,44,32,102,117,115,101,100,117,100,102,116,121,112,101,44,32,105,115,108,
105,116,101,114,97,108,41,58,10,
// '    inputd = [None]*paramsnum\n
32,32,32,32,105,110,112,117,116,100,32,61,32,91,78,111,110,101,93,42,112,97,
114,97,109,115,110,117,109,10,
// '    outputd = [None]*resultnum\n
32,32,32,32,111,117,116,112,117,116,100,32,61,32,91,78,111,110,101,93,42,114,
101,115,117,108,116,110,117,109,10,
// '    for i in range(paramsnum):\n
32,32,32,32,102,111,114,32,105,32,105,110,32,114,97,110,103,101,40,112,97,114,
97,109,115,110,117,109,41,58,10,
// '       if arrays[i].type == 0:\n
32,32,32,32,32,32,32,105,102,32,97,114,114,97,121,115,91,105,93,46,116,121,112,
101,32,61,61,32,48,58,10,
// '           inputd[i] = ffi.cast("char **", arrays[i].array )\n
32,32,32,32,32,32,32,32,32,32,32,105,110,112,117,116,100,91,105,93,32,61,32,
102,102,105,46,99,97,115,116,40,34,99,104,97,114,32,42,42,34,44,32,97,114,114,
97,121,115,91,105,93,46,97,114,114,97,121,32,41,10,
// '       elif arrays[i].type == 1:\n
32,32,32,32,32,32,32,101,108,105,102,32,97,114,114,97,121,115,91,105,93,46,116,
121,112,101,32,61,61,32,49,58,10,
// '           inputd[i] = ffi.cast("int *", arrays[i].array )\n
32,32,32,32,32,32,32,32,32,32,32,105,110,112,117,116,100,91,105,93,32,61,32,
102,102,105,46,99,97,115,116,40,34,105,110,116,32,42,34,44,32,97,114,114,97,
121,115,91,105,93,46,97,114,114,97,121,32,41,10,
// '       elif arrays[i].type == 2:\n
32,32,32,32,32,32,32,101,108,105,102,32,97,114,114,97,121,115,91,105,93,46,116,
121,112,101,32,61,61,32,50,58,10,
// '           inputd[i] = ffi.cast("double *", arrays[i].array)\n
32,32,32,32,32,32,32,32,32,32,32,105,110,112,117,116,100,91,105,93,32,61,32,
102,102,105,46,99,97,115,116,40,34,100,111,117,98,108,101,32,42,34,44,32,97,
114,114,97,121,115,91,105,93,46,97,114,114,97,121,41,10,
// '    if fusedudftype == 1:\n
32,32,32,32,105,102,32,102,117,115,101,100,117,100,102,116,121,112,101,32,61,
61,32,49,58,10,
// '        scalarfusionwrapper(fusiblecomponent, nops, paramsnum, arrays, resultdouble, resultint, resultstring, insize, isliteral)\n
32,32,32,32,32,32,32,32,115,99,97,108,97,114,102,117,115,105,111,110,119,114,
97,112,112,101,114,40,102,117,115,105,98,108,101,99,111,109,112,111,110,101,
110,116,44,32,110,111,112,115,44,32,112,97,114,97,109,115,110,117,109,44,32,
97,114,114,97,121,115,44,32,114,101,115,117,108,116,100,111,117,98,108,101,44,
32,114,101,115,117,108,116,105,110,116,44,32,114,101,115,117,108,116,115,116,
114,105,110,103,44,32,105,110,115,105,122,101,44,32,105,115,108,105,116,101,
114,97,108,41,10,
// '    if fusedudftype == 2:\n
32,32,32,32,105,102,32,102,117,115,101,100,117,100,102,116,121,112,101,32,61,
61,32,50,58,10,
// '        ## aggregate case (cases with aggregates and scalars)\n
32,32,32,32,32,32,32,32,35,35,32,97,103,103,114,101,103,97,116,101,32,99,97,
115,101,32,40,99,97,115,101,115,32,119,105,116,104,32,97,103,103,114,101,103,
97,116,101,115,32,97,110,100,32,115,99,97,108,97,114,115,41,10,
// '        pass\n
32,32,32,32,32,32,32,32,112,97,115,115,10,
// '    if fusedudftype == 3:\n
32,32,32,32,105,102,32,102,117,115,101,100,117,100,102,116,121,112,101,32,61,
61,32,51,58,10,
// '        # table case, all the other cases\n
32,32,32,32,32,32,32,32,35,32,116,97,98,108,101,32,99,97,115,101,44,32,97,108,
108,32,116,104,101,32,111,116,104,101,114,32,99,97,115,101,115,10,
// '        pass\n
32,32,32,32,32,32,32,32,112,97,115,115,10,
// '    return 1\n
32,32,32,32,114,101,116,117,114,110,32,49,10,
// '\n
10,
// '@ffi.def_extern()\n
64,102,102,105,46,100,101,102,95,101,120,116,101,114,110,40,41,10,
// 'def systemwrapper(funcname, paramsnum, arrays, resultnum, resultarrays, insize, extraparams, errormessage):\n
100,101,102,32,115,121,115,116,101,109,119,114,97,112,112,101,114,40,102,117,
110,99,110,97,109,101,44,32,112,97,114,97,109,115,110,117,109,44,32,97,114,114,
97,121,115,44,32,114,101,115,117,108,116,110,117,109,44,32,114,101,115,117,108,
116,97,114,114,97,121,115,44,32,105,110,115,105,122,101,44,32,101,120,116,114,
97,112,97,114,97,109,115,44,32,101,114,114,111,114,109,101,115,115,97,103,101,
41,58,10,
// '    funcname = ffi.string(funcname).decode()\n
32,32,32,32,102,117,110,99,110,97,109,101,32,61,32,102,102,105,46,115,116,114,
105,110,103,40,102,117,110,99,110,97,109,101,41,46,100,101,99,111,100,101,40,
41,10,
// "    funcname = funcname.split('.')\n
32,32,32,32,102,117,110,99,110,97,109,101,32,61,32,102,117,110,99,110,97,109,
101,46,115,112,108,105,116,40,39,46,39,41,10,
// '    inputd = [None]*paramsnum\n
32,32,32,32,105,110,112,117,116,100,32,61,32,91,78,111,110,101,93,42,112,97,
114,97,109,115,110,117,109,10,
// '    for i in range(paramsnum):\n
32,32,32,32,102,111,114,32,105,32,105,110,32,114,97,110,103,101,40,112,97,114,
97,109,115,110,117,109,41,58,10,
// '       if arrays[i].type == 0:\n
32,32,32,32,32,32,32,105,102,32,97,114,114,97,121,115,91,105,93,46,116,121,112,
101,32,61,61,32,48,58,10,
// '           inputd[i] = ffi.cast("char **", arrays[i].array )\n
32,32,32,32,32,32,32,32,32,32,32,105,110,112,117,116,100,91,105,93,32,61,32,
102,102,105,46,99,97,115,116,40,34,99,104,97,114,32,42,42,34,44,32,97,114,114,
97,121,115,91,105,93,46,97,114,114,97,121,32,41,10,
// '       elif arrays[i].type == 1:\n
32,32,32,32,32,32,32,101,108,105,102,32,97,114,114,97,121,115,91,105,93,46,116,
121,112,101,32,61,61,32,49,58,10,
// '           inputd[i] = ffi.cast("int *", arrays[i].array )\n
32,32,32,32,32,32,32,32,32,32,32,105,110,112,117,116,100,91,105,93,32,61,32,
102,102,105,46,99,97,115,116,40,34,105,110,116,32,42,34,44,32,97,114,114,97,
121,115,91,105,93,46,97,114,114,97,121,32,41,10,
// '       elif arrays[i].type == 2:\n
32,32,32,32,32,32,32,101,108,105,102,32,97,114,114,97,121,115,91,105,93,46,116,
121,112,101,32,61,61,32,50,58,10,
// '           inputd[i] = ffi.cast("double *", arrays[i].array)\n
32,32,32,32,32,32,32,32,32,32,32,105,110,112,117,116,100,91,105,93,32,61,32,
102,102,105,46,99,97,115,116,40,34,100,111,117,98,108,101,32,42,34,44,32,97,
114,114,97,121,115,91,105,93,46,97,114,114,97,121,41,10,
// "    codeparams = 'inputd, resultnum, resultarrays, insize, ffi, lib'\n
32,32,32,32,99,111,100,101,112,97,114,97,109,115,32,61,32,39,105,110,112,117,
116,100,44,32,114,101,115,117,108,116,110,117,109,44,32,114,101,115,117,108,
116,97,114,114,97,121,115,44,32,105,110,115,105,122,101,44,32,102,102,105,44,
32,108,105,98,39,10,
// "    code_string = '''\n
32,32,32,32,99,111,100,101,95,115,116,114,105,110,103,32,61,32,39,39,39,10,
// 'try:\n
116,114,121,58,10,
// "    from  '''+funcname[0]+''' import '''+funcname[1]+'''\n
32,32,32,32,102,114,111,109,32,32,39,39,39,43,102,117,110,99,110,97,109,101,
91,48,93,43,39,39,39,32,105,109,112,111,114,116,32,39,39,39,43,102,117,110,99,
110,97,109,101,91,49,93,43,39,39,39,10,
// 'except ImportError as import_err:\n
101,120,99,101,112,116,32,73,109,112,111,114,116,69,114,114,111,114,32,97,115,
32,105,109,112,111,114,116,95,101,114,114,58,10,
// "    importlib.reload('''+funcname[0]+''')\n
32,32,32,32,105,109,112,111,114,116,108,105,98,46,114,101,108,111,97,100,40,
39,39,39,43,102,117,110,99,110,97,109,101,91,48,93,43,39,39,39,41,10,
// "    from  '''+funcname[0]+''' import '''+funcname[1]+'''\n
32,32,32,32,102,114,111,109,32,32,39,39,39,43,102,117,110,99,110,97,109,101,
91,48,93,43,39,39,39,32,105,109,112,111,114,116,32,39,39,39,43,102,117,110,99,
110,97,109,101,91,49,93,43,39,39,39,10,
// "iter = '''+funcname[1]+'''.'''+funcname[2]+'''('''+codeparams+''')\n
105,116,101,114,32,61,32,39,39,39,43,102,117,110,99,110,97,109,101,91,49,93,
43,39,39,39,46,39,39,39,43,102,117,110,99,110,97,109,101,91,50,93,43,39,39,39,
40,39,39,39,43,99,111,100,101,112,97,114,97,109,115,43,39,39,39,41,10,
// 'next(iter)\n
110,101,120,116,40,105,116,101,114,41,10,
// "    '''\n
32,32,32,32,39,39,39,10,
// '    print(code_string)\n
32,32,32,32,112,114,105,110,116,40,99,111,100,101,95,115,116,114,105,110,103,
41,10,
// '    exec(code_string)\n
32,32,32,32,101,120,101,99,40,99,111,100,101,95,115,116,114,105,110,103,41,10,
// '    return 1\n
32,32,32,32,114,101,116,117,114,110,32,49,10,
// '\n
10,
// '@ffi.def_extern()\n
64,102,102,105,46,100,101,102,95,101,120,116,101,114,110,40,41,10,
// 'def tableudfwrapper(funcname, paramsnum, arrays, resultnum, resultarrays, insize, extraparams, errormessage):\n
100,101,102,32,116,97,98,108,101,117,100,102,119,114,97,112,112,101,114,40,102,
117,110,99,110,97,109,101,44,32,112,97,114,97,109,115,110,117,109,44,32,97,114,
114,97,121,115,44,32,114,101,115,117,108,116,110,117,109,44,32,114,101,115,117,
108,116,97,114,114,97,121,115,44,32,105,110,115,105,122,101,44,32,101,120,116,
114,97,112,97,114,97,109,115,44,32,101,114,114,111,114,109,101,115,115,97,103,
101,41,58,10,
// '  global global_lock\n
32,32,103,108,111,98,97,108,32,103,108,111,98,97,108,95,108,111,99,107,10,
// '  errorm = 0\n
32,32,101,114,114,111,114,109,32,61,32,48,10,
// '  with global_lock:\n
32,32,119,105,116,104,32,103,108,111,98,97,108,95,108,111,99,107,58,10,
// '     errorm = 0\n
32,32,32,32,32,101,114,114,111,114,109,32,61,32,48,10,
// '     global tmpstrs\n
32,32,32,32,32,103,108,111,98,97,108,32,116,109,112,115,116,114,115,10,
// '     del tmpstrs[:]\n
32,32,32,32,32,100,101,108,32,116,109,112,115,116,114,115,91,58,93,10,
// '     tmpstrs = []\n
32,32,32,32,32,116,109,112,115,116,114,115,32,61,32,91,93,10,
// '     #global inc\n
32,32,32,32,32,35,103,108,111,98,97,108,32,105,110,99,10,
// '     funcname = ffi.string(funcname).decode()\n
32,32,32,32,32,102,117,110,99,110,97,109,101,32,61,32,102,102,105,46,115,116,
114,105,110,103,40,102,117,110,99,110,97,109,101,41,46,100,101,99,111,100,101,
40,41,10,
// "     funcname = funcname.split('.')\n
32,32,32,32,32,102,117,110,99,110,97,109,101,32,61,32,102,117,110,99,110,97,
109,101,46,115,112,108,105,116,40,39,46,39,41,10,
// '     inputd = [None]*paramsnum\n
32,32,32,32,32,105,110,112,117,116,100,32,61,32,91,78,111,110,101,93,42,112,
97,114,97,109,115,110,117,109,10,
// '     outputd = [None]*resultnum\n
32,32,32,32,32,111,117,116,112,117,116,100,32,61,32,91,78,111,110,101,93,42,
114,101,115,117,108,116,110,117,109,10,
// '     scparams = None\n
32,32,32,32,32,115,99,112,97,114,97,109,115,32,61,32,78,111,110,101,10,
// '     start = 0\n
32,32,32,32,32,115,116,97,114,116,32,61,32,48,10,
// '     extrapar = 0\n
32,32,32,32,32,101,120,116,114,97,112,97,114,32,61,32,48,10,
// '     try:\n
32,32,32,32,32,116,114,121,58,10,
// '         if arrays[0].type == 0:\n
32,32,32,32,32,32,32,32,32,105,102,32,97,114,114,97,121,115,91,48,93,46,116,
121,112,101,32,61,61,32,48,58,10,
// '             scparams = json.loads(ffi.string(ffi.cast("char **", arrays[0].array )[0]).decode().replace("\'",\'"\')  )[\'scpar\']\n
32,32,32,32,32,32,32,32,32,32,32,32,32,115,99,112,97,114,97,109,115,32,61,32,
106,115,111,110,46,108,111,97,100,115,40,102,102,105,46,115,116,114,105,110,
103,40,102,102,105,46,99,97,115,116,40,34,99,104,97,114,32,42,42,34,44,32,97,
114,114,97,121,115,91,48,93,46,97,114,114,97,121,32,41,91,48,93,41,46,100,101,
99,111,100,101,40,41,46,114,101,112,108,97,99,101,40,34,39,34,44,39,34,39,41,
32,32,41,91,39,115,99,112,97,114,39,93,10,
// '         else: \n
32,32,32,32,32,32,32,32,32,101,108,115,101,58,32,10,
// '             raise\n
32,32,32,32,32,32,32,32,32,32,32,32,32,114,97,105,115,101,10,
// '     except:\n
32,32,32,32,32,101,120,99,101,112,116,58,10,
// '         try:\n
32,32,32,32,32,32,32,32,32,116,114,121,58,10,
// '             if extraparams != ffi.NULL:\n
32,32,32,32,32,32,32,32,32,32,32,32,32,105,102,32,101,120,116,114,97,112,97,
114,97,109,115,32,33,61,32,102,102,105,46,78,85,76,76,58,10,
// '                 scparams = json.loads(ffi.string(extraparams).decode().replace("\'\'",\'"\').strip("\'")  )[\'scpar\']\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,115,99,112,97,114,97,109,
115,32,61,32,106,115,111,110,46,108,111,97,100,115,40,102,102,105,46,115,116,
114,105,110,103,40,101,120,116,114,97,112,97,114,97,109,115,41,46,100,101,99,
111,100,101,40,41,46,114,101,112,108,97,99,101,40,34,39,39,34,44,39,34,39,41,
46,115,116,114,105,112,40,34,39,34,41,32,32,41,91,39,115,99,112,97,114,39,93,
10,
// '                 extrapar = 1\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,101,120,116,114,97,112,97,
114,32,61,32,49,10,
// '             else:\n
32,32,32,32,32,32,32,32,32,32,32,32,32,101,108,115,101,58,10,
// '                 scparams = None\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,115,99,112,97,114,97,109,
115,32,61,32,78,111,110,101,10,
// '         except:\n
32,32,32,32,32,32,32,32,32,101,120,99,101,112,116,58,10,
// '             scparams = None\n
32,32,32,32,32,32,32,32,32,32,32,32,32,115,99,112,97,114,97,109,115,32,61,32,
78,111,110,101,10,
// '     if scparams!=None and extrapar == 0:\n
32,32,32,32,32,105,102,32,115,99,112,97,114,97,109,115,33,61,78,111,110,101,
32,97,110,100,32,101,120,116,114,97,112,97,114,32,61,61,32,48,58,10,
// '         start = 1\n
32,32,32,32,32,32,32,32,32,115,116,97,114,116,32,61,32,49,10,
// '     for i in range(start, paramsnum):\n
32,32,32,32,32,102,111,114,32,105,32,105,110,32,114,97,110,103,101,40,115,116,
97,114,116,44,32,112,97,114,97,109,115,110,117,109,41,58,10,
// '       if arrays[i].type == 0:\n
32,32,32,32,32,32,32,105,102,32,97,114,114,97,121,115,91,105,93,46,116,121,112,
101,32,61,61,32,48,58,10,
// '           inputd[i] = ffi.cast("char **", arrays[i].array )\n
32,32,32,32,32,32,32,32,32,32,32,105,110,112,117,116,100,91,105,93,32,61,32,
102,102,105,46,99,97,115,116,40,34,99,104,97,114,32,42,42,34,44,32,97,114,114,
97,121,115,91,105,93,46,97,114,114,97,121,32,41,10,
// '       elif arrays[i].type == 1:\n
32,32,32,32,32,32,32,101,108,105,102,32,97,114,114,97,121,115,91,105,93,46,116,
121,112,101,32,61,61,32,49,58,10,
// '           inputd[i] = ffi.cast("int *", arrays[i].array )\n
32,32,32,32,32,32,32,32,32,32,32,105,110,112,117,116,100,91,105,93,32,61,32,
102,102,105,46,99,97,115,116,40,34,105,110,116,32,42,34,44,32,97,114,114,97,
121,115,91,105,93,46,97,114,114,97,121,32,41,10,
// '       elif arrays[i].type == 2:\n
32,32,32,32,32,32,32,101,108,105,102,32,97,114,114,97,121,115,91,105,93,46,116,
121,112,101,32,61,61,32,50,58,10,
// '           inputd[i] = ffi.cast("double *", arrays[i].array)\n
32,32,32,32,32,32,32,32,32,32,32,105,110,112,117,116,100,91,105,93,32,61,32,
102,102,105,46,99,97,115,116,40,34,100,111,117,98,108,101,32,42,34,44,32,97,
114,114,97,121,115,91,105,93,46,97,114,114,97,121,41,10,
// '       elif arrays[i].type == 4:\n
32,32,32,32,32,32,32,101,108,105,102,32,97,114,114,97,121,115,91,105,93,46,116,
121,112,101,32,61,61,32,52,58,10,
// '             inputd[i] = ffi.cast("int8_t *", arrays[i].array)\n
32,32,32,32,32,32,32,32,32,32,32,32,32,105,110,112,117,116,100,91,105,93,32,
61,32,102,102,105,46,99,97,115,116,40,34,105,110,116,56,95,116,32,42,34,44,32,
97,114,114,97,121,115,91,105,93,46,97,114,114,97,121,41,10,
// '       elif arrays[i].type == 5:\n
32,32,32,32,32,32,32,101,108,105,102,32,97,114,114,97,121,115,91,105,93,46,116,
121,112,101,32,61,61,32,53,58,10,
// '             inputd[i] = ffi.cast("int16_t *", arrays[i].array)\n
32,32,32,32,32,32,32,32,32,32,32,32,32,105,110,112,117,116,100,91,105,93,32,
61,32,102,102,105,46,99,97,115,116,40,34,105,110,116,49,54,95,116,32,42,34,44,
32,97,114,114,97,121,115,91,105,93,46,97,114,114,97,121,41,10,
// "     code_params = ', '.join(['int(inputd['+str(j)+'][n])' if arrays[j].type == 1 else 'ffi.string(inputd['+str(j)+'][n])' if arrays[j].type == 0 else 'float(inputd['+str(j)+'][n])' for j in range(start, paramsnum)])\n
32,32,32,32,32,99,111,100,101,95,112,97,114,97,109,115,32,61,32,39,44,32,39,
46,106,111,105,110,40,91,39,105,110,116,40,105,110,112,117,116,100,91,39,43,
115,116,114,40,106,41,43,39,93,91,110,93,41,39,32,105,102,32,97,114,114,97,121,
115,91,106,93,46,116,121,112,101,32,61,61,32,49,32,101,108,115,101,32,39,102,
102,105,46,115,116,114,105,110,103,40,105,110,112,117,116,100,91,39,43,115,116,
114,40,106,41,43,39,93,91,110,93,41,39,32,105,102,32,97,114,114,97,121,115,91,
106,93,46,116,121,112,101,32,61,61,32,48,32,101,108,115,101,32,39,102,108,111,
97,116,40,105,110,112,117,116,100,91,39,43,115,116,114,40,106,41,43,39,93,91,
110,93,41,39,32,102,111,114,32,106,32,105,110,32,114,97,110,103,101,40,115,116,
97,114,116,44,32,112,97,114,97,109,115,110,117,109,41,93,41,10,
// '     retlen = insize*2\n
32,32,32,32,32,114,101,116,108,101,110,32,61,32,105,110,115,105,122,101,42,50,
10,
// '     #for i in range(resultnum):\n
32,32,32,32,32,35,102,111,114,32,105,32,105,110,32,114,97,110,103,101,40,114,
101,115,117,108,116,110,117,109,41,58,10,
// '     #    if resultarrays[i].type == 0:\n
32,32,32,32,32,35,32,32,32,32,105,102,32,114,101,115,117,108,116,97,114,114,
97,121,115,91,105,93,46,116,121,112,101,32,61,61,32,48,58,10,
// '     #        resultarrays[i].array = ffi.cast("char**", lib.malloc(retlen*ffi.sizeof("char *")))\n
32,32,32,32,32,35,32,32,32,32,32,32,32,32,114,101,115,117,108,116,97,114,114,
97,121,115,91,105,93,46,97,114,114,97,121,32,61,32,102,102,105,46,99,97,115,
116,40,34,99,104,97,114,42,42,34,44,32,108,105,98,46,109,97,108,108,111,99,40,
114,101,116,108,101,110,42,102,102,105,46,115,105,122,101,111,102,40,34,99,104,
97,114,32,42,34,41,41,41,10,
// '     #        outputd[i] = ffi.cast("char **", resultarrays[i].array )\n
32,32,32,32,32,35,32,32,32,32,32,32,32,32,111,117,116,112,117,116,100,91,105,
93,32,61,32,102,102,105,46,99,97,115,116,40,34,99,104,97,114,32,42,42,34,44,
32,114,101,115,117,108,116,97,114,114,97,121,115,91,105,93,46,97,114,114,97,
121,32,41,10,
// '     #    elif resultarrays[i].type == 1:\n
32,32,32,32,32,35,32,32,32,32,101,108,105,102,32,114,101,115,117,108,116,97,
114,114,97,121,115,91,105,93,46,116,121,112,101,32,61,61,32,49,58,10,
// '     #        resultarrays[i].array = ffi.cast("int*", lib.malloc(retlen*ffi.sizeof("int")))\n
32,32,32,32,32,35,32,32,32,32,32,32,32,32,114,101,115,117,108,116,97,114,114,
97,121,115,91,105,93,46,97,114,114,97,121,32,61,32,102,102,105,46,99,97,115,
116,40,34,105,110,116,42,34,44,32,108,105,98,46,109,97,108,108,111,99,40,114,
101,116,108,101,110,42,102,102,105,46,115,105,122,101,111,102,40,34,105,110,
116,34,41,41,41,10,
// '     #        outputd[i] = ffi.cast("int *", resultarrays[i].array )\n
32,32,32,32,32,35,32,32,32,32,32,32,32,32,111,117,116,112,117,116,100,91,105,
93,32,61,32,102,102,105,46,99,97,115,116,40,34,105,110,116,32,42,34,44,32,114,
101,115,117,108,116,97,114,114,97,121,115,91,105,93,46,97,114,114,97,121,32,
41,10,
// '     #    elif resultarrays[i].type == 2:\n
32,32,32,32,32,35,32,32,32,32,101,108,105,102,32,114,101,115,117,108,116,97,
114,114,97,121,115,91,105,93,46,116,121,112,101,32,61,61,32,50,58,10,
// '     #        resultarrays[i].array = ffi.cast("double*", lib.malloc(retlen*ffi.sizeof("double")))\n
32,32,32,32,32,35,32,32,32,32,32,32,32,32,114,101,115,117,108,116,97,114,114,
97,121,115,91,105,93,46,97,114,114,97,121,32,61,32,102,102,105,46,99,97,115,
116,40,34,100,111,117,98,108,101,42,34,44,32,108,105,98,46,109,97,108,108,111,
99,40,114,101,116,108,101,110,42,102,102,105,46,115,105,122,101,111,102,40,34,
100,111,117,98,108,101,34,41,41,41,10,
// '     #        outputd[i] = ffi.cast("double *", resultarrays[i].array)\n
32,32,32,32,32,35,32,32,32,32,32,32,32,32,111,117,116,112,117,116,100,91,105,
93,32,61,32,102,102,105,46,99,97,115,116,40,34,100,111,117,98,108,101,32,42,
34,44,32,114,101,115,117,108,116,97,114,114,97,121,115,91,105,93,46,97,114,114,
97,121,41,10,
// '     if resultnum > 1:\n
32,32,32,32,32,105,102,32,114,101,115,117,108,116,110,117,109,32,62,32,49,58,
10,
// "         codeloop = '\\n    '.join(['outputd['+str(i)+'][cc] = lib.strdup(ffi.from_buffer(memoryview(row['+str(i)+'])))' if resultarrays[i].type == 0 else 'outputd['+str(i)+'][cc] = row['+str(i)+']' for i in range(resultnum)])\n
32,32,32,32,32,32,32,32,32,99,111,100,101,108,111,111,112,32,61,32,39,92,110,
32,32,32,32,39,46,106,111,105,110,40,91,39,111,117,116,112,117,116,100,91,39,
43,115,116,114,40,105,41,43,39,93,91,99,99,93,32,61,32,108,105,98,46,115,116,
114,100,117,112,40,102,102,105,46,102,114,111,109,95,98,117,102,102,101,114,
40,109,101,109,111,114,121,118,105,101,119,40,114,111,119,91,39,43,115,116,114,
40,105,41,43,39,93,41,41,41,39,32,105,102,32,114,101,115,117,108,116,97,114,
114,97,121,115,91,105,93,46,116,121,112,101,32,61,61,32,48,32,101,108,115,101,
32,39,111,117,116,112,117,116,100,91,39,43,115,116,114,40,105,41,43,39,93,91,
99,99,93,32,61,32,114,111,119,91,39,43,115,116,114,40,105,41,43,39,93,39,32,
102,111,114,32,105,32,105,110,32,114,97,110,103,101,40,114,101,115,117,108,116,
110,117,109,41,93,41,10,
// '     else:\n
32,32,32,32,32,101,108,115,101,58,10,
// "         codeloop = 'outputd[0][cc] = lib.strdup(ffi.from_buffer(memoryview(row)))' if resultarrays[0].type == 0 else 'outputd[0][cc] = row'  ## to do type == 0\n
32,32,32,32,32,32,32,32,32,99,111,100,101,108,111,111,112,32,61,32,39,111,117,
116,112,117,116,100,91,48,93,91,99,99,93,32,61,32,108,105,98,46,115,116,114,
100,117,112,40,102,102,105,46,102,114,111,109,95,98,117,102,102,101,114,40,109,
101,109,111,114,121,118,105,101,119,40,114,111,119,41,41,41,39,32,105,102,32,
114,101,115,117,108,116,97,114,114,97,121,115,91,48,93,46,116,121,112,101,32,
61,61,32,48,32,101,108,115,101,32,39,111,117,116,112,117,116,100,91,48,93,91,
99,99,93,32,61,32,114,111,119,39,32,32,35,35,32,116,111,32,100,111,32,116,121,
112,101,32,61,61,32,48,10,
// "     code_string = '''\n
32,32,32,32,32,99,111,100,101,95,115,116,114,105,110,103,32,61,32,39,39,39,10,
// 'try:\n
116,114,121,58,10,
// '  try:\n
32,32,116,114,121,58,10,
// "    #importlib.reload('''+funcname[0]+''')\n
32,32,32,32,35,105,109,112,111,114,116,108,105,98,46,114,101,108,111,97,100,
40,39,39,39,43,102,117,110,99,110,97,109,101,91,48,93,43,39,39,39,41,10,
// "    from  '''+funcname[0]+''' import '''+funcname[1]+'''\n
32,32,32,32,102,114,111,109,32,32,39,39,39,43,102,117,110,99,110,97,109,101,
91,48,93,43,39,39,39,32,105,109,112,111,114,116,32,39,39,39,43,102,117,110,99,
110,97,109,101,91,49,93,43,39,39,39,10,
// '    if functions.DEBUG:\n
32,32,32,32,105,102,32,102,117,110,99,116,105,111,110,115,46,68,69,66,85,71,
58,10,
// "      mypath = get_module_path(funcname[0]+'.'+funcname[1])\n
32,32,32,32,32,32,109,121,112,97,116,104,32,61,32,103,101,116,95,109,111,100,
117,108,101,95,112,97,116,104,40,102,117,110,99,110,97,109,101,91,48,93,43,39,
46,39,43,102,117,110,99,110,97,109,101,91,49,93,41,10,
// '      print(mypath)\n
32,32,32,32,32,32,112,114,105,110,116,40,109,121,112,97,116,104,41,10,
// '      if mypath not in checksums:\n
32,32,32,32,32,32,105,102,32,109,121,112,97,116,104,32,110,111,116,32,105,110,
32,99,104,101,99,107,115,117,109,115,58,10,
// '        checksums[mypath] = calculate_checksum(mypath)\n
32,32,32,32,32,32,32,32,99,104,101,99,107,115,117,109,115,91,109,121,112,97,
116,104,93,32,61,32,99,97,108,99,117,108,97,116,101,95,99,104,101,99,107,115,
117,109,40,109,121,112,97,116,104,41,10,
// '      elif mypath in checksums:\n
32,32,32,32,32,32,101,108,105,102,32,109,121,112,97,116,104,32,105,110,32,99,
104,101,99,107,115,117,109,115,58,10,
// '        csum = calculate_checksum(mypath)\n
32,32,32,32,32,32,32,32,99,115,117,109,32,61,32,99,97,108,99,117,108,97,116,
101,95,99,104,101,99,107,115,117,109,40,109,121,112,97,116,104,41,10,
// '        if checksums[mypath] != csum:\n
32,32,32,32,32,32,32,32,105,102,32,99,104,101,99,107,115,117,109,115,91,109,
121,112,97,116,104,93,32,33,61,32,99,115,117,109,58,10,
// "          importlib.reload('''+funcname[1]+''')\n
32,32,32,32,32,32,32,32,32,32,105,109,112,111,114,116,108,105,98,46,114,101,
108,111,97,100,40,39,39,39,43,102,117,110,99,110,97,109,101,91,49,93,43,39,39,
39,41,10,
// '          checksums[mypath] = csum\n
32,32,32,32,32,32,32,32,32,32,99,104,101,99,107,115,117,109,115,91,109,121,112,
97,116,104,93,32,61,32,99,115,117,109,10,
// '  except ImportError as import_err:\n
32,32,101,120,99,101,112,116,32,73,109,112,111,114,116,69,114,114,111,114,32,
97,115,32,105,109,112,111,114,116,95,101,114,114,58,10,
// "    importlib.reload('''+funcname[0]+''')\n
32,32,32,32,105,109,112,111,114,116,108,105,98,46,114,101,108,111,97,100,40,
39,39,39,43,102,117,110,99,110,97,109,101,91,48,93,43,39,39,39,41,10,
// "    from  '''+funcname[0]+''' import '''+funcname[1]+'''\n
32,32,32,32,102,114,111,109,32,32,39,39,39,43,102,117,110,99,110,97,109,101,
91,48,93,43,39,39,39,32,105,109,112,111,114,116,32,39,39,39,43,102,117,110,99,
110,97,109,101,91,49,93,43,39,39,39,10,
// '\n
10,
// '  cc = -1\n
32,32,99,99,32,61,32,45,49,10,
// '  def inputgen(inputd, insize, arrays):\n
32,32,100,101,102,32,105,110,112,117,116,103,101,110,40,105,110,112,117,116,
100,44,32,105,110,115,105,122,101,44,32,97,114,114,97,121,115,41,58,10,
// '    for n in range(insize):\n
32,32,32,32,102,111,114,32,110,32,105,110,32,114,97,110,103,101,40,105,110,115,
105,122,101,41,58,10,
// "        yield '''+code_params+'''\n
32,32,32,32,32,32,32,32,121,105,101,108,100,32,39,39,39,43,99,111,100,101,95,
112,97,114,97,109,115,43,39,39,39,10,
// '  def inputgen2(scparams):\n
32,32,100,101,102,32,105,110,112,117,116,103,101,110,50,40,115,99,112,97,114,
97,109,115,41,58,10,
// '      #if len(scparams) == 1:\n
32,32,32,32,32,32,35,105,102,32,108,101,110,40,115,99,112,97,114,97,109,115,
41,32,61,61,32,49,58,10,
// '      #    yield scparams[0]\n
32,32,32,32,32,32,35,32,32,32,32,121,105,101,108,100,32,115,99,112,97,114,97,
109,115,91,48,93,10,
// '      #else:\n
32,32,32,32,32,32,35,101,108,115,101,58,10,
// '          yield tuple(x for x in scparams)\n
32,32,32,32,32,32,32,32,32,32,121,105,101,108,100,32,116,117,112,108,101,40,
120,32,102,111,114,32,120,32,105,110,32,115,99,112,97,114,97,109,115,41,10,
// "  #for row in '''+funcname[1]+'''.'''+funcname[2]+'''(inputgen(inputd, insize, arrays)):\n
32,32,35,102,111,114,32,114,111,119,32,105,110,32,39,39,39,43,102,117,110,99,
110,97,109,101,91,49,93,43,39,39,39,46,39,39,39,43,102,117,110,99,110,97,109,
101,91,50,93,43,39,39,39,40,105,110,112,117,116,103,101,110,40,105,110,112,117,
116,100,44,32,105,110,115,105,122,101,44,32,97,114,114,97,121,115,41,41,58,10,
// '  ll = None\n
32,32,108,108,32,61,32,78,111,110,101,10,
// '  if insize>0:\n
32,32,105,102,32,105,110,115,105,122,101,62,48,58,10,
// '      if insize == 1 and scparams == None:\n
32,32,32,32,32,32,105,102,32,105,110,115,105,122,101,32,61,61,32,49,32,97,110,
100,32,115,99,112,97,114,97,109,115,32,61,61,32,78,111,110,101,58,10,
// '        if paramsnum == 1:\n
32,32,32,32,32,32,32,32,105,102,32,112,97,114,97,109,115,110,117,109,32,61,61,
32,49,58,10,
// "           ll = '''+funcname[1]+'''.'''+funcname[2]+'''(next(inputgen(inputd, insize, arrays))) #scparams  ))\n
32,32,32,32,32,32,32,32,32,32,32,108,108,32,61,32,39,39,39,43,102,117,110,99,
110,97,109,101,91,49,93,43,39,39,39,46,39,39,39,43,102,117,110,99,110,97,109,
101,91,50,93,43,39,39,39,40,110,101,120,116,40,105,110,112,117,116,103,101,110,
40,105,110,112,117,116,100,44,32,105,110,115,105,122,101,44,32,97,114,114,97,
121,115,41,41,41,32,35,115,99,112,97,114,97,109,115,32,32,41,41,10,
// '        else:\n
32,32,32,32,32,32,32,32,101,108,115,101,58,10,
// "           ll = '''+funcname[1]+'''.'''+funcname[2]+'''(*next(inputgen(inputd, insize, arrays))) #scparams  ))\n
32,32,32,32,32,32,32,32,32,32,32,108,108,32,61,32,39,39,39,43,102,117,110,99,
110,97,109,101,91,49,93,43,39,39,39,46,39,39,39,43,102,117,110,99,110,97,109,
101,91,50,93,43,39,39,39,40,42,110,101,120,116,40,105,110,112,117,116,103,101,
110,40,105,110,112,117,116,100,44,32,105,110,115,105,122,101,44,32,97,114,114,
97,121,115,41,41,41,32,35,115,99,112,97,114,97,109,115,32,32,41,41,10,
// '      else:\n
32,32,32,32,32,32,101,108,115,101,58,10,
// "        ll = '''+funcname[1]+'''.'''+funcname[2]+'''(inputgen(inputd, insize, arrays), scparams) #scparams  ))\n
32,32,32,32,32,32,32,32,108,108,32,61,32,39,39,39,43,102,117,110,99,110,97,109,
101,91,49,93,43,39,39,39,46,39,39,39,43,102,117,110,99,110,97,109,101,91,50,
93,43,39,39,39,40,105,110,112,117,116,103,101,110,40,105,110,112,117,116,100,
44,32,105,110,115,105,122,101,44,32,97,114,114,97,121,115,41,44,32,115,99,112,
97,114,97,109,115,41,32,35,115,99,112,97,114,97,109,115,32,32,41,41,10,
// '  else:\n
32,32,101,108,115,101,58,10,
// "      ll = '''+funcname[1]+'''.'''+funcname[2]+'''(*next(inputgen2(scparams)))\n
32,32,32,32,32,32,108,108,32,61,32,39,39,39,43,102,117,110,99,110,97,109,101,
91,49,93,43,39,39,39,46,39,39,39,43,102,117,110,99,110,97,109,101,91,50,93,43,
39,39,39,40,42,110,101,120,116,40,105,110,112,117,116,103,101,110,50,40,115,
99,112,97,114,97,109,115,41,41,41,10,
// '  #lll = list(ll)\n
32,32,35,108,108,108,32,61,32,108,105,115,116,40,108,108,41,10,
// "  #lll = list('''+funcname[1]+'''.'''+funcname[2]+'''(inputd, insize, arrays, scparams)) #scparams  )) #pass materialized array\n
32,32,35,108,108,108,32,61,32,108,105,115,116,40,39,39,39,43,102,117,110,99,
110,97,109,101,91,49,93,43,39,39,39,46,39,39,39,43,102,117,110,99,110,97,109,
101,91,50,93,43,39,39,39,40,105,110,112,117,116,100,44,32,105,110,115,105,122,
101,44,32,97,114,114,97,121,115,44,32,115,99,112,97,114,97,109,115,41,41,32,
35,115,99,112,97,114,97,109,115,32,32,41,41,32,35,112,97,115,115,32,109,97,116,
101,114,105,97,108,105,122,101,100,32,97,114,114,97,121,10,
// '  resultarrays[0].size = insize*2+1000000 #len(lll)\n
32,32,114,101,115,117,108,116,97,114,114,97,121,115,91,48,93,46,115,105,122,
101,32,61,32,105,110,115,105,122,101,42,50,43,49,48,48,48,48,48,48,32,35,108,
101,110,40,108,108,108,41,10,
// '  retlen = resultarrays[0].size\n
32,32,114,101,116,108,101,110,32,61,32,114,101,115,117,108,116,97,114,114,97,
121,115,91,48,93,46,115,105,122,101,10,
// '  for i in range(resultnum):\n
32,32,102,111,114,32,105,32,105,110,32,114,97,110,103,101,40,114,101,115,117,
108,116,110,117,109,41,58,10,
// '         if resultarrays[i].type == 0:\n
32,32,32,32,32,32,32,32,32,105,102,32,114,101,115,117,108,116,97,114,114,97,
121,115,91,105,93,46,116,121,112,101,32,61,61,32,48,58,10,
// '             resultarrays[i].array = ffi.cast("char**", lib.malloc(retlen*ffi.sizeof("char *")))\n
32,32,32,32,32,32,32,32,32,32,32,32,32,114,101,115,117,108,116,97,114,114,97,
121,115,91,105,93,46,97,114,114,97,121,32,61,32,102,102,105,46,99,97,115,116,
40,34,99,104,97,114,42,42,34,44,32,108,105,98,46,109,97,108,108,111,99,40,114,
101,116,108,101,110,42,102,102,105,46,115,105,122,101,111,102,40,34,99,104,97,
114,32,42,34,41,41,41,10,
// '             #resultarrays[i].array = ffi.gc(ffi.cast("char**", resultarrays[i].array), lib.custom_free2, size=resultarrays[0].size)\n
32,32,32,32,32,32,32,32,32,32,32,32,32,35,114,101,115,117,108,116,97,114,114,
97,121,115,91,105,93,46,97,114,114,97,121,32,61,32,102,102,105,46,103,99,40,
102,102,105,46,99,97,115,116,40,34,99,104,97,114,42,42,34,44,32,114,101,115,
117,108,116,97,114,114,97,121,115,91,105,93,46,97,114,114,97,121,41,44,32,108,
105,98,46,99,117,115,116,111,109,95,102,114,101,101,50,44,32,115,105,122,101,
61,114,101,115,117,108,116,97,114,114,97,121,115,91,48,93,46,115,105,122,101,
41,10,
// '             outputd[i] = ffi.cast("char **", resultarrays[i].array )\n
32,32,32,32,32,32,32,32,32,32,32,32,32,111,117,116,112,117,116,100,91,105,93,
32,61,32,102,102,105,46,99,97,115,116,40,34,99,104,97,114,32,42,42,34,44,32,
114,101,115,117,108,116,97,114,114,97,121,115,91,105,93,46,97,114,114,97,121,
32,41,10,
// '         elif resultarrays[i].type == 1:\n
32,32,32,32,32,32,32,32,32,101,108,105,102,32,114,101,115,117,108,116,97,114,
114,97,121,115,91,105,93,46,116,121,112,101,32,61,61,32,49,58,10,
// '             resultarrays[i].array = ffi.cast("int*", lib.malloc(retlen*ffi.sizeof("int")))\n
32,32,32,32,32,32,32,32,32,32,32,32,32,114,101,115,117,108,116,97,114,114,97,
121,115,91,105,93,46,97,114,114,97,121,32,61,32,102,102,105,46,99,97,115,116,
40,34,105,110,116,42,34,44,32,108,105,98,46,109,97,108,108,111,99,40,114,101,
116,108,101,110,42,102,102,105,46,115,105,122,101,111,102,40,34,105,110,116,
34,41,41,41,10,
// '             #resultarrays[i].array = ffi.gc(ffi.cast("int*", resultarrays[i].array), lib.custom_free3, size=resultarrays[0].size)\n
32,32,32,32,32,32,32,32,32,32,32,32,32,35,114,101,115,117,108,116,97,114,114,
97,121,115,91,105,93,46,97,114,114,97,121,32,61,32,102,102,105,46,103,99,40,
102,102,105,46,99,97,115,116,40,34,105,110,116,42,34,44,32,114,101,115,117,108,
116,97,114,114,97,121,115,91,105,93,46,97,114,114,97,121,41,44,32,108,105,98,
46,99,117,115,116,111,109,95,102,114,101,101,51,44,32,115,105,122,101,61,114,
101,115,117,108,116,97,114,114,97,121,115,91,48,93,46,115,105,122,101,41,10,
// '             outputd[i] = ffi.cast("int *", resultarrays[i].array )\n
32,32,32,32,32,32,32,32,32,32,32,32,32,111,117,116,112,117,116,100,91,105,93,
32,61,32,102,102,105,46,99,97,115,116,40,34,105,110,116,32,42,34,44,32,114,101,
115,117,108,116,97,114,114,97,121,115,91,105,93,46,97,114,114,97,121,32,41,10,
// '         elif resultarrays[i].type == 2:\n
32,32,32,32,32,32,32,32,32,101,108,105,102,32,114,101,115,117,108,116,97,114,
114,97,121,115,91,105,93,46,116,121,112,101,32,61,61,32,50,58,10,
// '             resultarrays[i].array = ffi.cast("double*", lib.malloc(retlen*ffi.sizeof("double")))\n
32,32,32,32,32,32,32,32,32,32,32,32,32,114,101,115,117,108,116,97,114,114,97,
121,115,91,105,93,46,97,114,114,97,121,32,61,32,102,102,105,46,99,97,115,116,
40,34,100,111,117,98,108,101,42,34,44,32,108,105,98,46,109,97,108,108,111,99,
40,114,101,116,108,101,110,42,102,102,105,46,115,105,122,101,111,102,40,34,100,
111,117,98,108,101,34,41,41,41,10,
// '             outputd[i] = ffi.cast("double *", resultarrays[i].array)\n
32,32,32,32,32,32,32,32,32,32,32,32,32,111,117,116,112,117,116,100,91,105,93,
32,61,32,102,102,105,46,99,97,115,116,40,34,100,111,117,98,108,101,32,42,34,
44,32,114,101,115,117,108,116,97,114,114,97,121,115,91,105,93,46,97,114,114,
97,121,41,10,
// '  cc = -1\n
32,32,99,99,32,61,32,45,49,10,
// '  for row in ll:\n
32,32,102,111,114,32,114,111,119,32,105,110,32,108,108,58,10,
// '  #for row in lll:\n
32,32,35,102,111,114,32,114,111,119,32,105,110,32,108,108,108,58,10,
// '  #for n in range(insize):\n
32,32,35,102,111,114,32,110,32,105,110,32,114,97,110,103,101,40,105,110,115,
105,122,101,41,58,10,
// "  #for row in '''+funcname[1]+'''.'''+funcname[2]+'''('''+code_params+'''):\n
32,32,35,102,111,114,32,114,111,119,32,105,110,32,39,39,39,43,102,117,110,99,
110,97,109,101,91,49,93,43,39,39,39,46,39,39,39,43,102,117,110,99,110,97,109,
101,91,50,93,43,39,39,39,40,39,39,39,43,99,111,100,101,95,112,97,114,97,109,
115,43,39,39,39,41,58,10,
// '    cc += 1\n
32,32,32,32,99,99,32,43,61,32,49,10,
// '    resultarrays[0].size = cc+1\n
32,32,32,32,114,101,115,117,108,116,97,114,114,97,121,115,91,48,93,46,115,105,
122,101,32,61,32,99,99,43,49,10,
// '    if cc >= retlen:\n
32,32,32,32,105,102,32,99,99,32,62,61,32,114,101,116,108,101,110,58,10,
// '      retlen = retlen*2\n
32,32,32,32,32,32,114,101,116,108,101,110,32,61,32,114,101,116,108,101,110,42,
50,10,
// '      for i in range(resultnum):\n
32,32,32,32,32,32,102,111,114,32,105,32,105,110,32,114,97,110,103,101,40,114,
101,115,117,108,116,110,117,109,41,58,10,
// '         if resultarrays[i].type == 0:\n
32,32,32,32,32,32,32,32,32,105,102,32,114,101,115,117,108,116,97,114,114,97,
121,115,91,105,93,46,116,121,112,101,32,61,61,32,48,58,10,
// '             resultarrays[i].array = ffi.cast("char**", lib.realloc(resultarrays[i].array,(retlen+1)*ffi.sizeof("char *")))\n
32,32,32,32,32,32,32,32,32,32,32,32,32,114,101,115,117,108,116,97,114,114,97,
121,115,91,105,93,46,97,114,114,97,121,32,61,32,102,102,105,46,99,97,115,116,
40,34,99,104,97,114,42,42,34,44,32,108,105,98,46,114,101,97,108,108,111,99,40,
114,101,115,117,108,116,97,114,114,97,121,115,91,105,93,46,97,114,114,97,121,
44,40,114,101,116,108,101,110,43,49,41,42,102,102,105,46,115,105,122,101,111,
102,40,34,99,104,97,114,32,42,34,41,41,41,10,
// '             outputd[i] = ffi.cast("char **", resultarrays[i].array )\n
32,32,32,32,32,32,32,32,32,32,32,32,32,111,117,116,112,117,116,100,91,105,93,
32,61,32,102,102,105,46,99,97,115,116,40,34,99,104,97,114,32,42,42,34,44,32,
114,101,115,117,108,116,97,114,114,97,121,115,91,105,93,46,97,114,114,97,121,
32,41,10,
// '         elif resultarrays[i].type == 1:\n
32,32,32,32,32,32,32,32,32,101,108,105,102,32,114,101,115,117,108,116,97,114,
114,97,121,115,91,105,93,46,116,121,112,101,32,61,61,32,49,58,10,
// '             resultarrays[i].array = ffi.cast("int*", lib.realloc(resultarrays[i].array, retlen*ffi.sizeof("int")))\n
32,32,32,32,32,32,32,32,32,32,32,32,32,114,101,115,117,108,116,97,114,114,97,
121,115,91,105,93,46,97,114,114,97,121,32,61,32,102,102,105,46,99,97,115,116,
40,34,105,110,116,42,34,44,32,108,105,98,46,114,101,97,108,108,111,99,40,114,
101,115,117,108,116,97,114,114,97,121,115,91,105,93,46,97,114,114,97,121,44,
32,114,101,116,108,101,110,42,102,102,105,46,115,105,122,101,111,102,40,34,105,
110,116,34,41,41,41,10,
// '             outputd[i] = ffi.cast("int*", resultarrays[i].array )\n
32,32,32,32,32,32,32,32,32,32,32,32,32,111,117,116,112,117,116,100,91,105,93,
32,61,32,102,102,105,46,99,97,115,116,40,34,105,110,116,42,34,44,32,114,101,
115,117,108,116,97,114,114,97,121,115,91,105,93,46,97,114,114,97,121,32,41,10,
// '         elif resultarrays[i].type == 2:\n
32,32,32,32,32,32,32,32,32,101,108,105,102,32,114,101,115,117,108,116,97,114,
114,97,121,115,91,105,93,46,116,121,112,101,32,61,61,32,50,58,10,
// '             resultarrays[i].array = ffi.cast("double*", lib.realloc(resultarrays[i].array, retlen*ffi.sizeof("double")))\n
32,32,32,32,32,32,32,32,32,32,32,32,32,114,101,115,117,108,116,97,114,114,97,
121,115,91,105,93,46,97,114,114,97,121,32,61,32,102,102,105,46,99,97,115,116,
40,34,100,111,117,98,108,101,42,34,44,32,108,105,98,46,114,101,97,108,108,111,
99,40,114,101,115,117,108,116,97,114,114,97,121,115,91,105,93,46,97,114,114,
97,121,44,32,114,101,116,108,101,110,42,102,102,105,46,115,105,122,101,111,102,
40,34,100,111,117,98,108,101,34,41,41,41,10,
// '             outputd[i] = ffi.cast("double", resultarrays[i].array )\n
32,32,32,32,32,32,32,32,32,32,32,32,32,111,117,116,112,117,116,100,91,105,93,
32,61,32,102,102,105,46,99,97,115,116,40,34,100,111,117,98,108,101,34,44,32,
114,101,115,117,108,116,97,114,114,97,121,115,91,105,93,46,97,114,114,97,121,
32,41,10,
// "    '''+codeloop+'''\n
32,32,32,32,39,39,39,43,99,111,100,101,108,111,111,112,43,39,39,39,10,
// "  #print('lala')\n
32,32,35,112,114,105,110,116,40,39,108,97,108,97,39,41,10,
// '  for i in range(resultnum):\n
32,32,102,111,114,32,105,32,105,110,32,114,97,110,103,101,40,114,101,115,117,
108,116,110,117,109,41,58,10,
// '         if resultarrays[i].type == 0:\n
32,32,32,32,32,32,32,32,32,105,102,32,114,101,115,117,108,116,97,114,114,97,
121,115,91,105,93,46,116,121,112,101,32,61,61,32,48,58,10,
// '             try:\n
32,32,32,32,32,32,32,32,32,32,32,32,32,116,114,121,58,10,
// '                import __pypy__\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,105,109,112,111,114,116,32,95,
95,112,121,112,121,95,95,10,
// '                resultarrays[i].array = ffi.gc(ffi.cast("char**", resultarrays[i].array), lib.custom_free, size=resultarrays[0].size)\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,114,101,115,117,108,116,97,114,
114,97,121,115,91,105,93,46,97,114,114,97,121,32,61,32,102,102,105,46,103,99,
40,102,102,105,46,99,97,115,116,40,34,99,104,97,114,42,42,34,44,32,114,101,115,
117,108,116,97,114,114,97,121,115,91,105,93,46,97,114,114,97,121,41,44,32,108,
105,98,46,99,117,115,116,111,109,95,102,114,101,101,44,32,115,105,122,101,61,
114,101,115,117,108,116,97,114,114,97,121,115,91,48,93,46,115,105,122,101,41,
10,
// '             except:\n
32,32,32,32,32,32,32,32,32,32,32,32,32,101,120,99,101,112,116,58,10,
// '                pass\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,112,97,115,115,10,
// '             outputd[i] = ffi.cast("char **", resultarrays[i].array)\n
32,32,32,32,32,32,32,32,32,32,32,32,32,111,117,116,112,117,116,100,91,105,93,
32,61,32,102,102,105,46,99,97,115,116,40,34,99,104,97,114,32,42,42,34,44,32,
114,101,115,117,108,116,97,114,114,97,121,115,91,105,93,46,97,114,114,97,121,
41,10,
// '             outputd[i][resultarrays[0].size] = ffi.NULL\n
32,32,32,32,32,32,32,32,32,32,32,32,32,111,117,116,112,117,116,100,91,105,93,
91,114,101,115,117,108,116,97,114,114,97,121,115,91,48,93,46,115,105,122,101,
93,32,61,32,102,102,105,46,78,85,76,76,10,
// '         elif resultarrays[i].type == 1:\n
32,32,32,32,32,32,32,32,32,101,108,105,102,32,114,101,115,117,108,116,97,114,
114,97,121,115,91,105,93,46,116,121,112,101,32,61,61,32,49,58,10,
// '             try:\n
32,32,32,32,32,32,32,32,32,32,32,32,32,116,114,121,58,10,
// '                import __pypy__\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,105,109,112,111,114,116,32,95,
95,112,121,112,121,95,95,10,
// '                resultarrays[i].array = ffi.gc(ffi.cast("int*", resultarrays[i].array), lib.custom_free3, size=resultarrays[0].size+1)\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,114,101,115,117,108,116,97,114,
114,97,121,115,91,105,93,46,97,114,114,97,121,32,61,32,102,102,105,46,103,99,
40,102,102,105,46,99,97,115,116,40,34,105,110,116,42,34,44,32,114,101,115,117,
108,116,97,114,114,97,121,115,91,105,93,46,97,114,114,97,121,41,44,32,108,105,
98,46,99,117,115,116,111,109,95,102,114,101,101,51,44,32,115,105,122,101,61,
114,101,115,117,108,116,97,114,114,97,121,115,91,48,93,46,115,105,122,101,43,
49,41,10,
// '             except:\n
32,32,32,32,32,32,32,32,32,32,32,32,32,101,120,99,101,112,116,58,10,
// '                pass\n
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,112,97,115,115,10,
// 'except Exception as e:\n
101,120,99,101,112,116,32,69,120,99,101,112,116,105,111,110,32,97,115,32,101,
58,10,
// "       errormessage[0] = lib.strdup(ffi.from_buffer(memoryview(b'UDFError '+ funcname[0].encode()+b'.'+funcname[1].encode()+b'.'+funcname[2].upper().encode() + b': ' + traceback.format_exc().encode())))\n
32,32,32,32,32,32,32,101,114,114,111,114,109,101,115,115,97,103,101,91,48,93,
32,61,32,108,105,98,46,115,116,114,100,117,112,40,102,102,105,46,102,114,111,
109,95,98,117,102,102,101,114,40,109,101,109,111,114,121,118,105,101,119,40,
98,39,85,68,70,69,114,114,111,114,32,39,43,32,102,117,110,99,110,97,109,101,
91,48,93,46,101,110,99,111,100,101,40,41,43,98,39,46,39,43,102,117,110,99,110,
97,109,101,91,49,93,46,101,110,99,111,100,101,40,41,43,98,39,46,39,43,102,117,
110,99,110,97,109,101,91,50,93,46,117,112,112,101,114,40,41,46,101,110,99,111,
100,101,40,41,32,43,32,98,39,58,32,39,32,43,32,116,114,97,99,101,98,97,99,107,
46,102,111,114,109,97,116,95,101,120,99,40,41,46,101,110,99,111,100,101,40,41,
41,41,41,10,
// '       errorm = 1\n
32,32,32,32,32,32,32,101,114,114,111,114,109,32,61,32,49,10,
// "'''\n
39,39,39,10,
// '     print(code_string)\n
32,32,32,32,32,112,114,105,110,116,40,99,111,100,101,95,115,116,114,105,110,
103,41,10,
// '     exec(code_string)\n
32,32,32,32,32,101,120,101,99,40,99,111,100,101,95,115,116,114,105,110,103,41,
10,
// '     if errorm == 0:\n
32,32,32,32,32,105,102,32,101,114,114,111,114,109,32,61,61,32,48,58,10,
// '         return 1\n
32,32,32,32,32,32,32,32,32,114,101,116,117,114,110,32,49,10,
// '     else:\n
32,32,32,32,32,101,108,115,101,58,10,
// '         return 0\n
32,32,32,32,32,32,32,32,32,114,101,116,117,114,110,32,48,10,
// 'def free_strings(ptr):\n
100,101,102,32,102,114,101,101,95,115,116,114,105,110,103,115,40,112,116,114,
41,58,10,
// '   try:\n
32,32,32,116,114,121,58,10,
// '     i = 0\n
32,32,32,32,32,105,32,61,32,48,10,
// "     print('automatic gc collection of c objects')\n
32,32,32,32,32,112,114,105,110,116,40,39,97,117,116,111,109,97,116,105,99,32,
103,99,32,99,111,108,108,101,99,116,105,111,110,32,111,102,32,99,32,111,98,106,
101,99,116,115,39,41,10,
// '     while True:\n
32,32,32,32,32,119,104,105,108,101,32,84,114,117,101,58,10,
// '         if ptr[i] != ffi.NULL:\n
32,32,32,32,32,32,32,32,32,105,102,32,112,116,114,91,105,93,32,33,61,32,102,
102,105,46,78,85,76,76,58,10,
// '            #print(ffi.string(ptr[i]))\n
32,32,32,32,32,32,32,32,32,32,32,32,35,112,114,105,110,116,40,102,102,105,46,
115,116,114,105,110,103,40,112,116,114,91,105,93,41,41,10,
// '            #pass\n
32,32,32,32,32,32,32,32,32,32,32,32,35,112,97,115,115,10,
// '            lib.free(ptr[i])\n
32,32,32,32,32,32,32,32,32,32,32,32,108,105,98,46,102,114,101,101,40,112,116,
114,91,105,93,41,10,
// '         else:\n
32,32,32,32,32,32,32,32,32,101,108,115,101,58,10,
// '            break\n
32,32,32,32,32,32,32,32,32,32,32,32,98,114,101,97,107,10,
// '         i+=1\n
32,32,32,32,32,32,32,32,32,105,43,61,49,10,
// '   except Exception as e:\n
32,32,32,101,120,99,101,112,116,32,69,120,99,101,112,116,105,111,110,32,97,115,
32,101,58,10,
// '     print(str(e))\n
32,32,32,32,32,112,114,105,110,116,40,115,116,114,40,101,41,41,10,
// '   lib.free(ptr)\n
32,32,32,108,105,98,46,102,114,101,101,40,112,116,114,41,10,
// '\n
10,
// 'def calculate_checksum(file_path):\n
100,101,102,32,99,97,108,99,117,108,97,116,101,95,99,104,101,99,107,115,117,
109,40,102,105,108,101,95,112,97,116,104,41,58,10,
// '  hasher = hashlib.md5()\n
32,32,104,97,115,104,101,114,32,61,32,104,97,115,104,108,105,98,46,109,100,53,
40,41,10,
// "  with open(file_path, 'rb') as file:\n
32,32,119,105,116,104,32,111,112,101,110,40,102,105,108,101,95,112,97,116,104,
44,32,39,114,98,39,41,32,97,115,32,102,105,108,101,58,10,
// '    buf = file.read()\n
32,32,32,32,98,117,102,32,61,32,102,105,108,101,46,114,101,97,100,40,41,10,
// '    hasher.update(buf)\n
32,32,32,32,104,97,115,104,101,114,46,117,112,100,97,116,101,40,98,117,102,41,
10,
// '  return hasher.hexdigest()\n
32,32,114,101,116,117,114,110,32,104,97,115,104,101,114,46,104,101,120,100,105,
103,101,115,116,40,41,10,
// '\n
10,
// 'def has_file_changed(file_path, initial_checksum):\n
100,101,102,32,104,97,115,95,102,105,108,101,95,99,104,97,110,103,101,100,40,
102,105,108,101,95,112,97,116,104,44,32,105,110,105,116,105,97,108,95,99,104,
101,99,107,115,117,109,41,58,10,
// '  current_checksum = calculate_checksum(file_path)\n
32,32,99,117,114,114,101,110,116,95,99,104,101,99,107,115,117,109,32,61,32,99,
97,108,99,117,108,97,116,101,95,99,104,101,99,107,115,117,109,40,102,105,108,
101,95,112,97,116,104,41,10,
// '  return current_checksum != initial_checksum\n
32,32,114,101,116,117,114,110,32,99,117,114,114,101,110,116,95,99,104,101,99,
107,115,117,109,32,33,61,32,105,110,105,116,105,97,108,95,99,104,101,99,107,
115,117,109,10,
// '\n
10,
// 'def get_module_path(module_name):\n
100,101,102,32,103,101,116,95,109,111,100,117,108,101,95,112,97,116,104,40,109,
111,100,117,108,101,95,110,97,109,101,41,58,10,
// '  try:\n
32,32,116,114,121,58,10,
// '    module = importlib.import_module(module_name)\n
32,32,32,32,109,111,100,117,108,101,32,61,32,105,109,112,111,114,116,108,105,
98,46,105,109,112,111,114,116,95,109,111,100,117,108,101,40,109,111,100,117,
108,101,95,110,97,109,101,41,10,
// '    module_file = inspect.getfile(module)\n
32,32,32,32,109,111,100,117,108,101,95,102,105,108,101,32,61,32,105,110,115,
112,101,99,116,46,103,101,116,102,105,108,101,40,109,111,100,117,108,101,41,
10,
// '    return os.path.abspath(module_file)\n
32,32,32,32,114,101,116,117,114,110,32,111,115,46,112,97,116,104,46,97,98,115,
112,97,116,104,40,109,111,100,117,108,101,95,102,105,108,101,41,10,
// '  except (ImportError, TypeError) as e:\n
32,32,101,120,99,101,112,116,32,40,73,109,112,111,114,116,69,114,114,111,114,
44,32,84,121,112,101,69,114,114,111,114,41,32,97,115,32,101,58,10,
// '    print(f"Error importing module {module_name}: {e}")\n
32,32,32,32,112,114,105,110,116,40,102,34,69,114,114,111,114,32,105,109,112,
111,114,116,105,110,103,32,109,111,100,117,108,101,32,123,109,111,100,117,108,
101,95,110,97,109,101,125,58,32,123,101,125,34,41,10,
// '    return None\n
32,32,32,32,114,101,116,117,114,110,32,78,111,110,101,10,
// '\n
10,
// '\n
10,
// 'def mysum(x, n):\n
100,101,102,32,109,121,115,117,109,40,120,44,32,110,41,58,10,
// '    s = 0.0\n
32,32,32,32,115,32,61,32,48,46,48,10,
// '    for i in range(n):\n
32,32,32,32,102,111,114,32,105,32,105,110,32,114,97,110,103,101,40,110,41,58,
10,
// '        s+=x[i]\n
32,32,32,32,32,32,32,32,115,43,61,120,91,105,93,10,
// '    return s\n
32,32,32,32,114,101,116,117,114,110,32,115,10,
// '\n
10,
// 'def mean(lst, n):\n
100,101,102,32,109,101,97,110,40,108,115,116,44,32,110,41,58,10,
// '    return mysum(lst,n) / n\n
32,32,32,32,114,101,116,117,114,110,32,109,121,115,117,109,40,108,115,116,44,
110,41,32,47,32,110,10,
// '\n
10,
// 'class pearson:    \n
99,108,97,115,115,32,112,101,97,114,115,111,110,58,32,32,32,32,10,
// '  def __init__(self,N):\n
32,32,100,101,102,32,95,95,105,110,105,116,95,95,40,115,101,108,102,44,78,41,
58,10,
// '    self.sX=0\n
32,32,32,32,115,101,108,102,46,115,88,61,48,10,
// '    self.sX2=0\n
32,32,32,32,115,101,108,102,46,115,88,50,61,48,10,
// '    self.sY=0\n
32,32,32,32,115,101,108,102,46,115,89,61,48,10,
// '    self.sY2=0\n
32,32,32,32,115,101,108,102,46,115,89,50,61,48,10,
// '    self.sXY=0\n
32,32,32,32,115,101,108,102,46,115,88,89,61,48,10,
// '    self.n=N\n
32,32,32,32,115,101,108,102,46,110,61,78,10,
// '\n
10,
// '  def step(self,x,y):\n
32,32,100,101,102,32,115,116,101,112,40,115,101,108,102,44,120,44,121,41,58,
10,
// '    self.sX+=x\n
32,32,32,32,115,101,108,102,46,115,88,43,61,120,10,
// '    self.sY+=y\n
32,32,32,32,115,101,108,102,46,115,89,43,61,121,10,
// '    self.sX2+=x*x\n
32,32,32,32,115,101,108,102,46,115,88,50,43,61,120,42,120,10,
// '    self.sY2+=y*y\n
32,32,32,32,115,101,108,102,46,115,89,50,43,61,121,42,121,10,
// '    self.sXY+=x*y\n
32,32,32,32,115,101,108,102,46,115,88,89,43,61,120,42,121,10,
// '\n
10,
// '  def final(self):\n
32,32,100,101,102,32,102,105,110,97,108,40,115,101,108,102,41,58,10,
// '    numerator = self.n * self.sXY - self.sX * self.sY\n
32,32,32,32,110,117,109,101,114,97,116,111,114,32,61,32,115,101,108,102,46,110,
32,42,32,115,101,108,102,46,115,88,89,32,45,32,115,101,108,102,46,115,88,32,
42,32,115,101,108,102,46,115,89,10,
// '    denominator_X = self.n * self.sX2 - self.sX**2\n
32,32,32,32,100,101,110,111,109,105,110,97,116,111,114,95,88,32,61,32,115,101,
108,102,46,110,32,42,32,115,101,108,102,46,115,88,50,32,45,32,115,101,108,102,
46,115,88,42,42,50,10,
// '    denominator_Y = self.n * self.sY2 - self.sY**2\n
32,32,32,32,100,101,110,111,109,105,110,97,116,111,114,95,89,32,61,32,115,101,
108,102,46,110,32,42,32,115,101,108,102,46,115,89,50,32,45,32,115,101,108,102,
46,115,89,42,42,50,10,
// '\n
10,
// '    r = numerator / (denominator_X**0.5 * denominator_Y**0.5)\n
32,32,32,32,114,32,61,32,110,117,109,101,114,97,116,111,114,32,47,32,40,100,
101,110,111,109,105,110,97,116,111,114,95,88,42,42,48,46,53,32,42,32,100,101,
110,111,109,105,110,97,116,111,114,95,89,42,42,48,46,53,41,10,
// '    return r\n
32,32,32,32,114,101,116,117,114,110,32,114,10,
// '    #d = (math.sqrt(self.n*self.sX2-self.sX*self.sX)*math.sqrt(self.n*self.sY2-self.sY*self.sY))\n
32,32,32,32,35,100,32,61,32,40,109,97,116,104,46,115,113,114,116,40,115,101,
108,102,46,110,42,115,101,108,102,46,115,88,50,45,115,101,108,102,46,115,88,
42,115,101,108,102,46,115,88,41,42,109,97,116,104,46,115,113,114,116,40,115,
101,108,102,46,110,42,115,101,108,102,46,115,89,50,45,115,101,108,102,46,115,
89,42,115,101,108,102,46,115,89,41,41,10,
// '    #return (self.n*self.sXY-self.sX*self.sY)/d\n
32,32,32,32,35,114,101,116,117,114,110,32,40,115,101,108,102,46,110,42,115,101,
108,102,46,115,88,89,45,115,101,108,102,46,115,88,42,115,101,108,102,46,115,
89,41,47,100,10,
// '\n
10,
// 'def multi(x):\n
100,101,102,32,109,117,108,116,105,40,120,41,58,10,
// '    return x*2\n
32,32,32,32,114,101,116,117,114,110,32,120,42,50,10,
// '\n
10,
// 'def multiv(X,n):\n
100,101,102,32,109,117,108,116,105,118,40,88,44,110,41,58,10,
// '    for i in range(n):\n
32,32,32,32,102,111,114,32,105,32,105,110,32,114,97,110,103,101,40,110,41,58,
10,
// '        X[i] = 2*X[i]\n
32,32,32,32,32,32,32,32,88,91,105,93,32,61,32,50,42,88,91,105,93,10,
// '    return X\n
32,32,32,32,114,101,116,117,114,110,32,88,10,
// 'def pearson_correlation(X, Y, n):\n
100,101,102,32,112,101,97,114,115,111,110,95,99,111,114,114,101,108,97,116,105,
111,110,40,88,44,32,89,44,32,110,41,58,10,
// '  #person = pearson(n)\n
32,32,35,112,101,114,115,111,110,32,61,32,112,101,97,114,115,111,110,40,110,
41,10,
// '  #for i in range(n):\n
32,32,35,102,111,114,32,105,32,105,110,32,114,97,110,103,101,40,110,41,58,10,
// '  #    person.step(multi(X[i]),multi(Y[i]))\n
32,32,35,32,32,32,32,112,101,114,115,111,110,46,115,116,101,112,40,109,117,108,
116,105,40,88,91,105,93,41,44,109,117,108,116,105,40,89,91,105,93,41,41,10,
// '  #return person.final()\n
32,32,35,114,101,116,117,114,110,32,112,101,114,115,111,110,46,102,105,110,97,
108,40,41,10,
// '  X = multiv(X,n)\n
32,32,88,32,61,32,109,117,108,116,105,118,40,88,44,110,41,10,
// '  Y = multiv(Y,n)\n
32,32,89,32,61,32,109,117,108,116,105,118,40,89,44,110,41,10,
// '  sum_X = 0\n
32,32,115,117,109,95,88,32,61,32,48,10,
// '  sum_Y = 0\n
32,32,115,117,109,95,89,32,61,32,48,10,
// '  sum_XY = 0\n
32,32,115,117,109,95,88,89,32,61,32,48,10,
// '  sum_X_squared = 0\n
32,32,115,117,109,95,88,95,115,113,117,97,114,101,100,32,61,32,48,10,
// '  sum_Y_squared = 0\n
32,32,115,117,109,95,89,95,115,113,117,97,114,101,100,32,61,32,48,10,
// '  \n
32,32,10,
// '  for i in range(n):\n
32,32,102,111,114,32,105,32,105,110,32,114,97,110,103,101,40,110,41,58,10,
// '    x = X[i]\n
32,32,32,32,120,32,61,32,88,91,105,93,10,
// '    y = Y[i]\n
32,32,32,32,121,32,61,32,89,91,105,93,10,
// '\n
10,
// '    sum_X += x\n
32,32,32,32,115,117,109,95,88,32,43,61,32,120,10,
// '    sum_Y += y\n
32,32,32,32,115,117,109,95,89,32,43,61,32,121,10,
// '    sum_XY += x * y\n
32,32,32,32,115,117,109,95,88,89,32,43,61,32,120,32,42,32,121,10,
// '    sum_X_squared += x**2\n
32,32,32,32,115,117,109,95,88,95,115,113,117,97,114,101,100,32,43,61,32,120,
42,42,50,10,
// '    sum_Y_squared += y**2\n
32,32,32,32,115,117,109,95,89,95,115,113,117,97,114,101,100,32,43,61,32,121,
42,42,50,10,
// '\n
10,
// '  # Calculate Pearson correlation coefficient\n
32,32,35,32,67,97,108,99,117,108,97,116,101,32,80,101,97,114,115,111,110,32,
99,111,114,114,101,108,97,116,105,111,110,32,99,111,101,102,102,105,99,105,101,
110,116,10,
// '  numerator = n * sum_XY - sum_X * sum_Y\n
32,32,110,117,109,101,114,97,116,111,114,32,61,32,110,32,42,32,115,117,109,95,
88,89,32,45,32,115,117,109,95,88,32,42,32,115,117,109,95,89,10,
// '  denominator_X = n * sum_X_squared - sum_X**2\n
32,32,100,101,110,111,109,105,110,97,116,111,114,95,88,32,61,32,110,32,42,32,
115,117,109,95,88,95,115,113,117,97,114,101,100,32,45,32,115,117,109,95,88,42,
42,50,10,
// '  denominator_Y = n * sum_Y_squared - sum_Y**2\n
32,32,100,101,110,111,109,105,110,97,116,111,114,95,89,32,61,32,110,32,42,32,
115,117,109,95,89,95,115,113,117,97,114,101,100,32,45,32,115,117,109,95,89,42,
42,50,10,
// '\n
10,
// '  r = numerator / (denominator_X**0.5 * denominator_Y**0.5)\n
32,32,114,32,61,32,110,117,109,101,114,97,116,111,114,32,47,32,40,100,101,110,
111,109,105,110,97,116,111,114,95,88,42,42,48,46,53,32,42,32,100,101,110,111,
109,105,110,97,116,111,114,95,89,42,42,48,46,53,41,10,
// '  print(r)\n
32,32,112,114,105,110,116,40,114,41,10,
// '  return r\n
32,32,114,101,116,117,114,110,32,114,10,
// '\n
10,
// 'def parse_args(input_list):\n
100,101,102,32,112,97,114,115,101,95,97,114,103,115,40,105,110,112,117,116,95,
108,105,115,116,41,58,10,
// '  kv_dict = {}\n
32,32,107,118,95,100,105,99,116,32,61,32,123,125,10,
// '  rest = []\n
32,32,114,101,115,116,32,61,32,91,93,10,
// '\n
10,
// '  def parse_value(val):\n
32,32,100,101,102,32,112,97,114,115,101,95,118,97,108,117,101,40,118,97,108,
41,58,10,
// '    val_lower = val.lower()\n
32,32,32,32,118,97,108,95,108,111,119,101,114,32,61,32,118,97,108,46,108,111,
119,101,114,40,41,10,
// "    if val_lower == 'true':\n
32,32,32,32,105,102,32,118,97,108,95,108,111,119,101,114,32,61,61,32,39,116,
114,117,101,39,58,10,
// '        return True\n
32,32,32,32,32,32,32,32,114,101,116,117,114,110,32,84,114,117,101,10,
// "    elif val_lower == 'false':\n
32,32,32,32,101,108,105,102,32,118,97,108,95,108,111,119,101,114,32,61,61,32,
39,102,97,108,115,101,39,58,10,
// '        return False\n
32,32,32,32,32,32,32,32,114,101,116,117,114,110,32,70,97,108,115,101,10,
// '    try:\n
32,32,32,32,116,114,121,58,10,
// '        return int(val)\n
32,32,32,32,32,32,32,32,114,101,116,117,114,110,32,105,110,116,40,118,97,108,
41,10,
// '    except ValueError:\n
32,32,32,32,101,120,99,101,112,116,32,86,97,108,117,101,69,114,114,111,114,58,
10,
// '        try:\n
32,32,32,32,32,32,32,32,116,114,121,58,10,
// '            return float(val)\n
32,32,32,32,32,32,32,32,32,32,32,32,114,101,116,117,114,110,32,102,108,111,97,
116,40,118,97,108,41,10,
// '        except ValueError:\n
32,32,32,32,32,32,32,32,101,120,99,101,112,116,32,86,97,108,117,101,69,114,114,
111,114,58,10,
// '            return val  # return as string if all conversions fail\n
32,32,32,32,32,32,32,32,32,32,32,32,114,101,116,117,114,110,32,118,97,108,32,
32,35,32,114,101,116,117,114,110,32,97,115,32,115,116,114,105,110,103,32,105,
102,32,97,108,108,32,99,111,110,118,101,114,115,105,111,110,115,32,102,97,105,
108,10,
// '\n
10,
// '  for item in input_list:\n
32,32,102,111,114,32,105,116,101,109,32,105,110,32,105,110,112,117,116,95,108,
105,115,116,58,10,
// "    if ':' in item:\n
32,32,32,32,105,102,32,39,58,39,32,105,110,32,105,116,101,109,58,10,
// "        key, value = item.split(':', 1)\n
32,32,32,32,32,32,32,32,107,101,121,44,32,118,97,108,117,101,32,61,32,105,116,
101,109,46,115,112,108,105,116,40,39,58,39,44,32,49,41,10,
// '        kv_dict[key] = parse_value(value)\n
32,32,32,32,32,32,32,32,107,118,95,100,105,99,116,91,107,101,121,93,32,61,32,
112,97,114,115,101,95,118,97,108,117,101,40,118,97,108,117,101,41,10,
// '    else:\n
32,32,32,32,101,108,115,101,58,10,
// '        rest.append(item)\n
32,32,32,32,32,32,32,32,114,101,115,116,46,97,112,112,101,110,100,40,105,116,
101,109,41,10,
// '\n
10,
// '  return kv_dict, rest\n
32,32,114,101,116,117,114,110,32,107,118,95,100,105,99,116,44,32,114,101,115,
116,10,
// '\n
10,
0 };
#ifdef PYPY_VERSION
# define _CFFI_PYTHON_STARTUP_FUNC  _cffi_pypyinit_my_plugin
#elif PY_MAJOR_VERSION >= 3
# define _CFFI_PYTHON_STARTUP_FUNC  PyInit_my_plugin
#else
# define _CFFI_PYTHON_STARTUP_FUNC  initmy_plugin
#endif

/***** Support code for embedding *****/

#ifdef __cplusplus
extern "C" {
#endif


#if defined(_WIN32)
#  define CFFI_DLLEXPORT  __declspec(dllexport)
#elif defined(__GNUC__)
#  define CFFI_DLLEXPORT  __attribute__((visibility("default")))
#else
#  define CFFI_DLLEXPORT  /* nothing */
#endif


/* There are two global variables of type _cffi_call_python_fnptr:

   * _cffi_call_python, which we declare just below, is the one called
     by ``extern "Python"`` implementations.

   * _cffi_call_python_org, which on CPython is actually part of the
     _cffi_exports[] array, is the function pointer copied from
     _cffi_backend.  If _cffi_start_python() fails, then this is set
     to NULL; otherwise, it should never be NULL.

   After initialization is complete, both are equal.  However, the
   first one remains equal to &_cffi_start_and_call_python until the
   very end of initialization, when we are (or should be) sure that
   concurrent threads also see a completely initialized world, and
   only then is it changed.
*/
#undef _cffi_call_python
typedef void (*_cffi_call_python_fnptr)(struct _cffi_externpy_s *, char *);
static void _cffi_start_and_call_python(struct _cffi_externpy_s *, char *);
static _cffi_call_python_fnptr _cffi_call_python = &_cffi_start_and_call_python;


#ifndef _MSC_VER
   /* --- Assuming a GCC not infinitely old --- */
# define cffi_compare_and_swap(l,o,n)  __sync_bool_compare_and_swap(l,o,n)
# define cffi_write_barrier()          __sync_synchronize()
# if !defined(__amd64__) && !defined(__x86_64__) &&   \
     !defined(__i386__) && !defined(__i386)
#   define cffi_read_barrier()         __sync_synchronize()
# else
#   define cffi_read_barrier()         (void)0
# endif
#else
   /* --- Windows threads version --- */
# include <Windows.h>
# define cffi_compare_and_swap(l,o,n) \
                               (InterlockedCompareExchangePointer(l,n,o) == (o))
# define cffi_write_barrier()       InterlockedCompareExchange(&_cffi_dummy,0,0)
# define cffi_read_barrier()           (void)0
static volatile LONG _cffi_dummy;
#endif

#ifdef WITH_THREAD
# ifndef _MSC_VER
#  include <pthread.h>
   static pthread_mutex_t _cffi_embed_startup_lock;
# else
   static CRITICAL_SECTION _cffi_embed_startup_lock;
# endif
  static char _cffi_embed_startup_lock_ready = 0;
#endif

static void _cffi_acquire_reentrant_mutex(void)
{
    static void *volatile lock = NULL;

    while (!cffi_compare_and_swap(&lock, NULL, (void *)1)) {
        /* should ideally do a spin loop instruction here, but
           hard to do it portably and doesn't really matter I
           think: pthread_mutex_init() should be very fast, and
           this is only run at start-up anyway. */
    }

#ifdef WITH_THREAD
    if (!_cffi_embed_startup_lock_ready) {
# ifndef _MSC_VER
        pthread_mutexattr_t attr;
        pthread_mutexattr_init(&attr);
        pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
        pthread_mutex_init(&_cffi_embed_startup_lock, &attr);
# else
        InitializeCriticalSection(&_cffi_embed_startup_lock);
# endif
        _cffi_embed_startup_lock_ready = 1;
    }
#endif

    while (!cffi_compare_and_swap(&lock, (void *)1, NULL))
        ;

#ifndef _MSC_VER
    pthread_mutex_lock(&_cffi_embed_startup_lock);
#else
    EnterCriticalSection(&_cffi_embed_startup_lock);
#endif
}

static void _cffi_release_reentrant_mutex(void)
{
#ifndef _MSC_VER
    pthread_mutex_unlock(&_cffi_embed_startup_lock);
#else
    LeaveCriticalSection(&_cffi_embed_startup_lock);
#endif
}


/**********  CPython-specific section  **********/
#ifndef PYPY_VERSION

#ifndef CFFI_MESSAGEBOX
# ifdef _MSC_VER
#  define CFFI_MESSAGEBOX  1
# else
#  define CFFI_MESSAGEBOX  0
# endif
#endif


#if CFFI_MESSAGEBOX
/* Windows only: logic to take the Python-CFFI embedding logic
   initialization errors and display them in a background thread
   with MessageBox.  The idea is that if the whole program closes
   as a result of this problem, then likely it is already a console
   program and you can read the stderr output in the console too.
   If it is not a console program, then it will likely show its own
   dialog to complain, or generally not abruptly close, and for this
   case the background thread should stay alive.
*/
static void *volatile _cffi_bootstrap_text;

static PyObject *_cffi_start_error_capture(void)
{
    PyObject *result = NULL;
    PyObject *x, *m, *bi;

    if (InterlockedCompareExchangePointer(&_cffi_bootstrap_text,
            (void *)1, NULL) != NULL)
        return (PyObject *)1;

    m = PyImport_AddModule("_cffi_error_capture");
    if (m == NULL)
        goto error;

    result = PyModule_GetDict(m);
    if (result == NULL)
        goto error;

#if PY_MAJOR_VERSION >= 3
    bi = PyImport_ImportModule("builtins");
#else
    bi = PyImport_ImportModule("__builtin__");
#endif
    if (bi == NULL)
        goto error;
    PyDict_SetItemString(result, "__builtins__", bi);
    Py_DECREF(bi);

    x = PyRun_String(
        "import sys\n"
        "class FileLike:\n"
        "  def write(self, x):\n"
        "    try:\n"
        "      of.write(x)\n"
        "    except: pass\n"
        "    self.buf += x\n"
        "  def flush(self):\n"
        "    pass\n"
        "fl = FileLike()\n"
        "fl.buf = ''\n"
        "of = sys.stderr\n"
        "sys.stderr = fl\n"
        "def done():\n"
        "  sys.stderr = of\n"
        "  return fl.buf\n",   /* make sure the returned value stays alive */
        Py_file_input,
        result, result);
    Py_XDECREF(x);

 error:
    if (PyErr_Occurred())
    {
        PyErr_WriteUnraisable(Py_None);
        PyErr_Clear();
    }
    return result;
}

#pragma comment(lib, "user32.lib")

static DWORD WINAPI _cffi_bootstrap_dialog(LPVOID ignored)
{
    Sleep(666);    /* may be interrupted if the whole process is closing */
#if PY_MAJOR_VERSION >= 3
    MessageBoxW(NULL, (wchar_t *)_cffi_bootstrap_text,
                L"Python-CFFI error",
                MB_OK | MB_ICONERROR);
#else
    MessageBoxA(NULL, (char *)_cffi_bootstrap_text,
                "Python-CFFI error",
                MB_OK | MB_ICONERROR);
#endif
    _cffi_bootstrap_text = NULL;
    return 0;
}

static void _cffi_stop_error_capture(PyObject *ecap)
{
    PyObject *s;
    void *text;

    if (ecap == (PyObject *)1)
        return;

    if (ecap == NULL)
        goto error;

    s = PyRun_String("done()", Py_eval_input, ecap, ecap);
    if (s == NULL)
        goto error;

    /* Show a dialog box, but in a background thread, and
       never show multiple dialog boxes at once. */
#if PY_MAJOR_VERSION >= 3
    text = PyUnicode_AsWideCharString(s, NULL);
#else
    text = PyString_AsString(s);
#endif

    _cffi_bootstrap_text = text;

    if (text != NULL)
    {
        HANDLE h;
        h = CreateThread(NULL, 0, _cffi_bootstrap_dialog,
                         NULL, 0, NULL);
        if (h != NULL)
            CloseHandle(h);
    }
    /* decref the string, but it should stay alive as 'fl.buf'
       in the small module above.  It will really be freed only if
       we later get another similar error.  So it's a leak of at
       most one copy of the small module.  That's fine for this
       situation which is usually a "fatal error" anyway. */
    Py_DECREF(s);
    PyErr_Clear();
    return;

  error:
    _cffi_bootstrap_text = NULL;
    PyErr_Clear();
}

#else

static PyObject *_cffi_start_error_capture(void) { return NULL; }
static void _cffi_stop_error_capture(PyObject *ecap) { }

#endif


#define _cffi_call_python_org  _cffi_exports[_CFFI_CPIDX]

PyMODINIT_FUNC _CFFI_PYTHON_STARTUP_FUNC(void);   /* forward */

static void _cffi_py_initialize(void)
{
    /* XXX use initsigs=0, which "skips initialization registration of
       signal handlers, which might be useful when Python is
       embedded" according to the Python docs.  But review and think
       if it should be a user-controllable setting.

       XXX we should also give a way to write errors to a buffer
       instead of to stderr.

       XXX if importing 'site' fails, CPython (any version) calls
       exit().  Should we try to work around this behavior here?
    */
    Py_InitializeEx(0);
}

static int _cffi_initialize_python(void)
{
    /* This initializes Python, imports _cffi_backend, and then the
       present .dll/.so is set up as a CPython C extension module.
    */
    int result;
    PyGILState_STATE state;
    PyObject *pycode=NULL, *global_dict=NULL, *x;
    PyObject *builtins;

    state = PyGILState_Ensure();

    /* Call the initxxx() function from the present module.  It will
       create and initialize us as a CPython extension module, instead
       of letting the startup Python code do it---it might reimport
       the same .dll/.so and get maybe confused on some platforms.
       It might also have troubles locating the .dll/.so again for all
       I know.
    */
    (void)_CFFI_PYTHON_STARTUP_FUNC();
    if (PyErr_Occurred())
        goto error;

    /* Now run the Python code provided to ffi.embedding_init_code().
     */
    pycode = Py_CompileString(_CFFI_PYTHON_STARTUP_CODE,
                              "<init code for '" _CFFI_MODULE_NAME "'>",
                              Py_file_input);
    if (pycode == NULL)
        goto error;
    global_dict = PyDict_New();
    if (global_dict == NULL)
        goto error;
    builtins = PyEval_GetBuiltins();
    if (builtins == NULL)
        goto error;
    if (PyDict_SetItemString(global_dict, "__builtins__", builtins) < 0)
        goto error;
    x = PyEval_EvalCode(
#if PY_MAJOR_VERSION < 3
                        (PyCodeObject *)
#endif
                        pycode, global_dict, global_dict);
    if (x == NULL)
        goto error;
    Py_DECREF(x);

    /* Done!  Now if we've been called from
       _cffi_start_and_call_python() in an ``extern "Python"``, we can
       only hope that the Python code did correctly set up the
       corresponding @ffi.def_extern() function.  Otherwise, the
       general logic of ``extern "Python"`` functions (inside the
       _cffi_backend module) will find that the reference is still
       missing and print an error.
     */
    result = 0;
 done:
    Py_XDECREF(pycode);
    Py_XDECREF(global_dict);
    PyGILState_Release(state);
    return result;

 error:;
    {
        /* Print as much information as potentially useful.
           Debugging load-time failures with embedding is not fun
        */
        PyObject *ecap;
        PyObject *exception, *v, *tb, *f, *modules, *mod;
        PyErr_Fetch(&exception, &v, &tb);
        ecap = _cffi_start_error_capture();
        f = PySys_GetObject((char *)"stderr");
        if (f != NULL && f != Py_None) {
            PyFile_WriteString(
                "Failed to initialize the Python-CFFI embedding logic:\n\n", f);
        }

        if (exception != NULL) {
            PyErr_NormalizeException(&exception, &v, &tb);
            PyErr_Display(exception, v, tb);
        }
        Py_XDECREF(exception);
        Py_XDECREF(v);
        Py_XDECREF(tb);

        if (f != NULL && f != Py_None) {
            PyFile_WriteString("\nFrom: " _CFFI_MODULE_NAME
                               "\ncompiled with cffi version: 1.17.0"
                               "\n_cffi_backend module: ", f);
            modules = PyImport_GetModuleDict();
            mod = PyDict_GetItemString(modules, "_cffi_backend");
            if (mod == NULL) {
                PyFile_WriteString("not loaded", f);
            }
            else {
                v = PyObject_GetAttrString(mod, "__file__");
                PyFile_WriteObject(v, f, 0);
                Py_XDECREF(v);
            }
            PyFile_WriteString("\nsys.path: ", f);
            PyFile_WriteObject(PySys_GetObject((char *)"path"), f, 0);
            PyFile_WriteString("\n\n", f);
        }
        _cffi_stop_error_capture(ecap);
    }
    result = -1;
    goto done;
}

#if PY_VERSION_HEX < 0x03080000
PyAPI_DATA(char *) _PyParser_TokenNames[];  /* from CPython */
#endif

static int _cffi_carefully_make_gil(void)
{
    /* This does the basic initialization of Python.  It can be called
       completely concurrently from unrelated threads.  It assumes
       that we don't hold the GIL before (if it exists), and we don't
       hold it afterwards.

       (What it really does used to be completely different in Python 2
       and Python 3, with the Python 2 solution avoiding the spin-lock
       around the Py_InitializeEx() call.  However, after recent changes
       to CPython 2.7 (issue #358) it no longer works.  So we use the
       Python 3 solution everywhere.)

       This initializes Python by calling Py_InitializeEx().
       Important: this must not be called concurrently at all.
       So we use a global variable as a simple spin lock.  This global
       variable must be from 'libpythonX.Y.so', not from this
       cffi-based extension module, because it must be shared from
       different cffi-based extension modules.

       In Python < 3.8, we choose
       _PyParser_TokenNames[0] as a completely arbitrary pointer value
       that is never written to.  The default is to point to the
       string "ENDMARKER".  We change it temporarily to point to the
       next character in that string.  (Yes, I know it's REALLY
       obscure.)

       In Python >= 3.8, this string array is no longer writable, so
       instead we pick PyCapsuleType.tp_version_tag.  We can't change
       Python < 3.8 because someone might use a mixture of cffi
       embedded modules, some of which were compiled before this file
       changed.

       In Python >= 3.12, this stopped working because that particular
       tp_version_tag gets modified during interpreter startup.  It's
       arguably a bad idea before 3.12 too, but again we can't change
       that because someone might use a mixture of cffi embedded
       modules, and no-one reported a bug so far.  In Python >= 3.12
       we go instead for PyCapsuleType.tp_as_buffer, which is supposed
       to always be NULL.  We write to it temporarily a pointer to
       a struct full of NULLs, which is semantically the same.
    */

#ifdef WITH_THREAD
# if PY_VERSION_HEX < 0x03080000
    char *volatile *lock = (char *volatile *)_PyParser_TokenNames;
    char *old_value, *locked_value;

    while (1) {    /* spin loop */
        old_value = *lock;
        locked_value = old_value + 1;
        if (old_value[0] == 'E') {
            assert(old_value[1] == 'N');
            if (cffi_compare_and_swap(lock, old_value, locked_value))
                break;
        }
        else {
            assert(old_value[0] == 'N');
            /* should ideally do a spin loop instruction here, but
               hard to do it portably and doesn't really matter I
               think: PyEval_InitThreads() should be very fast, and
               this is only run at start-up anyway. */
        }
    }
# else
#  if PY_VERSION_HEX < 0x030C0000
    int volatile *lock = (int volatile *)&PyCapsule_Type.tp_version_tag;
    int old_value, locked_value = -42;
    assert(!(PyCapsule_Type.tp_flags & Py_TPFLAGS_HAVE_VERSION_TAG));
#  else
    static struct ebp_s { PyBufferProcs buf; int mark; } empty_buffer_procs;
    empty_buffer_procs.mark = -42;
    PyBufferProcs *volatile *lock = (PyBufferProcs *volatile *)
        &PyCapsule_Type.tp_as_buffer;
    PyBufferProcs *old_value, *locked_value = &empty_buffer_procs.buf;
#  endif

    while (1) {    /* spin loop */
        old_value = *lock;
        if (old_value == 0) {
            if (cffi_compare_and_swap(lock, old_value, locked_value))
                break;
        }
        else {
#  if PY_VERSION_HEX < 0x030C0000
            assert(old_value == locked_value);
#  else
            /* The pointer should point to a possibly different
               empty_buffer_procs from another C extension module */
            assert(((struct ebp_s *)old_value)->mark == -42);
#  endif
            /* should ideally do a spin loop instruction here, but
               hard to do it portably and doesn't really matter I
               think: PyEval_InitThreads() should be very fast, and
               this is only run at start-up anyway. */
        }
    }
# endif
#endif

    /* call Py_InitializeEx() */
    if (!Py_IsInitialized()) {
        _cffi_py_initialize();
#if PY_VERSION_HEX < 0x03070000
        PyEval_InitThreads();
#endif
        PyEval_SaveThread();  /* release the GIL */
        /* the returned tstate must be the one that has been stored into the
           autoTLSkey by _PyGILState_Init() called from Py_Initialize(). */
    }
    else {
#if PY_VERSION_HEX < 0x03070000
        /* PyEval_InitThreads() is always a no-op from CPython 3.7 */
        PyGILState_STATE state = PyGILState_Ensure();
        PyEval_InitThreads();
        PyGILState_Release(state);
#endif
    }

#ifdef WITH_THREAD
    /* release the lock */
    while (!cffi_compare_and_swap(lock, locked_value, old_value))
        ;
#endif

    return 0;
}

/**********  end CPython-specific section  **********/


#else


/**********  PyPy-specific section  **********/

PyMODINIT_FUNC _CFFI_PYTHON_STARTUP_FUNC(const void *[]);   /* forward */

static struct _cffi_pypy_init_s {
    const char *name;
    void *func;    /* function pointer */
    const char *code;
} _cffi_pypy_init = {
    _CFFI_MODULE_NAME,
    _CFFI_PYTHON_STARTUP_FUNC,
    _CFFI_PYTHON_STARTUP_CODE,
};

extern int pypy_carefully_make_gil(const char *);
extern int pypy_init_embedded_cffi_module(int, struct _cffi_pypy_init_s *);

static int _cffi_carefully_make_gil(void)
{
    return pypy_carefully_make_gil(_CFFI_MODULE_NAME);
}

static int _cffi_initialize_python(void)
{
    return pypy_init_embedded_cffi_module(0xB011, &_cffi_pypy_init);
}

/**********  end PyPy-specific section  **********/


#endif


#ifdef __GNUC__
__attribute__((noinline))
#endif
static _cffi_call_python_fnptr _cffi_start_python(void)
{
    /* Delicate logic to initialize Python.  This function can be
       called multiple times concurrently, e.g. when the process calls
       its first ``extern "Python"`` functions in multiple threads at
       once.  It can also be called recursively, in which case we must
       ignore it.  We also have to consider what occurs if several
       different cffi-based extensions reach this code in parallel
       threads---it is a different copy of the code, then, and we
       can't have any shared global variable unless it comes from
       'libpythonX.Y.so'.

       Idea:

       * _cffi_carefully_make_gil(): "carefully" call
         PyEval_InitThreads() (possibly with Py_InitializeEx() first).

       * then we use a (local) custom lock to make sure that a call to this
         cffi-based extension will wait if another call to the *same*
         extension is running the initialization in another thread.
         It is reentrant, so that a recursive call will not block, but
         only one from a different thread.

       * then we grab the GIL and (Python 2) we call Py_InitializeEx().
         At this point, concurrent calls to Py_InitializeEx() are not
         possible: we have the GIL.

       * do the rest of the specific initialization, which may
         temporarily release the GIL but not the custom lock.
         Only release the custom lock when we are done.
    */
    static char called = 0;

    if (_cffi_carefully_make_gil() != 0)
        return NULL;

    _cffi_acquire_reentrant_mutex();

    /* Here the GIL exists, but we don't have it.  We're only protected
       from concurrency by the reentrant mutex. */

    /* This file only initializes the embedded module once, the first
       time this is called, even if there are subinterpreters. */
    if (!called) {
        called = 1;  /* invoke _cffi_initialize_python() only once,
                        but don't set '_cffi_call_python' right now,
                        otherwise concurrent threads won't call
                        this function at all (we need them to wait) */
        if (_cffi_initialize_python() == 0) {
            /* now initialization is finished.  Switch to the fast-path. */

            /* We would like nobody to see the new value of
               '_cffi_call_python' without also seeing the rest of the
               data initialized.  However, this is not possible.  But
               the new value of '_cffi_call_python' is the function
               'cffi_call_python()' from _cffi_backend.  So:  */
            cffi_write_barrier();
            /* ^^^ we put a write barrier here, and a corresponding
               read barrier at the start of cffi_call_python().  This
               ensures that after that read barrier, we see everything
               done here before the write barrier.
            */

            assert(_cffi_call_python_org != NULL);
            _cffi_call_python = (_cffi_call_python_fnptr)_cffi_call_python_org;
        }
        else {
            /* initialization failed.  Reset this to NULL, even if it was
               already set to some other value.  Future calls to
               _cffi_start_python() are still forced to occur, and will
               always return NULL from now on. */
            _cffi_call_python_org = NULL;
        }
    }

    _cffi_release_reentrant_mutex();

    return (_cffi_call_python_fnptr)_cffi_call_python_org;
}

static
void _cffi_start_and_call_python(struct _cffi_externpy_s *externpy, char *args)
{
    _cffi_call_python_fnptr fnptr;
    int current_err = errno;
#ifdef _MSC_VER
    int current_lasterr = GetLastError();
#endif
    fnptr = _cffi_start_python();
    if (fnptr == NULL) {
        fprintf(stderr, "function %s() called, but initialization code "
                        "failed.  Returning 0.\n", externpy->name);
        memset(args, 0, externpy->size_of_result);
    }
#ifdef _MSC_VER
    SetLastError(current_lasterr);
#endif
    errno = current_err;

    if (fnptr != NULL)
        fnptr(externpy, args);
}


/* The cffi_start_python() function makes sure Python is initialized
   and our cffi module is set up.  It can be called manually from the
   user C code.  The same effect is obtained automatically from any
   dll-exported ``extern "Python"`` function.  This function returns
   -1 if initialization failed, 0 if all is OK.  */
_CFFI_UNUSED_FN
static int cffi_start_python(void)
{
    if (_cffi_call_python == &_cffi_start_and_call_python) {
        if (_cffi_start_python() == NULL)
            return -1;
    }
    cffi_read_barrier();
    return 0;
}

#undef cffi_compare_and_swap
#undef cffi_write_barrier
#undef cffi_read_barrier

#ifdef __cplusplus
}
#endif

/************************************************************/


    #include "udfs.h"
    #include <stdlib.h>
    #include <string.h>
    #include <stdint.h>
    void custom_free(char** ptr_array) {
        int i = 0;
        printf("automatic gc collect\n");
        while (1) {
            if (ptr_array[i] != NULL) {
                free(ptr_array[i]);
            }
            else break;
            i++;
        }
        free(ptr_array);
    }
    void custom_free2(char** ptr_array) {
        printf("automatic gc collect\n");
        free(ptr_array);
    }
    void custom_free3(int* ptr_array) {
        printf("automatic gc collect\n");
        free(ptr_array);
    }


/************************************************************/

static void *_cffi_types[] = {
/*  0 */ _CFFI_OP(_CFFI_OP_FUNCTION, 37), // char *()(char const *)
/*  1 */ _CFFI_OP(_CFFI_OP_POINTER, 166), // char const *
/*  2 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/*  3 */ _CFFI_OP(_CFFI_OP_FUNCTION, 5), // int()(ArrayInfo1 *, int, int)
/*  4 */ _CFFI_OP(_CFFI_OP_POINTER, 164), // ArrayInfo1 *
/*  5 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7), // int
/*  6 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/*  7 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/*  8 */ _CFFI_OP(_CFFI_OP_FUNCTION, 5), // int()(char * *, int, ArrayInfo1 *, double *, int *, char * *, int, size_t *)
/*  9 */ _CFFI_OP(_CFFI_OP_POINTER, 37), // char * *
/* 10 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 11 */ _CFFI_OP(_CFFI_OP_NOOP, 4),
/* 12 */ _CFFI_OP(_CFFI_OP_POINTER, 167), // double *
/* 13 */ _CFFI_OP(_CFFI_OP_POINTER, 5), // int *
/* 14 */ _CFFI_OP(_CFFI_OP_NOOP, 9),
/* 15 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 16 */ _CFFI_OP(_CFFI_OP_POINTER, 140), // size_t *
/* 17 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 18 */ _CFFI_OP(_CFFI_OP_FUNCTION, 5), // int()(char * *, int, ArrayInfo1 *, int, ArrayInfo1 *, int)
/* 19 */ _CFFI_OP(_CFFI_OP_NOOP, 9),
/* 20 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 21 */ _CFFI_OP(_CFFI_OP_NOOP, 4),
/* 22 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 23 */ _CFFI_OP(_CFFI_OP_NOOP, 4),
/* 24 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 25 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 26 */ _CFFI_OP(_CFFI_OP_FUNCTION, 5), // int()(char * *, int, int, ArrayInfo1 *, double *, int *, char * *, int, ArrayInfo1 *, int, char *, int, int)
/* 27 */ _CFFI_OP(_CFFI_OP_NOOP, 9),
/* 28 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 29 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 30 */ _CFFI_OP(_CFFI_OP_NOOP, 4),
/* 31 */ _CFFI_OP(_CFFI_OP_NOOP, 12),
/* 32 */ _CFFI_OP(_CFFI_OP_NOOP, 13),
/* 33 */ _CFFI_OP(_CFFI_OP_NOOP, 9),
/* 34 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 35 */ _CFFI_OP(_CFFI_OP_NOOP, 4),
/* 36 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 37 */ _CFFI_OP(_CFFI_OP_POINTER, 166), // char *
/* 38 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 39 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 40 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 41 */ _CFFI_OP(_CFFI_OP_FUNCTION, 5), // int()(char * *, int, int, ArrayInfo1 *, double *, int *, char * *, int, int)
/* 42 */ _CFFI_OP(_CFFI_OP_NOOP, 9),
/* 43 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 44 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 45 */ _CFFI_OP(_CFFI_OP_NOOP, 4),
/* 46 */ _CFFI_OP(_CFFI_OP_NOOP, 12),
/* 47 */ _CFFI_OP(_CFFI_OP_NOOP, 13),
/* 48 */ _CFFI_OP(_CFFI_OP_NOOP, 9),
/* 49 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 50 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 51 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 52 */ _CFFI_OP(_CFFI_OP_FUNCTION, 5), // int()(char *, int, ArrayInfo1 *, double *, int *, char * *, int, char * *)
/* 53 */ _CFFI_OP(_CFFI_OP_NOOP, 37),
/* 54 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 55 */ _CFFI_OP(_CFFI_OP_NOOP, 4),
/* 56 */ _CFFI_OP(_CFFI_OP_NOOP, 12),
/* 57 */ _CFFI_OP(_CFFI_OP_NOOP, 13),
/* 58 */ _CFFI_OP(_CFFI_OP_NOOP, 9),
/* 59 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 60 */ _CFFI_OP(_CFFI_OP_NOOP, 9),
/* 61 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 62 */ _CFFI_OP(_CFFI_OP_FUNCTION, 5), // int()(char *, int, ArrayInfo1 *, double *, int *, char * *, int, int, char * *)
/* 63 */ _CFFI_OP(_CFFI_OP_NOOP, 37),
/* 64 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 65 */ _CFFI_OP(_CFFI_OP_NOOP, 4),
/* 66 */ _CFFI_OP(_CFFI_OP_NOOP, 12),
/* 67 */ _CFFI_OP(_CFFI_OP_NOOP, 13),
/* 68 */ _CFFI_OP(_CFFI_OP_NOOP, 9),
/* 69 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 70 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 71 */ _CFFI_OP(_CFFI_OP_NOOP, 9),
/* 72 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 73 */ _CFFI_OP(_CFFI_OP_FUNCTION, 5), // int()(char *, int, ArrayInfo1 *, int, ArrayInfo1 *, int *, int, int, int *, char * *)
/* 74 */ _CFFI_OP(_CFFI_OP_NOOP, 37),
/* 75 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 76 */ _CFFI_OP(_CFFI_OP_NOOP, 4),
/* 77 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 78 */ _CFFI_OP(_CFFI_OP_NOOP, 4),
/* 79 */ _CFFI_OP(_CFFI_OP_NOOP, 13),
/* 80 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 81 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 82 */ _CFFI_OP(_CFFI_OP_NOOP, 13),
/* 83 */ _CFFI_OP(_CFFI_OP_NOOP, 9),
/* 84 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 85 */ _CFFI_OP(_CFFI_OP_FUNCTION, 5), // int()(char *, int, ArrayInfo1 *, int, ArrayInfo1 *, int)
/* 86 */ _CFFI_OP(_CFFI_OP_NOOP, 37),
/* 87 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 88 */ _CFFI_OP(_CFFI_OP_NOOP, 4),
/* 89 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 90 */ _CFFI_OP(_CFFI_OP_NOOP, 4),
/* 91 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 92 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 93 */ _CFFI_OP(_CFFI_OP_FUNCTION, 5), // int()(char *, int, ArrayInfo1 *, int, ArrayInfo1 *, int, char *)
/* 94 */ _CFFI_OP(_CFFI_OP_NOOP, 37),
/* 95 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 96 */ _CFFI_OP(_CFFI_OP_NOOP, 4),
/* 97 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 98 */ _CFFI_OP(_CFFI_OP_NOOP, 4),
/* 99 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 100 */ _CFFI_OP(_CFFI_OP_NOOP, 37),
/* 101 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 102 */ _CFFI_OP(_CFFI_OP_FUNCTION, 5), // int()(char *, int, ArrayInfo1 *, int, ArrayInfo1 *, int, char *, char * *)
/* 103 */ _CFFI_OP(_CFFI_OP_NOOP, 37),
/* 104 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 105 */ _CFFI_OP(_CFFI_OP_NOOP, 4),
/* 106 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 107 */ _CFFI_OP(_CFFI_OP_NOOP, 4),
/* 108 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 109 */ _CFFI_OP(_CFFI_OP_NOOP, 37),
/* 110 */ _CFFI_OP(_CFFI_OP_NOOP, 9),
/* 111 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 112 */ _CFFI_OP(_CFFI_OP_FUNCTION, 5), // int()(char *, int, int, ArrayInfo1 *, double *, int *, char * *, int, size_t *, char * *)
/* 113 */ _CFFI_OP(_CFFI_OP_NOOP, 37),
/* 114 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 115 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 116 */ _CFFI_OP(_CFFI_OP_NOOP, 4),
/* 117 */ _CFFI_OP(_CFFI_OP_NOOP, 12),
/* 118 */ _CFFI_OP(_CFFI_OP_NOOP, 13),
/* 119 */ _CFFI_OP(_CFFI_OP_NOOP, 9),
/* 120 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 121 */ _CFFI_OP(_CFFI_OP_NOOP, 16),
/* 122 */ _CFFI_OP(_CFFI_OP_NOOP, 9),
/* 123 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 124 */ _CFFI_OP(_CFFI_OP_FUNCTION, 5), // int()(int, ArrayInfo1 *, int, ArrayInfo1 *, int)
/* 125 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 126 */ _CFFI_OP(_CFFI_OP_NOOP, 4),
/* 127 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 128 */ _CFFI_OP(_CFFI_OP_NOOP, 4),
/* 129 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 130 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 131 */ _CFFI_OP(_CFFI_OP_FUNCTION, 5), // int()(void *)
/* 132 */ _CFFI_OP(_CFFI_OP_POINTER, 183), // void *
/* 133 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 134 */ _CFFI_OP(_CFFI_OP_FUNCTION, 5), // int()(void)
/* 135 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 136 */ _CFFI_OP(_CFFI_OP_FUNCTION, 140), // size_t()(char *)
/* 137 */ _CFFI_OP(_CFFI_OP_NOOP, 37),
/* 138 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 139 */ _CFFI_OP(_CFFI_OP_FUNCTION, 132), // void *()(size_t)
/* 140 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 28), // size_t
/* 141 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 142 */ _CFFI_OP(_CFFI_OP_FUNCTION, 132), // void *()(void *, size_t)
/* 143 */ _CFFI_OP(_CFFI_OP_NOOP, 132),
/* 144 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 28),
/* 145 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 146 */ _CFFI_OP(_CFFI_OP_FUNCTION, 132), // void *()(void *, void const *, size_t)
/* 147 */ _CFFI_OP(_CFFI_OP_NOOP, 132),
/* 148 */ _CFFI_OP(_CFFI_OP_POINTER, 183), // void const *
/* 149 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 28),
/* 150 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 151 */ _CFFI_OP(_CFFI_OP_FUNCTION, 183), // void()(char * *)
/* 152 */ _CFFI_OP(_CFFI_OP_NOOP, 9),
/* 153 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 154 */ _CFFI_OP(_CFFI_OP_FUNCTION, 183), // void()(char *, char *)
/* 155 */ _CFFI_OP(_CFFI_OP_NOOP, 37),
/* 156 */ _CFFI_OP(_CFFI_OP_NOOP, 37),
/* 157 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 158 */ _CFFI_OP(_CFFI_OP_FUNCTION, 183), // void()(int *)
/* 159 */ _CFFI_OP(_CFFI_OP_NOOP, 13),
/* 160 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 161 */ _CFFI_OP(_CFFI_OP_FUNCTION, 183), // void()(void *)
/* 162 */ _CFFI_OP(_CFFI_OP_NOOP, 132),
/* 163 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 164 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 1), // ArrayInfo1
/* 165 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 0), // ArrayInfo
/* 166 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 2), // char
/* 167 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 14), // double
/* 168 */ _CFFI_OP(_CFFI_OP_POINTER, 3), // int(*)(ArrayInfo1 *, int, int)
/* 169 */ _CFFI_OP(_CFFI_OP_POINTER, 8), // int(*)(char * *, int, ArrayInfo1 *, double *, int *, char * *, int, size_t *)
/* 170 */ _CFFI_OP(_CFFI_OP_POINTER, 18), // int(*)(char * *, int, ArrayInfo1 *, int, ArrayInfo1 *, int)
/* 171 */ _CFFI_OP(_CFFI_OP_POINTER, 26), // int(*)(char * *, int, int, ArrayInfo1 *, double *, int *, char * *, int, ArrayInfo1 *, int, char *, int, int)
/* 172 */ _CFFI_OP(_CFFI_OP_POINTER, 41), // int(*)(char * *, int, int, ArrayInfo1 *, double *, int *, char * *, int, int)
/* 173 */ _CFFI_OP(_CFFI_OP_POINTER, 52), // int(*)(char *, int, ArrayInfo1 *, double *, int *, char * *, int, char * *)
/* 174 */ _CFFI_OP(_CFFI_OP_POINTER, 62), // int(*)(char *, int, ArrayInfo1 *, double *, int *, char * *, int, int, char * *)
/* 175 */ _CFFI_OP(_CFFI_OP_POINTER, 73), // int(*)(char *, int, ArrayInfo1 *, int, ArrayInfo1 *, int *, int, int, int *, char * *)
/* 176 */ _CFFI_OP(_CFFI_OP_POINTER, 85), // int(*)(char *, int, ArrayInfo1 *, int, ArrayInfo1 *, int)
/* 177 */ _CFFI_OP(_CFFI_OP_POINTER, 93), // int(*)(char *, int, ArrayInfo1 *, int, ArrayInfo1 *, int, char *)
/* 178 */ _CFFI_OP(_CFFI_OP_POINTER, 102), // int(*)(char *, int, ArrayInfo1 *, int, ArrayInfo1 *, int, char *, char * *)
/* 179 */ _CFFI_OP(_CFFI_OP_POINTER, 112), // int(*)(char *, int, int, ArrayInfo1 *, double *, int *, char * *, int, size_t *, char * *)
/* 180 */ _CFFI_OP(_CFFI_OP_POINTER, 124), // int(*)(int, ArrayInfo1 *, int, ArrayInfo1 *, int)
/* 181 */ _CFFI_OP(_CFFI_OP_POINTER, 131), // int(*)(void *)
/* 182 */ _CFFI_OP(_CFFI_OP_POINTER, 134), // int(*)(void)
/* 183 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 0), // void
};

_CFFI_UNUSED_FN
static void _cffi_checkfld_typedef_ArrayInfo(ArrayInfo *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  (void)((p->type) | 0);  /* check that 'ArrayInfo.type' is an integer */
  { void * *tmp = &p->array; (void)tmp; }
  (void)((p->size) | 0);  /* check that 'ArrayInfo.size' is an integer */
}
struct _cffi_align_typedef_ArrayInfo { char x; ArrayInfo y; };

_CFFI_UNUSED_FN
static void _cffi_checkfld_typedef_ArrayInfo1(ArrayInfo1 *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  (void)((p->type) | 0);  /* check that 'ArrayInfo1.type' is an integer */
  { void * *tmp = &p->array; (void)tmp; }
  (void)((p->size) | 0);  /* check that 'ArrayInfo1.size' is an integer */
}
struct _cffi_align_typedef_ArrayInfo1 { char x; ArrayInfo1 y; };

static struct _cffi_externpy_s _cffi_externpy__aggregatefusionwrapper =
  { "my_plugin.aggregatefusionwrapper", (int)sizeof(int), 0, 0 };

CFFI_DLLEXPORT int aggregatefusionwrapper(char * * a0, int a1, ArrayInfo1 * a2, double * a3, int * a4, char * * a5, int a6, size_t * a7)
{
  char a[64];
  char *p = a;
  *(char * * *)(p + 0) = a0;
  *(int *)(p + 8) = a1;
  *(ArrayInfo1 * *)(p + 16) = a2;
  *(double * *)(p + 24) = a3;
  *(int * *)(p + 32) = a4;
  *(char * * *)(p + 40) = a5;
  *(int *)(p + 48) = a6;
  *(size_t * *)(p + 56) = a7;
  _cffi_call_python(&_cffi_externpy__aggregatefusionwrapper, p);
  return *(int *)p;
}

static struct _cffi_externpy_s _cffi_externpy__aggregatewrapper =
  { "my_plugin.aggregatewrapper", (int)sizeof(int), 0, 0 };

CFFI_DLLEXPORT int aggregatewrapper(char * a0, int a1, int a2, ArrayInfo1 * a3, double * a4, int * a5, char * * a6, int a7, size_t * a8, char * * a9)
{
  char a[80];
  char *p = a;
  *(char * *)(p + 0) = a0;
  *(int *)(p + 8) = a1;
  *(int *)(p + 16) = a2;
  *(ArrayInfo1 * *)(p + 24) = a3;
  *(double * *)(p + 32) = a4;
  *(int * *)(p + 40) = a5;
  *(char * * *)(p + 48) = a6;
  *(int *)(p + 56) = a7;
  *(size_t * *)(p + 64) = a8;
  *(char * * *)(p + 72) = a9;
  _cffi_call_python(&_cffi_externpy__aggregatewrapper, p);
  return *(int *)p;
}

static struct _cffi_externpy_s _cffi_externpy__call_gc =
  { "my_plugin.call_gc", (int)sizeof(int), 0, 0 };

CFFI_DLLEXPORT int call_gc(void)
{
  char a[8];
  char *p = a;
  _cffi_call_python(&_cffi_externpy__call_gc, p);
  return *(int *)p;
}

static struct _cffi_externpy_s _cffi_externpy__disable_gc =
  { "my_plugin.disable_gc", (int)sizeof(int), 0, 0 };

CFFI_DLLEXPORT int disable_gc(void)
{
  char a[8];
  char *p = a;
  _cffi_call_python(&_cffi_externpy__disable_gc, p);
  return *(int *)p;
}

static struct _cffi_externpy_s _cffi_externpy__expandaggrwrapper =
  { "my_plugin.expandaggrwrapper", (int)sizeof(int), 0, 0 };

CFFI_DLLEXPORT int expandaggrwrapper(char * a0, int a1, ArrayInfo1 * a2, int a3, ArrayInfo1 * a4, int * a5, int a6, int a7, int * a8, char * * a9)
{
  char a[80];
  char *p = a;
  *(char * *)(p + 0) = a0;
  *(int *)(p + 8) = a1;
  *(ArrayInfo1 * *)(p + 16) = a2;
  *(int *)(p + 24) = a3;
  *(ArrayInfo1 * *)(p + 32) = a4;
  *(int * *)(p + 40) = a5;
  *(int *)(p + 48) = a6;
  *(int *)(p + 56) = a7;
  *(int * *)(p + 64) = a8;
  *(char * * *)(p + 72) = a9;
  _cffi_call_python(&_cffi_externpy__expandaggrwrapper, p);
  return *(int *)p;
}

static struct _cffi_externpy_s _cffi_externpy__expandwrapper =
  { "my_plugin.expandwrapper", (int)sizeof(int), 0, 0 };

CFFI_DLLEXPORT int expandwrapper(char * a0, int a1, ArrayInfo1 * a2, int a3, ArrayInfo1 * a4, int * a5, int a6, int a7, int * a8, char * * a9)
{
  char a[80];
  char *p = a;
  *(char * *)(p + 0) = a0;
  *(int *)(p + 8) = a1;
  *(ArrayInfo1 * *)(p + 16) = a2;
  *(int *)(p + 24) = a3;
  *(ArrayInfo1 * *)(p + 32) = a4;
  *(int * *)(p + 40) = a5;
  *(int *)(p + 48) = a6;
  *(int *)(p + 56) = a7;
  *(int * *)(p + 64) = a8;
  *(char * * *)(p + 72) = a9;
  _cffi_call_python(&_cffi_externpy__expandwrapper, p);
  return *(int *)p;
}

static struct _cffi_externpy_s _cffi_externpy__freecarray =
  { "my_plugin.freecarray", (int)sizeof(int), 0, 0 };

CFFI_DLLEXPORT int freecarray(ArrayInfo1 * a0, int a1, int a2)
{
  char a[24];
  char *p = a;
  *(ArrayInfo1 * *)(p + 0) = a0;
  *(int *)(p + 8) = a1;
  *(int *)(p + 16) = a2;
  _cffi_call_python(&_cffi_externpy__freecarray, p);
  return *(int *)p;
}

static struct _cffi_externpy_s _cffi_externpy__fusionwrapper =
  { "my_plugin.fusionwrapper", (int)sizeof(int), 0, 0 };

CFFI_DLLEXPORT int fusionwrapper(char * * a0, int a1, int a2, ArrayInfo1 * a3, double * a4, int * a5, char * * a6, int a7, ArrayInfo1 * a8, int a9, char * a10, int a11, int a12)
{
  char a[104];
  char *p = a;
  *(char * * *)(p + 0) = a0;
  *(int *)(p + 8) = a1;
  *(int *)(p + 16) = a2;
  *(ArrayInfo1 * *)(p + 24) = a3;
  *(double * *)(p + 32) = a4;
  *(int * *)(p + 40) = a5;
  *(char * * *)(p + 48) = a6;
  *(int *)(p + 56) = a7;
  *(ArrayInfo1 * *)(p + 64) = a8;
  *(int *)(p + 72) = a9;
  *(char * *)(p + 80) = a10;
  *(int *)(p + 88) = a11;
  *(int *)(p + 96) = a12;
  _cffi_call_python(&_cffi_externpy__fusionwrapper, p);
  return *(int *)p;
}

static struct _cffi_externpy_s _cffi_externpy__myfree =
  { "my_plugin.myfree", (int)sizeof(int), 0, 0 };

CFFI_DLLEXPORT int myfree(void * a0)
{
  char a[8];
  char *p = a;
  *(void * *)(p + 0) = a0;
  _cffi_call_python(&_cffi_externpy__myfree, p);
  return *(int *)p;
}

static struct _cffi_externpy_s _cffi_externpy__numpyudfwrapper =
  { "my_plugin.numpyudfwrapper", (int)sizeof(int), 0, 0 };

CFFI_DLLEXPORT int numpyudfwrapper(char * a0, int a1, ArrayInfo1 * a2, int a3, ArrayInfo1 * a4, int a5, char * a6, char * * a7)
{
  char a[64];
  char *p = a;
  *(char * *)(p + 0) = a0;
  *(int *)(p + 8) = a1;
  *(ArrayInfo1 * *)(p + 16) = a2;
  *(int *)(p + 24) = a3;
  *(ArrayInfo1 * *)(p + 32) = a4;
  *(int *)(p + 40) = a5;
  *(char * *)(p + 48) = a6;
  *(char * * *)(p + 56) = a7;
  _cffi_call_python(&_cffi_externpy__numpyudfwrapper, p);
  return *(int *)p;
}

static struct _cffi_externpy_s _cffi_externpy__numpyudfwrapperwithtests =
  { "my_plugin.numpyudfwrapperwithtests", (int)sizeof(int), 0, 0 };

CFFI_DLLEXPORT int numpyudfwrapperwithtests(char * a0, int a1, ArrayInfo1 * a2, int a3, ArrayInfo1 * a4, int a5, char * a6)
{
  char a[56];
  char *p = a;
  *(char * *)(p + 0) = a0;
  *(int *)(p + 8) = a1;
  *(ArrayInfo1 * *)(p + 16) = a2;
  *(int *)(p + 24) = a3;
  *(ArrayInfo1 * *)(p + 32) = a4;
  *(int *)(p + 40) = a5;
  *(char * *)(p + 48) = a6;
  _cffi_call_python(&_cffi_externpy__numpyudfwrapperwithtests, p);
  return *(int *)p;
}

static struct _cffi_externpy_s _cffi_externpy__rowtablewrapper =
  { "my_plugin.rowtablewrapper", (int)sizeof(int), 0, 0 };

CFFI_DLLEXPORT int rowtablewrapper(char * a0, int a1, ArrayInfo1 * a2, int a3, ArrayInfo1 * a4, int a5)
{
  char a[48];
  char *p = a;
  *(char * *)(p + 0) = a0;
  *(int *)(p + 8) = a1;
  *(ArrayInfo1 * *)(p + 16) = a2;
  *(int *)(p + 24) = a3;
  *(ArrayInfo1 * *)(p + 32) = a4;
  *(int *)(p + 40) = a5;
  _cffi_call_python(&_cffi_externpy__rowtablewrapper, p);
  return *(int *)p;
}

static struct _cffi_externpy_s _cffi_externpy__rowtuplewrapper =
  { "my_plugin.rowtuplewrapper", (int)sizeof(int), 0, 0 };

CFFI_DLLEXPORT int rowtuplewrapper(char * a0, int a1, ArrayInfo1 * a2, int a3, ArrayInfo1 * a4, int a5)
{
  char a[48];
  char *p = a;
  *(char * *)(p + 0) = a0;
  *(int *)(p + 8) = a1;
  *(ArrayInfo1 * *)(p + 16) = a2;
  *(int *)(p + 24) = a3;
  *(ArrayInfo1 * *)(p + 32) = a4;
  *(int *)(p + 40) = a5;
  _cffi_call_python(&_cffi_externpy__rowtuplewrapper, p);
  return *(int *)p;
}

static struct _cffi_externpy_s _cffi_externpy__scalarfusionwrapper =
  { "my_plugin.scalarfusionwrapper", (int)sizeof(int), 0, 0 };

CFFI_DLLEXPORT int scalarfusionwrapper(char * * a0, int a1, int a2, ArrayInfo1 * a3, double * a4, int * a5, char * * a6, int a7, int a8)
{
  char a[72];
  char *p = a;
  *(char * * *)(p + 0) = a0;
  *(int *)(p + 8) = a1;
  *(int *)(p + 16) = a2;
  *(ArrayInfo1 * *)(p + 24) = a3;
  *(double * *)(p + 32) = a4;
  *(int * *)(p + 40) = a5;
  *(char * * *)(p + 48) = a6;
  *(int *)(p + 56) = a7;
  *(int *)(p + 64) = a8;
  _cffi_call_python(&_cffi_externpy__scalarfusionwrapper, p);
  return *(int *)p;
}

static struct _cffi_externpy_s _cffi_externpy__systemwrapper =
  { "my_plugin.systemwrapper", (int)sizeof(int), 0, 0 };

CFFI_DLLEXPORT int systemwrapper(char * a0, int a1, ArrayInfo1 * a2, int a3, ArrayInfo1 * a4, int a5, char * a6, char * * a7)
{
  char a[64];
  char *p = a;
  *(char * *)(p + 0) = a0;
  *(int *)(p + 8) = a1;
  *(ArrayInfo1 * *)(p + 16) = a2;
  *(int *)(p + 24) = a3;
  *(ArrayInfo1 * *)(p + 32) = a4;
  *(int *)(p + 40) = a5;
  *(char * *)(p + 48) = a6;
  *(char * * *)(p + 56) = a7;
  _cffi_call_python(&_cffi_externpy__systemwrapper, p);
  return *(int *)p;
}

static struct _cffi_externpy_s _cffi_externpy__tablefusionwrapper =
  { "my_plugin.tablefusionwrapper", (int)sizeof(int), 0, 0 };

CFFI_DLLEXPORT int tablefusionwrapper(char * * a0, int a1, ArrayInfo1 * a2, int a3, ArrayInfo1 * a4, int a5)
{
  char a[48];
  char *p = a;
  *(char * * *)(p + 0) = a0;
  *(int *)(p + 8) = a1;
  *(ArrayInfo1 * *)(p + 16) = a2;
  *(int *)(p + 24) = a3;
  *(ArrayInfo1 * *)(p + 32) = a4;
  *(int *)(p + 40) = a5;
  _cffi_call_python(&_cffi_externpy__tablefusionwrapper, p);
  return *(int *)p;
}

static struct _cffi_externpy_s _cffi_externpy__tablematerwrapper =
  { "my_plugin.tablematerwrapper", (int)sizeof(int), 0, 0 };

CFFI_DLLEXPORT int tablematerwrapper(int a0, ArrayInfo1 * a1, int a2, ArrayInfo1 * a3, int a4)
{
  char a[40];
  char *p = a;
  *(int *)(p + 0) = a0;
  *(ArrayInfo1 * *)(p + 8) = a1;
  *(int *)(p + 16) = a2;
  *(ArrayInfo1 * *)(p + 24) = a3;
  *(int *)(p + 32) = a4;
  _cffi_call_python(&_cffi_externpy__tablematerwrapper, p);
  return *(int *)p;
}

static struct _cffi_externpy_s _cffi_externpy__tabletuple =
  { "my_plugin.tabletuple", (int)sizeof(int), 0, 0 };

CFFI_DLLEXPORT int tabletuple(char * a0, int a1, ArrayInfo1 * a2, int a3, ArrayInfo1 * a4, int a5)
{
  char a[48];
  char *p = a;
  *(char * *)(p + 0) = a0;
  *(int *)(p + 8) = a1;
  *(ArrayInfo1 * *)(p + 16) = a2;
  *(int *)(p + 24) = a3;
  *(ArrayInfo1 * *)(p + 32) = a4;
  *(int *)(p + 40) = a5;
  _cffi_call_python(&_cffi_externpy__tabletuple, p);
  return *(int *)p;
}

static struct _cffi_externpy_s _cffi_externpy__tableudfwrapper =
  { "my_plugin.tableudfwrapper", (int)sizeof(int), 0, 0 };

CFFI_DLLEXPORT int tableudfwrapper(char * a0, int a1, ArrayInfo1 * a2, int a3, ArrayInfo1 * a4, int a5, char * a6, char * * a7)
{
  char a[64];
  char *p = a;
  *(char * *)(p + 0) = a0;
  *(int *)(p + 8) = a1;
  *(ArrayInfo1 * *)(p + 16) = a2;
  *(int *)(p + 24) = a3;
  *(ArrayInfo1 * *)(p + 32) = a4;
  *(int *)(p + 40) = a5;
  *(char * *)(p + 48) = a6;
  *(char * * *)(p + 56) = a7;
  _cffi_call_python(&_cffi_externpy__tableudfwrapper, p);
  return *(int *)p;
}

static struct _cffi_externpy_s _cffi_externpy__tablevalue =
  { "my_plugin.tablevalue", (int)sizeof(int), 0, 0 };

CFFI_DLLEXPORT int tablevalue(char * a0, int a1, ArrayInfo1 * a2, int a3, ArrayInfo1 * a4, int a5)
{
  char a[48];
  char *p = a;
  *(char * *)(p + 0) = a0;
  *(int *)(p + 8) = a1;
  *(ArrayInfo1 * *)(p + 16) = a2;
  *(int *)(p + 24) = a3;
  *(ArrayInfo1 * *)(p + 32) = a4;
  *(int *)(p + 40) = a5;
  _cffi_call_python(&_cffi_externpy__tablevalue, p);
  return *(int *)p;
}

static struct _cffi_externpy_s _cffi_externpy__udfwrapper =
  { "my_plugin.udfwrapper", (int)sizeof(int), 0, 0 };

CFFI_DLLEXPORT int udfwrapper(char * a0, int a1, ArrayInfo1 * a2, double * a3, int * a4, char * * a5, int a6, int a7, char * * a8)
{
  char a[72];
  char *p = a;
  *(char * *)(p + 0) = a0;
  *(int *)(p + 8) = a1;
  *(ArrayInfo1 * *)(p + 16) = a2;
  *(double * *)(p + 24) = a3;
  *(int * *)(p + 32) = a4;
  *(char * * *)(p + 40) = a5;
  *(int *)(p + 48) = a6;
  *(int *)(p + 56) = a7;
  *(char * * *)(p + 64) = a8;
  _cffi_call_python(&_cffi_externpy__udfwrapper, p);
  return *(int *)p;
}

static struct _cffi_externpy_s _cffi_externpy__udfwrapper_parallel =
  { "my_plugin.udfwrapper_parallel", (int)sizeof(int), 0, 0 };

CFFI_DLLEXPORT int udfwrapper_parallel(char * a0, int a1, ArrayInfo1 * a2, double * a3, int * a4, char * * a5, int a6, char * * a7)
{
  char a[64];
  char *p = a;
  *(char * *)(p + 0) = a0;
  *(int *)(p + 8) = a1;
  *(ArrayInfo1 * *)(p + 16) = a2;
  *(double * *)(p + 24) = a3;
  *(int * *)(p + 32) = a4;
  *(char * * *)(p + 40) = a5;
  *(int *)(p + 48) = a6;
  *(char * * *)(p + 56) = a7;
  _cffi_call_python(&_cffi_externpy__udfwrapper_parallel, p);
  return *(int *)p;
}

static void _cffi_d_custom_free(char * * x0)
{
  custom_free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_custom_free(PyObject *self, PyObject *arg0)
{
  char * * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(9), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (char * *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(9), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { custom_free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_custom_free _cffi_d_custom_free
#endif

static void _cffi_d_custom_free2(char * * x0)
{
  custom_free2(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_custom_free2(PyObject *self, PyObject *arg0)
{
  char * * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(9), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (char * *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(9), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { custom_free2(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_custom_free2 _cffi_d_custom_free2
#endif

static void _cffi_d_custom_free3(int * x0)
{
  custom_free3(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_custom_free3(PyObject *self, PyObject *arg0)
{
  int * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (int *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(13), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { custom_free3(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_custom_free3 _cffi_d_custom_free3
#endif

static void _cffi_d_free(void * x0)
{
  free(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_free(PyObject *self, PyObject *arg0)
{
  void * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(132), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (void *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(132), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { free(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_free _cffi_d_free
#endif

static void * _cffi_d_malloc(size_t x0)
{
  return malloc(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_malloc(PyObject *self, PyObject *arg0)
{
  size_t x0;
  void * result;
  PyObject *pyresult;

  x0 = _cffi_to_c_int(arg0, size_t);
  if (x0 == (size_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = malloc(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(132));
  return pyresult;
}
#else
#  define _cffi_f_malloc _cffi_d_malloc
#endif

static void * _cffi_d_memcpy(void * x0, void const * x1, size_t x2)
{
  return memcpy(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_memcpy(PyObject *self, PyObject *args)
{
  void * x0;
  void const * x1;
  size_t x2;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  void * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;

  if (!PyArg_UnpackTuple(args, "memcpy", 3, 3, &arg0, &arg1, &arg2))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(132), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (void *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(132), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(148), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (void const *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(148), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, size_t);
  if (x2 == (size_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = memcpy(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(132));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_memcpy _cffi_d_memcpy
#endif

static void * _cffi_d_realloc(void * x0, size_t x1)
{
  return realloc(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_realloc(PyObject *self, PyObject *args)
{
  void * x0;
  size_t x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  void * result;
  PyObject *pyresult;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "realloc", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(132), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (void *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(132), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, size_t);
  if (x1 == (size_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = realloc(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(132));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_realloc _cffi_d_realloc
#endif

static void _cffi_d_strcpy(char * x0, char * x1)
{
  strcpy(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_strcpy(PyObject *self, PyObject *args)
{
  char * x0;
  char * x1;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  PyObject *arg0;
  PyObject *arg1;

  if (!PyArg_UnpackTuple(args, "strcpy", 2, 2, &arg0, &arg1))
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(37), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (char *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(37), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(37), arg1, (char **)&x1);
  if (datasize != 0) {
    x1 = ((size_t)datasize) <= 640 ? (char *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(37), arg1, (char **)&x1,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { strcpy(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_strcpy _cffi_d_strcpy
#endif

static char * _cffi_d_strdup(char const * x0)
{
  return strdup(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_strdup(PyObject *self, PyObject *arg0)
{
  char const * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  char * result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (char const *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(1), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = strdup(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_pointer((char *)result, _cffi_type(37));
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_strdup _cffi_d_strdup
#endif

static size_t _cffi_d_strlen(char * x0)
{
  return strlen(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_strlen(PyObject *self, PyObject *arg0)
{
  char * x0;
  Py_ssize_t datasize;
  struct _cffi_freeme_s *large_args_free = NULL;
  size_t result;
  PyObject *pyresult;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(37), arg0, (char **)&x0);
  if (datasize != 0) {
    x0 = ((size_t)datasize) <= 640 ? (char *)alloca((size_t)datasize) : NULL;
    if (_cffi_convert_array_argument(_cffi_type(37), arg0, (char **)&x0,
            datasize, &large_args_free) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = strlen(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  pyresult = _cffi_from_c_int(result, size_t);
  if (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);
  return pyresult;
}
#else
#  define _cffi_f_strlen _cffi_d_strlen
#endif

static const struct _cffi_global_s _cffi_globals[] = {
  { "aggregatefusionwrapper", (void *)&_cffi_externpy__aggregatefusionwrapper, _CFFI_OP(_CFFI_OP_EXTERN_PYTHON, 169), (void *)aggregatefusionwrapper },
  { "aggregatewrapper", (void *)&_cffi_externpy__aggregatewrapper, _CFFI_OP(_CFFI_OP_EXTERN_PYTHON, 179), (void *)aggregatewrapper },
  { "call_gc", (void *)&_cffi_externpy__call_gc, _CFFI_OP(_CFFI_OP_EXTERN_PYTHON, 182), (void *)call_gc },
  { "custom_free", (void *)_cffi_f_custom_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 151), (void *)_cffi_d_custom_free },
  { "custom_free2", (void *)_cffi_f_custom_free2, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 151), (void *)_cffi_d_custom_free2 },
  { "custom_free3", (void *)_cffi_f_custom_free3, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 158), (void *)_cffi_d_custom_free3 },
  { "disable_gc", (void *)&_cffi_externpy__disable_gc, _CFFI_OP(_CFFI_OP_EXTERN_PYTHON, 182), (void *)disable_gc },
  { "expandaggrwrapper", (void *)&_cffi_externpy__expandaggrwrapper, _CFFI_OP(_CFFI_OP_EXTERN_PYTHON, 175), (void *)expandaggrwrapper },
  { "expandwrapper", (void *)&_cffi_externpy__expandwrapper, _CFFI_OP(_CFFI_OP_EXTERN_PYTHON, 175), (void *)expandwrapper },
  { "free", (void *)_cffi_f_free, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 161), (void *)_cffi_d_free },
  { "freecarray", (void *)&_cffi_externpy__freecarray, _CFFI_OP(_CFFI_OP_EXTERN_PYTHON, 168), (void *)freecarray },
  { "fusionwrapper", (void *)&_cffi_externpy__fusionwrapper, _CFFI_OP(_CFFI_OP_EXTERN_PYTHON, 171), (void *)fusionwrapper },
  { "malloc", (void *)_cffi_f_malloc, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 139), (void *)_cffi_d_malloc },
  { "memcpy", (void *)_cffi_f_memcpy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 146), (void *)_cffi_d_memcpy },
  { "myfree", (void *)&_cffi_externpy__myfree, _CFFI_OP(_CFFI_OP_EXTERN_PYTHON, 181), (void *)myfree },
  { "numpyudfwrapper", (void *)&_cffi_externpy__numpyudfwrapper, _CFFI_OP(_CFFI_OP_EXTERN_PYTHON, 178), (void *)numpyudfwrapper },
  { "numpyudfwrapperwithtests", (void *)&_cffi_externpy__numpyudfwrapperwithtests, _CFFI_OP(_CFFI_OP_EXTERN_PYTHON, 177), (void *)numpyudfwrapperwithtests },
  { "realloc", (void *)_cffi_f_realloc, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 142), (void *)_cffi_d_realloc },
  { "rowtablewrapper", (void *)&_cffi_externpy__rowtablewrapper, _CFFI_OP(_CFFI_OP_EXTERN_PYTHON, 176), (void *)rowtablewrapper },
  { "rowtuplewrapper", (void *)&_cffi_externpy__rowtuplewrapper, _CFFI_OP(_CFFI_OP_EXTERN_PYTHON, 176), (void *)rowtuplewrapper },
  { "scalarfusionwrapper", (void *)&_cffi_externpy__scalarfusionwrapper, _CFFI_OP(_CFFI_OP_EXTERN_PYTHON, 172), (void *)scalarfusionwrapper },
  { "strcpy", (void *)_cffi_f_strcpy, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 154), (void *)_cffi_d_strcpy },
  { "strdup", (void *)_cffi_f_strdup, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 0), (void *)_cffi_d_strdup },
  { "strlen", (void *)_cffi_f_strlen, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 136), (void *)_cffi_d_strlen },
  { "systemwrapper", (void *)&_cffi_externpy__systemwrapper, _CFFI_OP(_CFFI_OP_EXTERN_PYTHON, 178), (void *)systemwrapper },
  { "tablefusionwrapper", (void *)&_cffi_externpy__tablefusionwrapper, _CFFI_OP(_CFFI_OP_EXTERN_PYTHON, 170), (void *)tablefusionwrapper },
  { "tablematerwrapper", (void *)&_cffi_externpy__tablematerwrapper, _CFFI_OP(_CFFI_OP_EXTERN_PYTHON, 180), (void *)tablematerwrapper },
  { "tabletuple", (void *)&_cffi_externpy__tabletuple, _CFFI_OP(_CFFI_OP_EXTERN_PYTHON, 176), (void *)tabletuple },
  { "tableudfwrapper", (void *)&_cffi_externpy__tableudfwrapper, _CFFI_OP(_CFFI_OP_EXTERN_PYTHON, 178), (void *)tableudfwrapper },
  { "tablevalue", (void *)&_cffi_externpy__tablevalue, _CFFI_OP(_CFFI_OP_EXTERN_PYTHON, 176), (void *)tablevalue },
  { "udfwrapper", (void *)&_cffi_externpy__udfwrapper, _CFFI_OP(_CFFI_OP_EXTERN_PYTHON, 174), (void *)udfwrapper },
  { "udfwrapper_parallel", (void *)&_cffi_externpy__udfwrapper_parallel, _CFFI_OP(_CFFI_OP_EXTERN_PYTHON, 173), (void *)udfwrapper_parallel },
};

static const struct _cffi_field_s _cffi_fields[] = {
  { "type", offsetof(ArrayInfo, type),
            sizeof(((ArrayInfo *)0)->type),
            _CFFI_OP(_CFFI_OP_NOOP, 5) },
  { "array", offsetof(ArrayInfo, array),
             sizeof(((ArrayInfo *)0)->array),
             _CFFI_OP(_CFFI_OP_NOOP, 132) },
  { "size", offsetof(ArrayInfo, size),
            sizeof(((ArrayInfo *)0)->size),
            _CFFI_OP(_CFFI_OP_NOOP, 5) },
  { "type", offsetof(ArrayInfo1, type),
            sizeof(((ArrayInfo1 *)0)->type),
            _CFFI_OP(_CFFI_OP_NOOP, 5) },
  { "array", offsetof(ArrayInfo1, array),
             sizeof(((ArrayInfo1 *)0)->array),
             _CFFI_OP(_CFFI_OP_NOOP, 132) },
  { "size", offsetof(ArrayInfo1, size),
            sizeof(((ArrayInfo1 *)0)->size),
            _CFFI_OP(_CFFI_OP_NOOP, 5) },
};

static const struct _cffi_struct_union_s _cffi_struct_unions[] = {
  { "$ArrayInfo", 165, _CFFI_F_CHECK_FIELDS,
    sizeof(ArrayInfo), offsetof(struct _cffi_align_typedef_ArrayInfo, y), 0, 3 },
  { "$ArrayInfo1", 164, _CFFI_F_CHECK_FIELDS,
    sizeof(ArrayInfo1), offsetof(struct _cffi_align_typedef_ArrayInfo1, y), 3, 3 },
};

static const struct _cffi_typename_s _cffi_typenames[] = {
  { "ArrayInfo", 165 },
  { "ArrayInfo1", 164 },
};

static const struct _cffi_type_context_s _cffi_type_context = {
  _cffi_types,
  _cffi_globals,
  _cffi_fields,
  _cffi_struct_unions,
  NULL,  /* no enums */
  _cffi_typenames,
  32,  /* num_globals */
  2,  /* num_struct_unions */
  0,  /* num_enums */
  2,  /* num_typenames */
  NULL,  /* no includes */
  184,  /* num_types */
  1,  /* flags */
};

#ifdef __GNUC__
#  pragma GCC visibility push(default)  /* for -fvisibility= */
#endif

#ifdef PYPY_VERSION
PyMODINIT_FUNC
_cffi_pypyinit_my_plugin(const void *p[])
{
    if (((intptr_t)p[0]) >= 0x0A03) {
        _cffi_call_python_org = (void(*)(struct _cffi_externpy_s *, char *))p[1];
    }
    p[0] = (const void *)0x2701;
    p[1] = &_cffi_type_context;
#if PY_MAJOR_VERSION >= 3
    return NULL;
#endif
}
#  ifdef _MSC_VER
     PyMODINIT_FUNC
#  if PY_MAJOR_VERSION >= 3
     PyInit_my_plugin(void) { return NULL; }
#  else
     initmy_plugin(void) { }
#  endif
#  endif
#elif PY_MAJOR_VERSION >= 3
PyMODINIT_FUNC
PyInit_my_plugin(void)
{
  return _cffi_init("my_plugin", 0x2701, &_cffi_type_context);
}
#else
PyMODINIT_FUNC
initmy_plugin(void)
{
  _cffi_init("my_plugin", 0x2701, &_cffi_type_context);
}
#endif

#ifdef __GNUC__
#  pragma GCC visibility pop
#endif
